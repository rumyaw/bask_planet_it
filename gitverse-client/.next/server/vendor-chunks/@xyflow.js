"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error001']();\n/**\n * Hook for accessing the internal store. Should only be used in rare cases.\n *\n * @public\n * @param selector\n * @param equalityFn\n * @returns The selected state slice\n *\n * @example\n * const nodes = useStore((state: ReactFlowState<MyNodeType>) => state.nodes);\n *\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\nfunction useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst selector$o = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$o);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: [\n                    \"Press enter or space to select a node.\",\n                    !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',\n                    \" Press delete to remove it and escape to cancel.\",\n                    ' '\n                ]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\nconst selector$n = (s)=>s.userSelectionActive ? 'none' : 'all';\nfunction Panel({ position = 'top-left', children, className, style, ...rest }) {\n    const pointerEvents = useStore(selector$n);\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ...rest,\n        children: children\n    });\n}\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // these fields exist in the global store and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    // these are values that are also passed directly to other components\n    // than the StoreUpdater. We can reduce the number of setStore calls\n    // by setting the same values here as prev fields.\n    translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewOnInit: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOnInitOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * Hook for handling key events.\n *\n * @public\n * @param param.keyCode - The key code (string or array of strings) to use\n * @param param.options - Options\n * @returns boolean\n */ function useKeyPress(// the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n// a string means a single key 'a' or a combination when '+' is used 'a+d'\n// an array means different possibilites. Explainer: ['a', 'd+s'] here the\n// user can use the single key 'a' or the combination 'd' + 's'\nkeyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set([]));\n    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n    // we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n    // and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n    // we can't find it in the list of keysToWatch.\n    const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"]).map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.split('+')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target || defaultDoc;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            event.preventDefault();\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes// we only want to compare same sizes of keyCode definitions\n    // and pressed keys. When the user specified 'Meta' as a key somewhere\n    // this would also be truthy without this filter when user presses 'Meta' + 'r'\n    .filter((keys)=>isUp || keys.length === pressedKeys.size)// since we want to support multiple possibilities only one of the\n    // combinations need to be part of the pressed keys\n    .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitView: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { nodeLookup, minZoom, maxZoom, panZoom, domNode } = store.getState();\n                        if (!panZoom || !domNode) {\n                            return Promise.resolve(false);\n                        }\n                        const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode);\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                            nodes: fitViewNodes,\n                            width,\n                            height,\n                            minZoom,\n                            maxZoom,\n                            panZoom\n                        }, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        const { width, height, maxZoom, panZoom } = store.getState();\n                        const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                        const centerX = width / 2 - x * nextZoom;\n                        const centerY = height / 2 - y * nextZoom;\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: centerX,\n                            y: centerY,\n                            zoom: nextZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {\n                        snapToGrid: true\n                    })=>{\n                        const { transform, snapGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(correctedPosition, transform, options.snapToGrid, snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n// This function applies changes to nodes or edges that are triggered by React Flow internally.\n// When you drag a node for example, React Flow will send a position change update.\n// This function then applies the changes and returns the updated elements.\nfunction applyChanges(changes, elements) {\n    const updatedElements = [];\n    // By storing a map of changes for each element, we can a quick lookup as we\n    // iterate over the elements array!\n    const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            // For a 'remove' change we can safely ignore any other changes queued for\n            // the same element, it's going to be removed anyway!\n            changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                // If we have some changes queued already, we can do a mutable update of\n                // that array and save ourselves some copying.\n                elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        // When there are no changes for an element we can just push it unmodified,\n        // no need to copy it.\n        if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        // For other types of changes, we want to start with a shallow copy of the\n        // object so React knows this element has changed. Sequential changes will\n        /// each _mutate_ this object, so there's only ever one copy.\n        const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    // we need to wait for all changes to be applied before adding new items\n    // to be able to add them at the correct index\n    if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        element.width = change.dimensions.width;\n                        element.height = change.dimensions.height;\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange} that describes how to update the edges of your flow in some way.\n If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.\n * @param changes - Array of changes to apply\n * @param nodes - Array of nodes to apply the changes to\n * @returns Array of updated nodes\n * @example\n *  const onNodesChange = useCallback(\n      (changes) => {\n        setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n      },\n      [setNodes],\n    );\n  \n    return (\n      <ReactFLow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n    );\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange} that describes how to update the edges of your flow in some way.\n If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.\n * @param changes - Array of changes to apply\n * @param edges - Array of edge to apply the changes to\n * @returns Array of updated edges\n * @example\n *  const onEdgesChange = useCallback(\n      (changes) => {\n        setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n      },\n      [setEdges],\n    );\n  \n    return (\n      <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n    );\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                // this hack is needed for nodes. When the user dragged a node, it's selected.\n                // When another node gets dragged, we need to deselect the previous one,\n                // in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is useable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNodeBase)(element);\n/**\n * Test whether an object is useable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    // Because we're using a ref above, we need some way to let React know when to\n    // actually process the queue. We flip this bit of state to `true` any time we\n    // mutate the queue and then flip it back to `false` after flushing the queue.\n    const [shouldFlush, setShouldFlush] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // A reference of all the batched updates to process before the next render. We\n    // want a reference here so multiple synchronous calls to `setNodes` etc can be\n    // batched together.\n    const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setShouldFlush(true)\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    // Layout effects are guaranteed to run before the next render which means we\n    // shouldn't run into any issues with stale state or weird issues that come from\n    // rendering things one frame later than expected (we used to use `setTimeout`).\n    useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            // Because we need to flip the state back to false after flushing, this should\n            // trigger the hook again (!). If the hook is being run again we know that any\n            // updates should have been processed by now and we can safely clear the queue\n            // and bail early.\n            if (!shouldFlush) {\n                queue.reset();\n                return;\n            }\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n            // Because we're using reactive state to trigger this effect, we need to flip\n            // it back to false.\n            setShouldFlush(false);\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        shouldFlush\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup } = store.getState();\n            // This is essentially an `Array.reduce` in imperative clothing. Processing\n            // this queue is a relatively hot path so we'd like to avoid the overhead of\n            // array methods where we can.\n            let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultNodes) {\n                setNodes(next);\n            } else if (onNodesChange) {\n                onNodesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: nodeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * Hook for accessing the ReactFlow instance.\n *\n * @public\n * @returns ReactFlowInstance\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        id: nodeToUse.id,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height,\n                        data: nodeToUse.data\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}-${id ?? null}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst deleteKeyOptions = {\n    actInsideInputWithModifier: false\n};\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const store = useStoreApi();\n    const prevSelectedNodesCount = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    const prevSelectedEdgesCount = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const edgeIdLookup = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Map());\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    const resetUserSelection = ()=>{\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null\n        });\n        prevSelectedNodesCount.current = 0;\n        prevSelectedEdgesCount.current = 0;\n    };\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        if (selectionInProgress.current) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode, edgeLookup } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        edgeIdLookup.current = new Map();\n        for (const [id, edge] of edgeLookup){\n            edgeIdLookup.current.set(edge.source, edgeIdLookup.current.get(edge.source)?.add(id) || new Set([\n                id\n            ]));\n            edgeIdLookup.current.set(edge.target, edgeIdLookup.current.get(edge.target)?.add(id) || new Set([\n                id\n            ]));\n        }\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, edgeLookup, transform, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const selectedNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Partial, true);\n        const selectedEdgeIds = new Set();\n        const selectedNodeIds = new Set();\n        for (const selectedNode of selectedNodes){\n            selectedNodeIds.add(selectedNode.id);\n            const edgeIds = edgeIdLookup.current.get(selectedNode.id);\n            if (edgeIds) {\n                for (const edgeId of edgeIds){\n                    selectedEdgeIds.add(edgeId);\n                }\n            }\n        }\n        if (prevSelectedNodesCount.current !== selectedNodeIds.size) {\n            prevSelectedNodesCount.current = selectedNodeIds.size;\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds, true);\n            triggerNodeChanges(changes);\n        }\n        if (prevSelectedEdgesCount.current !== selectedEdgeIds.size) {\n            prevSelectedEdgesCount.current = selectedEdgeIds.size;\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        // We only want to trigger click functions when in selection mode if\n        // the user did not move the mouse.\n        if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        if (prevSelectedNodesCount.current > 0) {\n            store.setState({\n                nodesSelectionActive: true\n            });\n        }\n        resetUserSelection();\n        onSelectionEnd?.(event);\n        // If the user kept holding the selectionKey during the selection,\n        // we need to reset the selectionInProgress, so the next click event is not prevented\n        if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n// this handler is called by\n// 1. the click handler when node is not draggable or selectNodesOnDrag = false\n// or\n// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\nfunction handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            // by default a node moves 5px on each key press\n            // if snap grid is enabled, we use that for the velocity\n            const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\nconst useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                // shows where you can start a connection from\n                // and where you can end it while connecting\n                connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The Handle component is a UI element that is used to connect nodes.\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                // when the user programmatically changes the source or handle position, we need to update the internals\n                // to make sure the edges are updated correctly\n                const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeExtent, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            // this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n            // here we only need to call it when selectNodesOnDrag=false\n            handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            store.setState({\n                ariaLiveMessage: `Moved selected node ${event.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        role: isFocusable ? 'button' : undefined,\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(// The split of responsibilities between NodeRenderer and\n            // NodeComponentWrapper may appear weird. However, it’s designed to\n            // minimize the cost of updates when individual nodes change.\n            //\n            // For example, when you’re dragging a single node, that node gets\n            // updated multiple times per second. If `NodeRenderer` were to update\n            // every time, it would have to re-run the `nodes.map()` loop every\n            // time. This gets pricey with hundreds of nodes, especially if every\n            // loop cycle does more than just rendering a JSX element!\n            //\n            // As a result of this choice, we took the following implementation\n            // decisions:\n            // - NodeRenderer subscribes *only* to node IDs – and therefore\n            //   rerender *only* when visible nodes are added or removed.\n            // - NodeRenderer performs all operations the result of which can be\n            //   shared between nodes (such as creating the `ResizeObserver`\n            //   instance, or subscribing to `selector`). This means extra prop\n            //   drilling into `NodeComponentWrapper`, but it means we need to run\n            //   these operations only once – instead of once per node.\n            // - Any operations that you’d normally write inside `nodes.map` are\n            //   moved into `NodeComponentWrapper`. This ensures they are\n            //   memorized – so if `NodeRenderer` *has* to rerender, it only\n            //   needs to regenerate the list of nodes, nothing else.\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n// that we can then use for creating our unique marker ids\nconst MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (typeof label === 'undefined' || !label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\nconst EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeTextComponent);\nfunction BaseEdge({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, className, interactionWidth = 20 }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                id: id,\n                style: style,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                    'react-flow__edge-path',\n                    className\n                ]),\n                markerEnd: markerEnd,\n                markerStart: markerStart\n            }),\n            interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }),\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\nfunction getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\nconst SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\nconst StepEdge = createStepEdge({\n    isInternal: false\n});\nconst StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst StraightEdge = createStraightEdge({\n    isInternal: false\n});\nconst StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst BezierEdge = createBezierEdge({\n    isInternal: false\n});\nconst BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\nfunction EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        setReconnecting(true);\n        onReconnectStart?.(event, edge, oppositeHandle.type);\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? 'button' : 'img',\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        width: s.width,\n        height: s.height,\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * Hook for accessing the connection state.\n *\n * @public\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, 0.5, 2, 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom: 0.5,\n        maxZoom: 2,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        fitViewOnInit: false,\n        fitViewDone: false,\n        fitViewOnInitOptions: undefined,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView: fitView$1, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>({\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView: fitView$1,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect } = get();\n                // setNodes() is called exclusively in response to user actions:\n                // - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n                // - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n                //\n                // When this happens, we take the note objects passed by the user and extend them with fields\n                // relevant for internal React Flow operations.\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                set({\n                    nodes\n                });\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            // Every node gets registerd at a ResizeObserver. Whenever a node\n            // changes its dimensions, this function is called to measure the\n            // new dimensions and update the nodes.\n            updateNodeInternals: (updates, params = {\n                triggerFitView: true\n            })=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, fitViewOnInit, fitViewDone, fitViewOnInitOptions, domNode, nodeOrigin, nodeExtent, debug, fitViewSync } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (params.triggerFitView) {\n                    // we call fitView once initially after all dimensions are set\n                    let nextFitViewDone = fitViewDone;\n                    if (!fitViewDone && fitViewOnInit) {\n                        nextFitViewDone = fitViewSync({\n                            ...fitViewOnInitOptions,\n                            nodes: fitViewOnInitOptions?.nodes\n                        });\n                    }\n                    // here we are cirmumventing the onNodesChange handler\n                    // in order to be able to display nodes even if the user\n                    // has not provided an onNodesChange handler.\n                    // Nodes are only rendered if they have a width and height\n                    // attribute which they get from this handler.\n                    set({\n                        fitViewDone: nextFitViewDone\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                for (const [id, dragItem] of nodeDragItems){\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: dragItem.position,\n                        dragging\n                    };\n                    if (dragItem?.expandParent && dragItem?.parentId && change.position) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: dragItem.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width,\n                                height: dragItem.measured.height\n                            }\n                        });\n                        change.position.x = Math.max(0, change.position.x);\n                        change.position.y = Math.max(0, change.position.y);\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { nodeLookup, parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                get().triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        // we need to unselect the internal node that was selected previously before we\n                        // send the change to the user to prevent it to be selected while dragging the new node\n                        internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            fitView: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n            },\n            // we can't call an asnychronous function in updateNodeInternals\n            // for that we created this sync version of fitView\n            fitViewSync: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return false;\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n                return fitViewNodes.size > 0;\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        }), Object.is);\nfunction ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (isWrapped) {\n        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        ...rest,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        \"data-testid\": \"rf__wrapper\",\n        id: id,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nvar index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\nfunction EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\nfunction ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * Hook for updating node internals.\n *\n * @public\n * @returns function for updating node internals\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * Hook for getting the current nodes from the store.\n *\n * @public\n * @returns An array of nodes\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * Hook for getting the current edges from the store.\n *\n * @public\n * @returns An array of edges\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * Hook for getting the current viewport from the store.\n *\n * @public\n * @returns The current viewport\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * Hook for managing the state of nodes - should only be used for prototyping / simple use cases.\n *\n * @public\n * @param initialNodes\n * @returns an array [nodes, setNodes, onNodesChange]\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * Hook for managing the state of edges - should only be used for prototyping / simple use cases.\n *\n * @public\n * @param initialEdges\n * @returns an array [edges, setEdges, onEdgesChange]\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * Hook for registering an onViewportChange handler.\n *\n * @public\n * @param params.onStart - gets called when the viewport starts changing\n * @param params.onChange - gets called when the viewport changes\n * @param params.onEnd - gets called when the viewport stops changing\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * Hook for registering an onSelectionChange handler.\n *\n * @public\n * @param params.onChange - The handler to register\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { hidden, internals }] of s.nodeLookup){\n            if (options.includeHiddenNodes || !hidden) {\n                if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(internals.userNode)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\nconst defaultOptions = {\n    includeHiddenNodes: false\n};\n/**\n * Hook which returns true when all nodes are initialized.\n *\n * @public\n * @param options.includeHiddenNodes - defaults to false\n * @returns boolean indicating whether all nodes are initialized\n */ function useNodesInitialized(options = defaultOptions) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @param param.type - handle type 'source' or 'target'\n * @param param.nodeId - node id - if not provided, the node id from the NodeIdContext is used\n * @param param.id - the handle id (this is only needed if the node has multiple handles of the same type)\n * @param param.onConnect - gets called when a connection is established\n * @param param.onDisconnect - gets called when a connection is removed\n * @returns an array with handle connections\n */ function useHandleConnections({ type, id = null, nodeId, onConnect, onDisconnect }) {\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}-${id}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.shallowNodeData);\n    return nodesData;\n}\n/**\n * Hook for getting an internal node by id\n *\n * @public\n * @param id - id of the node\n * @returns array with visible node ids\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\nvar BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\nconst Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\nfunction ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel = 'React Flow controls' }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel,\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: \"zoom in\",\n                        \"aria-label\": \"zoom in\",\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: \"zoom out\",\n                        \"aria-label\": \"zoom out\",\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: \"fit view\",\n                \"aria-label\": \"fit view\",\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: \"toggle interactivity\",\n                \"aria-label\": \"toggle interactivity\",\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\nconst Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>// The split of responsibilities between MiniMapNodes and\n            // NodeComponentWrapper may appear weird. However, it’s designed to\n            // minimize the cost of updates when individual nodes change.\n            //\n            // For more details, see a similar commit in `NodeRenderer/index.tsx`.\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const { x, y } = node.internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan, zoomStep = 10, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId);\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'string' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\nconst MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapComponent);\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const defaultPosition = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width;\n                                const height = change.height ?? node.measured.height;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                // when the parent was expanded by the child node, its position will be clamped at\n                                // 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                                nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes: true,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? {\n        ...style,\n        [colorStyleProp]: color\n    } : style;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: controlStyle,\n        children: children\n    });\n}\nconst NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ResizeControl);\nfunction NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\nfunction NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NDRCQUN3RDtBQUM5QjtBQUNvb0M7QUFDbDJCO0FBQ3BMO0FBQ3JEO0FBQ3pDO0FBQ0Q7QUFFekMsTUFBTTBGLDZCQUFlZCxvREFBYUEsQ0FBQztBQUNuQyxNQUFNZSxhQUFhRCxhQUFhRSxRQUFRO0FBRXhDLE1BQU1DLHNCQUFzQnpGLHlEQUFhLENBQUMsV0FBVztBQUNyRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVMwRixTQUFTQyxRQUFRLEVBQUVDLFVBQVU7SUFDbEMsTUFBTUMsUUFBUXBCLGlEQUFVQSxDQUFDYTtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9QLDJFQUFzQkEsQ0FBQ1csT0FBT0YsVUFBVUM7QUFDbkQ7QUFDQSxTQUFTRztJQUNMLE1BQU1GLFFBQVFwQixpREFBVUEsQ0FBQ2E7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPZiw4Q0FBT0E7K0JBQUMsSUFBTztnQkFDbEJzQixVQUFVSCxNQUFNRyxRQUFRO2dCQUN4QkMsVUFBVUosTUFBTUksUUFBUTtnQkFDeEJDLFdBQVdMLE1BQU1LLFNBQVM7WUFDOUI7OEJBQUk7UUFBQ0w7S0FBTTtBQUNmO0FBRUEsTUFBTU0sUUFBUTtJQUFFQyxTQUFTO0FBQU87QUFDaEMsTUFBTUMsZ0JBQWdCO0lBQ2xCQyxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRLENBQUM7SUFDVEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsTUFBTTtJQUNOQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNQyxxQkFBcUI7QUFD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LEtBQUtobEMsT0FBUyxHQUFHZ2xDLE1BQU1obEMsS0FBS3JCLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJc21DLElBQUk7WUFBSXJtQyxVQUFVQTtRQUFTO0lBQUc7QUFDclA7QUFFNG9CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJ1c2xhXFxPbmVEcml2ZVxc0KDQsNCx0L7Rh9C40Lkg0YHRgtC+0LtcXGdpdHZlcnNlLWNpY2RcXGdpdHZlcnNlLWNsaWVudFxcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxyZWFjdFxcZGlzdFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuaW1wb3J0IHsganN4cywgRnJhZ21lbnQsIGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCBjYyBmcm9tICdjbGFzc2NhdCc7XG5pbXBvcnQgeyBlcnJvck1lc3NhZ2VzLCBpbmZpbml0ZUV4dGVudCwgaXNJbnB1dERPTU5vZGUsIGdldEZpdFZpZXdOb2RlcywgZ2V0RGltZW5zaW9ucywgZml0VmlldywgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgWFlEcmFnLCBzbmFwUG9zaXRpb24sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgUG9zaXRpb24sIENvbm5lY3Rpb25Nb2RlLCBpc01vdXNlRXZlbnQsIFhZSGFuZGxlLCBnZXRIb3N0Rm9yRWxlbWVudCwgYWRkRWRnZSwgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgaXNOdW1lcmljLCBub2RlSGFzRGltZW5zaW9ucywgZ2V0Tm9kZURpbWVuc2lvbnMsIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBpc0VkZ2VWaXNpYmxlLCBNYXJrZXJUeXBlLCBjcmVhdGVNYXJrZXJJZHMsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldEJlemllclBhdGgsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRNYXJrZXJJZCwgZ2V0Q29ubmVjdGlvblN0YXR1cywgQ29ubmVjdGlvbkxpbmVUeXBlLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCBhZG9wdFVzZXJOb2RlcywgaW5pdGlhbENvbm5lY3Rpb24sIGRldldhcm4sIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCBoYW5kbGVFeHBhbmRQYXJlbnQsIHBhbkJ5LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFNlbGVjdGlvbk1vZGUsIGFkZEVkZ2UsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldEJlemllclBhdGgsIGdldENvbm5lY3RlZEVkZ2VzLCBnZXRFZGdlQ2VudGVyLCBnZXRJbmNvbWVycywgZ2V0Tm9kZXNCb3VuZHMsIGdldE91dGdvZXJzLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgcmVjb25uZWN0RWRnZSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgZm9yd2FyZFJlZiwgdXNlTGF5b3V0RWZmZWN0LCB1c2VDYWxsYmFjaywgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4sIGNyZWF0ZVdpdGhFcXVhbGl0eUZuIH0gZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciQxID0gU3RvcmVDb250ZXh0LlByb3ZpZGVyO1xuXG5jb25zdCB6dXN0YW5kRXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMDEnXSgpO1xuLyoqXG4gKiBIb29rIGZvciBhY2Nlc3NpbmcgdGhlIGludGVybmFsIHN0b3JlLiBTaG91bGQgb25seSBiZSB1c2VkIGluIHJhcmUgY2FzZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHNlbGVjdG9yXG4gKiBAcGFyYW0gZXF1YWxpdHlGblxuICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHN0YXRlIHNsaWNlXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUoKHN0YXRlOiBSZWFjdEZsb3dTdGF0ZTxNeU5vZGVUeXBlPikgPT4gc3RhdGUubm9kZXMpO1xuICpcbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBzZWxlY3RvciRvID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoc2VsZWN0b3Ikbyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9MSVZFX01FU1NBR0V9LSR7cmZJZH1gLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiLCBzdHlsZTogYXJpYUxpdmVTdHlsZSwgY2hpbGRyZW46IGFyaWFMaXZlTWVzc2FnZSB9KSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGlkOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBbXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLlwiLCAhZGlzYWJsZUtleWJvYXJkQTExeSAmJiAnWW91IGNhbiB0aGVuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBub2RlIGFyb3VuZC4nLCBcIiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLlwiLCAnICddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogXCJQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC5cIiB9KSwgIWRpc2FibGVLZXlib2FyZEExMXkgJiYganN4KEFyaWFMaXZlTWVzc2FnZSwgeyByZklkOiByZklkIH0pXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJG4gPSAocykgPT4gKHMudXNlclNlbGVjdGlvbkFjdGl2ZSA/ICdub25lJyA6ICdhbGwnKTtcbmZ1bmN0aW9uIFBhbmVsKHsgcG9zaXRpb24gPSAndG9wLWxlZnQnLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgcG9pbnRlckV2ZW50cyA9IHVzZVN0b3JlKHNlbGVjdG9yJG4pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiB7IC4uLnN0eWxlLCBwb2ludGVyRXZlbnRzIH0sIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXR0cmlidXRpb25cIiwgXCJkYXRhLW1lc3NhZ2VcIjogXCJQbGVhc2Ugb25seSBoaWRlIHRoaXMgYXR0cmlidXRpb24gd2hlbiB5b3UgYXJlIHN1YnNjcmliZWQgdG8gUmVhY3QgRmxvdyBQcm86IGh0dHBzOi8vcHJvLnJlYWN0Zmxvdy5kZXZcIiwgY2hpbGRyZW46IGpzeChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiwgY2hpbGRyZW46IFwiUmVhY3QgRmxvd1wiIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkbSA9IChzKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5wdXNoKG5vZGUuaW50ZXJuYWxzLnVzZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIGVkZ2VdIG9mIHMuZWRnZUxvb2t1cCkge1xuICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfTtcbn07XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXJJbm5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRtLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaCgoZm4pID0+IGZuKHBhcmFtcykpO1xuICAgIH0sIFtzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzLCBvblNlbGVjdGlvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM7XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gdXNlU3RvcmUoY2hhbmdlU2VsZWN0b3IpO1xuICAgIGlmIChvblNlbGVjdGlvbkNoYW5nZSB8fCBzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBqc3goU2VsZWN0aW9uTGlzdGVuZXJJbm5lciwgeyBvblNlbGVjdGlvbkNoYW5nZTogb25TZWxlY3Rpb25DaGFuZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBkZWZhdWx0Tm9kZU9yaWdpbiA9IFswLCAwXTtcbmNvbnN0IGRlZmF1bHRWaWV3cG9ydCA9IHsgeDogMCwgeTogMCwgem9vbTogMSB9O1xuXG4vKlxuICogVGhpcyBjb21wb25lbnQgaGVscHMgdXMgdG8gdXBkYXRlIHRoZSBzdG9yZSB3aXRoIHRoZSB2YWx1ZXMgY29taW5nIGZyb20gdGhlIHVzZXIuXG4gKiBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIHZhbHVlcyB3ZSBjYW4gdXBkYXRlIGRpcmVjdGx5IHdpdGggYHVzZURpcmVjdFN0b3JlVXBkYXRlcmAgKGxpa2UgYHNuYXBHcmlkYClcbiAqIGFuZCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVkaWNhdGVkIHNldHRlciBmdW5jdGlvbiBpbiB0aGUgc3RvcmUgKGxpa2UgYHNldE5vZGVzYCkuXG4gKi9cbi8vIHRoZXNlIGZpZWxkcyBleGlzdCBpbiB0aGUgZ2xvYmFsIHN0b3JlIGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1cCB0byBkYXRlXG5jb25zdCByZWFjdEZsb3dGaWVsZHNUb1RyYWNrID0gW1xuICAgICdub2RlcycsXG4gICAgJ2VkZ2VzJyxcbiAgICAnZGVmYXVsdE5vZGVzJyxcbiAgICAnZGVmYXVsdEVkZ2VzJyxcbiAgICAnb25Db25uZWN0JyxcbiAgICAnb25Db25uZWN0U3RhcnQnLFxuICAgICdvbkNvbm5lY3RFbmQnLFxuICAgICdvbkNsaWNrQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25DbGlja0Nvbm5lY3RFbmQnLFxuICAgICdub2Rlc0RyYWdnYWJsZScsXG4gICAgJ25vZGVzQ29ubmVjdGFibGUnLFxuICAgICdub2Rlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNSZWNvbm5lY3RhYmxlJyxcbiAgICAnZWxldmF0ZU5vZGVzT25TZWxlY3QnLFxuICAgICdlbGV2YXRlRWRnZXNPblNlbGVjdCcsXG4gICAgJ21pblpvb20nLFxuICAgICdtYXhab29tJyxcbiAgICAnbm9kZUV4dGVudCcsXG4gICAgJ29uTm9kZXNDaGFuZ2UnLFxuICAgICdvbkVkZ2VzQ2hhbmdlJyxcbiAgICAnZWxlbWVudHNTZWxlY3RhYmxlJyxcbiAgICAnY29ubmVjdGlvbk1vZGUnLFxuICAgICdzbmFwR3JpZCcsXG4gICAgJ3NuYXBUb0dyaWQnLFxuICAgICd0cmFuc2xhdGVFeHRlbnQnLFxuICAgICdjb25uZWN0T25DbGljaycsXG4gICAgJ2RlZmF1bHRFZGdlT3B0aW9ucycsXG4gICAgJ2ZpdFZpZXcnLFxuICAgICdmaXRWaWV3T3B0aW9ucycsXG4gICAgJ29uTm9kZXNEZWxldGUnLFxuICAgICdvbkVkZ2VzRGVsZXRlJyxcbiAgICAnb25EZWxldGUnLFxuICAgICdvbk5vZGVEcmFnJyxcbiAgICAnb25Ob2RlRHJhZ1N0YXJ0JyxcbiAgICAnb25Ob2RlRHJhZ1N0b3AnLFxuICAgICdvblNlbGVjdGlvbkRyYWcnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdGFydCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLFxuICAgICdvbk1vdmVTdGFydCcsXG4gICAgJ29uTW92ZScsXG4gICAgJ29uTW92ZUVuZCcsXG4gICAgJ25vUGFuQ2xhc3NOYW1lJyxcbiAgICAnbm9kZU9yaWdpbicsXG4gICAgJ2F1dG9QYW5PbkNvbm5lY3QnLFxuICAgICdhdXRvUGFuT25Ob2RlRHJhZycsXG4gICAgJ29uRXJyb3InLFxuICAgICdjb25uZWN0aW9uUmFkaXVzJyxcbiAgICAnaXNWYWxpZENvbm5lY3Rpb24nLFxuICAgICdzZWxlY3ROb2Rlc09uRHJhZycsXG4gICAgJ25vZGVEcmFnVGhyZXNob2xkJyxcbiAgICAnb25CZWZvcmVEZWxldGUnLFxuICAgICdkZWJ1ZycsXG4gICAgJ2F1dG9QYW5TcGVlZCcsXG4gICAgJ3BhbmVDbGlja0Rpc3RhbmNlJyxcbl07XG4vLyByZklkIGRvZXNuJ3QgZXhpc3QgaW4gUmVhY3RGbG93UHJvcHMsIGJ1dCBpdCdzIG9uZSBvZiB0aGUgZmllbGRzIHdlIHdhbnQgdG8gdXBkYXRlXG5jb25zdCBmaWVsZHNUb1RyYWNrID0gWy4uLnJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2ssICdyZklkJ107XG5jb25zdCBzZWxlY3RvciRsID0gKHMpID0+ICh7XG4gICAgc2V0Tm9kZXM6IHMuc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXM6IHMuc2V0RWRnZXMsXG4gICAgc2V0TWluWm9vbTogcy5zZXRNaW5ab29tLFxuICAgIHNldE1heFpvb206IHMuc2V0TWF4Wm9vbSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6IHMuc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgIHNldE5vZGVFeHRlbnQ6IHMuc2V0Tm9kZUV4dGVudCxcbiAgICByZXNldDogcy5yZXNldCxcbiAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogcy5zZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyxcbiAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZTogcy5zZXRQYW5lQ2xpY2tEaXN0YW5jZSxcbn0pO1xuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7XG4gICAgLy8gdGhlc2UgYXJlIHZhbHVlcyB0aGF0IGFyZSBhbHNvIHBhc3NlZCBkaXJlY3RseSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgLy8gdGhhbiB0aGUgU3RvcmVVcGRhdGVyLiBXZSBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2V0U3RvcmUgY2FsbHNcbiAgICAvLyBieSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlcyBoZXJlIGFzIHByZXYgZmllbGRzLlxuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZU9yaWdpbjogZGVmYXVsdE5vZGVPcmlnaW4sXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIHJmSWQ6ICcxJyxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZTogMCxcbn07XG5mdW5jdGlvbiBTdG9yZVVwZGF0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0TWluWm9vbSwgc2V0TWF4Wm9vbSwgc2V0VHJhbnNsYXRlRXh0ZW50LCBzZXROb2RlRXh0ZW50LCByZXNldCwgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldFBhbmVDbGlja0Rpc3RhbmNlLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAncGFuZUNsaWNrRGlzdGFuY2UnKVxuICAgICAgICAgICAgICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09uSW5pdDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPbkluaXRPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBjYXNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgXG4gICAgLy8gT25seSByZS1ydW4gdGhlIGVmZmVjdCBpZiBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB0cmFjayBjaGFuZ2VzXG4gICAgZmllbGRzVG9UcmFjay5tYXAoKGZpZWxkTmFtZSkgPT4gcHJvcHNbZmllbGROYW1lXSkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNZWRpYVF1ZXJ5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xufVxuLyoqXG4gKiBIb29rIGZvciByZWNlaXZpbmcgdGhlIGN1cnJlbnQgY29sb3IgbW9kZSBjbGFzcyAnZGFyaycgb3IgJ2xpZ2h0Jy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb2xvck1vZGUgLSBUaGUgY29sb3IgbW9kZSB0byB1c2UgKCdkYXJrJywgJ2xpZ2h0JyBvciAnc3lzdGVtJylcbiAqL1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKSB7XG4gICAgY29uc3QgW2NvbG9yTW9kZUNsYXNzLCBzZXRDb2xvck1vZGVDbGFzc10gPSB1c2VTdGF0ZShjb2xvck1vZGUgPT09ICdzeXN0ZW0nID8gbnVsbCA6IGNvbG9yTW9kZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yTW9kZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldENvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IGdldE1lZGlhUXVlcnkoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29sb3JNb2RlQ2xhc3MgPSAoKSA9PiBzZXRDb2xvck1vZGVDbGFzcyhtZWRpYVF1ZXJ5Py5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gICAgICAgIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKCk7XG4gICAgICAgIG1lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29sb3JNb2RlXSk7XG4gICAgcmV0dXJuIGNvbG9yTW9kZUNsYXNzICE9PSBudWxsID8gY29sb3JNb2RlQ2xhc3MgOiBnZXRNZWRpYVF1ZXJ5KCk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnO1xufVxuXG5jb25zdCBkZWZhdWx0RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbi8qKlxuICogSG9vayBmb3IgaGFuZGxpbmcga2V5IGV2ZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW0ua2V5Q29kZSAtIFRoZSBrZXkgY29kZSAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpIHRvIHVzZVxuICogQHBhcmFtIHBhcmFtLm9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIHVzZUtleVByZXNzKFxuLy8gdGhlIGtleWNvZGUgY2FuIGJlIGEgc3RyaW5nICdhJyBvciBhbiBhcnJheSBvZiBzdHJpbmdzIFsnYScsICdhK2QnXVxuLy8gYSBzdHJpbmcgbWVhbnMgYSBzaW5nbGUga2V5ICdhJyBvciBhIGNvbWJpbmF0aW9uIHdoZW4gJysnIGlzIHVzZWQgJ2ErZCdcbi8vIGFuIGFycmF5IG1lYW5zIGRpZmZlcmVudCBwb3NzaWJpbGl0ZXMuIEV4cGxhaW5lcjogWydhJywgJ2QrcyddIGhlcmUgdGhlXG4vLyB1c2VyIGNhbiB1c2UgdGhlIHNpbmdsZSBrZXkgJ2EnIG9yIHRoZSBjb21iaW5hdGlvbiAnZCcgKyAncydcbmtleUNvZGUgPSBudWxsLCBvcHRpb25zID0geyB0YXJnZXQ6IGRlZmF1bHREb2MsIGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiB0cnVlIH0pIHtcbiAgICBjb25zdCBba2V5UHJlc3NlZCwgc2V0S2V5UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpZiBhIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkIGluIG9yZGVyIHRvIHRyYWNrIGl0XG4gICAgY29uc3QgbW9kaWZpZXJQcmVzc2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwcmVzc2VkIGtleXMgaW4gb3JkZXIgdG8gc3VwcG9ydCBjb21iaW5hdGlvbnNcbiAgICBjb25zdCBwcmVzc2VkS2V5cyA9IHVzZVJlZihuZXcgU2V0KFtdKSk7XG4gICAgLy8ga2V5Q29kZXMgPSBhcnJheSB3aXRoIHNpbmdsZSBrZXlzIFtbJ2EnXV0gb3Iga2V5IGNvbWJpbmF0aW9ucyBbWydhJywgJ3MnXV1cbiAgICAvLyBrZXlzVG9XYXRjaCA9IGFycmF5IHdpdGggYWxsIGtleXMgZmxhdHRlbmVkIFsnYScsICdkJywgJ1NoaWZ0TGVmdCddXG4gICAgLy8gdXNlZCB0byBjaGVjayBpZiB3ZSBzdG9yZSBldmVudC5jb2RlIG9yIGV2ZW50LmtleS4gV2hlbiB0aGUgY29kZSBpcyBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaFxuICAgIC8vIHdlIHVzZSB0aGUgY29kZSBvdGhlcndpc2UgdGhlIGtleS4gRXhwbGFpbmVyOiBXaGVuIHlvdSBwcmVzcyB0aGUgbGVmdCBcImNvbW1hbmRcIiBrZXksIHRoZSBjb2RlIGlzIFwiTWV0YUxlZnRcIlxuICAgIC8vIGFuZCB0aGUga2V5IGlzIFwiTWV0YVwiLiBXZSB3YW50IHVzZXJzIHRvIGJlIGFibGUgdG8gcGFzcyBrZXlzIGFuZCBjb2RlcyBzbyB3ZSBhc3N1bWUgdGhhdCB0aGUga2V5IGlzIG1lYW50IHdoZW5cbiAgICAvLyB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoLlxuICAgIGNvbnN0IFtrZXlDb2Rlcywga2V5c1RvV2F0Y2hdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDb2RlQXJyID0gQXJyYXkuaXNBcnJheShrZXlDb2RlKSA/IGtleUNvZGUgOiBba2V5Q29kZV07XG4gICAgICAgICAgICBjb25zdCBrZXlzID0ga2V5Q29kZUFyci5maWx0ZXIoKGtjKSA9PiB0eXBlb2Yga2MgPT09ICdzdHJpbmcnKS5tYXAoKGtjKSA9PiBrYy5zcGxpdCgnKycpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNGbGF0ID0ga2V5cy5yZWR1Y2UoKHJlcywgaXRlbSkgPT4gcmVzLmNvbmNhdCguLi5pdGVtKSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlzLCBrZXlzRmxhdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtbXSwgW11dO1xuICAgIH0sIFtrZXlDb2RlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucz8udGFyZ2V0IHx8IGRlZmF1bHREb2M7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZlbnRBY3Rpb24gPSAoIW1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8IChtb2RpZmllclByZXNzZWQuY3VycmVudCAmJiAhb3B0aW9ucy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5hZGQoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIW9wdGlvbnMuYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0lucHV0RE9NTm9kZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgIC8vIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAuZmlsdGVyKChrZXlzKSA9PiBpc1VwIHx8IGtleXMubGVuZ3RoID09PSBwcmVzc2VkS2V5cy5zaXplKVxuICAgICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIHN1cHBvcnQgbXVsdGlwbGUgcG9zc2liaWxpdGllcyBvbmx5IG9uZSBvZiB0aGVcbiAgICAgICAgLy8gY29tYmluYXRpb25zIG5lZWQgdG8gYmUgcGFydCBvZiB0aGUgcHJlc3NlZCBrZXlzXG4gICAgICAgIC5zb21lKChrZXlzKSA9PiBrZXlzLmV2ZXJ5KChrKSA9PiBwcmVzc2VkS2V5cy5oYXMoaykpKSk7XG59XG5mdW5jdGlvbiB1c2VLZXlPckNvZGUoZXZlbnRDb2RlLCBrZXlzVG9XYXRjaCkge1xuICAgIHJldHVybiBrZXlzVG9XYXRjaC5pbmNsdWRlcyhldmVudENvZGUpID8gJ2NvZGUnIDogJ2tleSc7XG59XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdmlld3BvcnQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgem9vbUluOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tT3V0OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxIC8gMS4yLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZVRvKHpvb21MZXZlbCwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFpvb206ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgc2V0Vmlld3BvcnQ6IGFzeW5jICh2aWV3cG9ydCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtOiBbdFgsIHRZLCB0Wm9vbV0sIHBhblpvb20sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0LnggPz8gdFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnkgPz8gdFksXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZpZXdwb3J0Lnpvb20gPz8gdFpvb20sXG4gICAgICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWaWV3cG9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHpvb20gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRWaWV3OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuWm9vbSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhblpvb20gfHwgIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoZG9tTm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdFZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBub2RlczogZml0Vmlld05vZGVzLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1heFpvb20sIHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0eXBlb2Ygb3B0aW9ucz8uem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnpvb20gOiBtYXhab29tO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSB3aWR0aCAvIDIgLSB4ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb207XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRCb3VuZHM6IGFzeW5jIChib3VuZHMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuVG9GbG93UG9zaXRpb246IChjbGllbnRQb3NpdGlvbiwgb3B0aW9ucyA9IHsgc25hcFRvR3JpZDogdHJ1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2xpZW50UG9zaXRpb24ueCAtIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNsaWVudFBvc2l0aW9uLnkgLSBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50VG9SZW5kZXJlclBvaW50KGNvcnJlY3RlZFBvc2l0aW9uLCB0cmFuc2Zvcm0sIG9wdGlvbnMuc25hcFRvR3JpZCwgc25hcEdyaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb3dUb1NjcmVlblBvc2l0aW9uOiAoZmxvd1Bvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG93UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclBvc2l0aW9uID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoZmxvd1Bvc2l0aW9uLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJlbmRlcmVyUG9zaXRpb24ueCArIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlbmRlcmVyUG9zaXRpb24ueSArIGRvbVksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGNoYW5nZXMgdG8gbm9kZXMgb3IgZWRnZXMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IFJlYWN0IEZsb3cgaW50ZXJuYWxseS5cbi8vIFdoZW4geW91IGRyYWcgYSBub2RlIGZvciBleGFtcGxlLCBSZWFjdCBGbG93IHdpbGwgc2VuZCBhIHBvc2l0aW9uIGNoYW5nZSB1cGRhdGUuXG4vLyBUaGlzIGZ1bmN0aW9uIHRoZW4gYXBwbGllcyB0aGUgY2hhbmdlcyBhbmQgcmV0dXJucyB0aGUgdXBkYXRlZCBlbGVtZW50cy5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlbGVtZW50cykge1xuICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50cyA9IFtdO1xuICAgIC8vIEJ5IHN0b3JpbmcgYSBtYXAgb2YgY2hhbmdlcyBmb3IgZWFjaCBlbGVtZW50LCB3ZSBjYW4gYSBxdWljayBsb29rdXAgYXMgd2VcbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGVsZW1lbnRzIGFycmF5IVxuICAgIGNvbnN0IGNoYW5nZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkSXRlbUNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIGFkZEl0ZW1DaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlJyB8fCBjaGFuZ2UudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAvLyBGb3IgYSAncmVtb3ZlJyBjaGFuZ2Ugd2UgY2FuIHNhZmVseSBpZ25vcmUgYW55IG90aGVyIGNoYW5nZXMgcXVldWVkIGZvclxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgZWxlbWVudCwgaXQncyBnb2luZyB0byBiZSByZW1vdmVkIGFueXdheSFcbiAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudENoYW5nZXMgPSBjaGFuZ2VzTWFwLmdldChjaGFuZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21lIGNoYW5nZXMgcXVldWVkIGFscmVhZHksIHdlIGNhbiBkbyBhIG11dGFibGUgdXBkYXRlIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhcnJheSBhbmQgc2F2ZSBvdXJzZWx2ZXMgc29tZSBjb3B5aW5nLlxuICAgICAgICAgICAgICAgIGVsZW1lbnRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoZWxlbWVudC5pZCk7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG5vIGNoYW5nZXMgZm9yIGFuIGVsZW1lbnQgd2UgY2FuIGp1c3QgcHVzaCBpdCB1bm1vZGlmaWVkLFxuICAgICAgICAvLyBubyBuZWVkIHRvIGNvcHkgaXQuXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgJ3JlbW92ZScgY2hhbmdlIHF1ZXVlZCwgaXQnbGwgYmUgdGhlIG9ubHkgY2hhbmdlIGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZXNbMF0uaXRlbSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBvdGhlciB0eXBlcyBvZiBjaGFuZ2VzLCB3ZSB3YW50IHRvIHN0YXJ0IHdpdGggYSBzaGFsbG93IGNvcHkgb2YgdGhlXG4gICAgICAgIC8vIG9iamVjdCBzbyBSZWFjdCBrbm93cyB0aGlzIGVsZW1lbnQgaGFzIGNoYW5nZWQuIFNlcXVlbnRpYWwgY2hhbmdlcyB3aWxsXG4gICAgICAgIC8vLyBlYWNoIF9tdXRhdGVfIHRoaXMgb2JqZWN0LCBzbyB0aGVyZSdzIG9ubHkgZXZlciBvbmUgY29weS5cbiAgICAgICAgY29uc3QgdXBkYXRlZEVsZW1lbnQgPSB7IC4uLmVsZW1lbnQgfTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgYXBwbHlDaGFuZ2UoY2hhbmdlLCB1cGRhdGVkRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2godXBkYXRlZEVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIGFsbCBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgYmVmb3JlIGFkZGluZyBuZXcgaXRlbXNcbiAgICAvLyB0byBiZSBhYmxlIHRvIGFkZCB0aGVtIGF0IHRoZSBjb3JyZWN0IGluZGV4XG4gICAgaWYgKGFkZEl0ZW1DaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICBhZGRJdGVtQ2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5zcGxpY2UoY2hhbmdlLmluZGV4LCAwLCB7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVkRWxlbWVudHM7XG59XG4vLyBBcHBsaWVzIGEgc2luZ2xlIGNoYW5nZSB0byBhbiBlbGVtZW50LiBUaGlzIGlzIGEgKm11dGFibGUqIHVwZGF0ZS5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlKGNoYW5nZSwgZWxlbWVudCkge1xuICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZCA9IGNoYW5nZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbiA9IGNoYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRyYWdnaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZHJhZ2dpbmcgPSBjaGFuZ2UuZHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZGltZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkID8/PSB7fTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQud2lkdGggPSBjaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UucmVzaXppbmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXppbmcgPSBjaGFuZ2UucmVzaXppbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgbm9kZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBOb2RlQ2hhbmdlfSB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5IG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseVxuICogQHBhcmFtIG5vZGVzIC0gQXJyYXkgb2Ygbm9kZXMgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG9cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgbm9kZXNcbiAqIEBleGFtcGxlXG4gKiAgY29uc3Qgb25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGNoYW5nZXMpID0+IHtcbiAgICAgICAgc2V0Tm9kZXMoKG9sZE5vZGVzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG9sZE5vZGVzKSk7XG4gICAgICB9LFxuICAgICAgW3NldE5vZGVzXSxcbiAgICApO1xuICBcbiAgICByZXR1cm4gKFxuICAgICAgPFJlYWN0RkxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX0gLz5cbiAgICApO1xuICovXG5mdW5jdGlvbiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGVkZ2UgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBlZGdlcy5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgRWRnZUNoYW5nZX0gdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheSBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSBlZGdlcyAtIEFycmF5IG9mIGVkZ2UgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG9cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgZWRnZXNcbiAqIEBleGFtcGxlXG4gKiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGNoYW5nZXMpID0+IHtcbiAgICAgICAgc2V0RWRnZXMoKG9sZEVkZ2VzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIG9sZEVkZ2VzKSk7XG4gICAgICB9LFxuICAgICAgW3NldEVkZ2VzXSxcbiAgICApO1xuICBcbiAgICByZXR1cm4gKFxuICAgICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX0gLz5cbiAgICApO1xuICovXG5mdW5jdGlvbiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaWQsIHNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhpdGVtcywgc2VsZWN0ZWRJZHMgPSBuZXcgU2V0KCksIG11dGF0ZUl0ZW0gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3Qgd2lsbEJlU2VsZWN0ZWQgPSBzZWxlY3RlZElkcy5oYXMoaWQpO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNldCBhbGwgaXRlbXMgdG8gc2VsZWN0ZWQ9ZmFsc2Ugb24gdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICBpZiAoIShpdGVtLnNlbGVjdGVkID09PSB1bmRlZmluZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSAmJiBpdGVtLnNlbGVjdGVkICE9PSB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG11dGF0ZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhY2sgaXMgbmVlZGVkIGZvciBub2Rlcy4gV2hlbiB0aGUgdXNlciBkcmFnZ2VkIGEgbm9kZSwgaXQncyBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFub3RoZXIgbm9kZSBnZXRzIGRyYWdnZWQsIHdlIG5lZWQgdG8gZGVzZWxlY3QgdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBoYXZlIG9ubHkgb25lIHNlbGVjdGVkIG5vZGUgYXQgYSB0aW1lIC0gdGhlIG9uTm9kZXNDaGFuZ2UgY2FsbGJhY2sgY29tZXMgdG9vIGxhdGUgaGVyZSA6L1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB3aWxsQmVTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgd2lsbEJlU2VsZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoeyBpdGVtcyA9IFtdLCBsb29rdXAsIH0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgaXRlbXNMb29rdXAgPSBuZXcgTWFwKGl0ZW1zLm1hcCgoaXRlbSkgPT4gW2l0ZW0uaWQsIGl0ZW1dKSk7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGl0ZW1dIG9mIGl0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBsb29rdXBJdGVtID0gbG9va3VwLmdldChpdGVtLmlkKTtcbiAgICAgICAgY29uc3Qgc3RvcmVJdGVtID0gbG9va3VwSXRlbT8uaW50ZXJuYWxzPy51c2VyTm9kZSA/PyBsb29rdXBJdGVtO1xuICAgICAgICBpZiAoc3RvcmVJdGVtICE9PSB1bmRlZmluZWQgJiYgc3RvcmVJdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZDogaXRlbS5pZCwgaXRlbTogaXRlbSwgdHlwZTogJ3JlcGxhY2UnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaXRlbTogaXRlbSwgdHlwZTogJ2FkZCcsIGluZGV4IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkXSBvZiBsb29rdXApIHtcbiAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBpdGVtc0xvb2t1cC5nZXQoaWQpO1xuICAgICAgICBpZiAobmV4dE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQsIHR5cGU6ICdyZW1vdmUnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYSBOb2RlXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBOb2RlXG4gKi9cbmNvbnN0IGlzTm9kZSA9IChlbGVtZW50KSA9PiBpc05vZGVCYXNlKGVsZW1lbnQpO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYW4gRWRnZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gRWRnZVxuICovXG5jb25zdCBpc0VkZ2UgPSAoZWxlbWVudCkgPT4gaXNFZGdlQmFzZShlbGVtZW50KTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLy8gQmVjYXVzZSB3ZSdyZSB1c2luZyBhIHJlZiBhYm92ZSwgd2UgbmVlZCBzb21lIHdheSB0byBsZXQgUmVhY3Qga25vdyB3aGVuIHRvXG4gICAgLy8gYWN0dWFsbHkgcHJvY2VzcyB0aGUgcXVldWUuIFdlIGZsaXAgdGhpcyBiaXQgb2Ygc3RhdGUgdG8gYHRydWVgIGFueSB0aW1lIHdlXG4gICAgLy8gbXV0YXRlIHRoZSBxdWV1ZSBhbmQgdGhlbiBmbGlwIGl0IGJhY2sgdG8gYGZhbHNlYCBhZnRlciBmbHVzaGluZyB0aGUgcXVldWUuXG4gICAgY29uc3QgW3Nob3VsZEZsdXNoLCBzZXRTaG91bGRGbHVzaF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgIC8vIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTaG91bGRGbHVzaCh0cnVlKSkpO1xuICAgIC8vIExheW91dCBlZmZlY3RzIGFyZSBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIHdoaWNoIG1lYW5zIHdlXG4gICAgLy8gc2hvdWxkbid0IHJ1biBpbnRvIGFueSBpc3N1ZXMgd2l0aCBzdGFsZSBzdGF0ZSBvciB3ZWlyZCBpc3N1ZXMgdGhhdCBjb21lIGZyb21cbiAgICAvLyByZW5kZXJpbmcgdGhpbmdzIG9uZSBmcmFtZSBsYXRlciB0aGFuIGV4cGVjdGVkICh3ZSB1c2VkIHRvIHVzZSBgc2V0VGltZW91dGApLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBCZWNhdXNlIHdlIG5lZWQgdG8gZmxpcCB0aGUgc3RhdGUgYmFjayB0byBmYWxzZSBhZnRlciBmbHVzaGluZywgdGhpcyBzaG91bGRcbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgaG9vayBhZ2FpbiAoISkuIElmIHRoZSBob29rIGlzIGJlaW5nIHJ1biBhZ2FpbiB3ZSBrbm93IHRoYXQgYW55XG4gICAgICAgIC8vIHVwZGF0ZXMgc2hvdWxkIGhhdmUgYmVlbiBwcm9jZXNzZWQgYnkgbm93IGFuZCB3ZSBjYW4gc2FmZWx5IGNsZWFyIHRoZSBxdWV1ZVxuICAgICAgICAvLyBhbmQgYmFpbCBlYXJseS5cbiAgICAgICAgaWYgKCFzaG91bGRGbHVzaCkge1xuICAgICAgICAgICAgcXVldWUucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWV1ZUl0ZW1zID0gcXVldWUuZ2V0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuUXVldWUocXVldWVJdGVtcyk7XG4gICAgICAgICAgICBxdWV1ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlY2F1c2Ugd2UncmUgdXNpbmcgcmVhY3RpdmUgc3RhdGUgdG8gdHJpZ2dlciB0aGlzIGVmZmVjdCwgd2UgbmVlZCB0byBmbGlwXG4gICAgICAgIC8vIGl0IGJhY2sgdG8gZmFsc2UuXG4gICAgICAgIHNldFNob3VsZEZsdXNoKGZhbHNlKTtcbiAgICB9LCBbc2hvdWxkRmx1c2hdKTtcbiAgICByZXR1cm4gcXVldWU7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWV1ZShjYikge1xuICAgIGxldCBxdWV1ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldDogKCkgPT4gcXVldWUsXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoOiAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgQmF0Y2hDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogVGhpcyBpcyBhIGNvbnRleHQgcHJvdmlkZXIgdGhhdCBob2xkcyBhbmQgcHJvY2Vzc2VzIHRoZSBub2RlIGFuZCBlZGdlIHVwZGF0ZSBxdWV1ZXNcbiAqIHRoYXQgYXJlIG5lZWRlZCB0byBoYW5kbGUgc2V0Tm9kZXMsIGFkZE5vZGVzLCBzZXRFZGdlcyBhbmQgYWRkRWRnZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEJhdGNoUHJvdmlkZXIoeyBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUXVldWVIYW5kbGVyID0gdXNlQ2FsbGJhY2soKHF1ZXVlSXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlcyA9IFtdLCBzZXROb2RlcywgaGFzRGVmYXVsdE5vZGVzLCBvbk5vZGVzQ2hhbmdlLCBub2RlTG9va3VwIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGFuIGBBcnJheS5yZWR1Y2VgIGluIGltcGVyYXRpdmUgY2xvdGhpbmcuIFByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhpcyBxdWV1ZSBpcyBhIHJlbGF0aXZlbHkgaG90IHBhdGggc28gd2UnZCBsaWtlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZCBvZlxuICAgICAgICAvLyBhcnJheSBtZXRob2RzIHdoZXJlIHdlIGNhbi5cbiAgICAgICAgbGV0IG5leHQgPSBub2RlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgIHNldE5vZGVzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uTm9kZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBub2RlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHVzZVF1ZXVlKG5vZGVRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UsIGVkZ2VMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGxldCBuZXh0ID0gZWRnZXM7XG4gICAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBxdWV1ZUl0ZW1zKSB7XG4gICAgICAgICAgICBuZXh0ID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKG5leHQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBzZXRFZGdlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbkVkZ2VzQ2hhbmdlKSB7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cDogZWRnZUxvb2t1cCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlZGdlUXVldWUgPSB1c2VRdWV1ZShlZGdlUXVldWVIYW5kbGVyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbm9kZVF1ZXVlLCBlZGdlUXVldWUgfSksIFtdKTtcbiAgICByZXR1cm4ganN4KEJhdGNoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJhdGNoQ29udGV4dCgpIHtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VDb250ZXh0KEJhdGNoQ29udGV4dCk7XG4gICAgaWYgKCFiYXRjaENvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VCYXRjaENvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJhdGNoUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoQ29udGV4dDtcbn1cblxuY29uc3Qgc2VsZWN0b3IkayA9IChzKSA9PiAhIXMucGFuWm9vbTtcbi8qKlxuICogSG9vayBmb3IgYWNjZXNzaW5nIHRoZSBSZWFjdEZsb3cgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgUmVhY3RGbG93SW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gdXNlUmVhY3RGbG93KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0SGVscGVyID0gdXNlVmlld3BvcnRIZWxwZXIoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgYmF0Y2hDb250ZXh0ID0gdXNlQmF0Y2hDb250ZXh0KCk7XG4gICAgY29uc3Qgdmlld3BvcnRJbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJGspO1xuICAgIGNvbnN0IGdlbmVyYWxIZWxwZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgZ2V0SW50ZXJuYWxOb2RlID0gKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3Qgc2V0Tm9kZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0Lm5vZGVRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRFZGdlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldE5vZGVSZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVUb1VzZSA9IGlzTm9kZShub2RlKSA/IG5vZGUgOiBub2RlTG9va3VwLmdldChub2RlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbm9kZVRvVXNlLnBhcmVudElkXG4gICAgICAgICAgICAgICAgPyBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24obm9kZVRvVXNlLnBvc2l0aW9uLCBub2RlVG9Vc2UubWVhc3VyZWQsIG5vZGVUb1VzZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbilcbiAgICAgICAgICAgICAgICA6IG5vZGVUb1VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVXaXRoUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vZGVUb1VzZS5pZCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZVRvVXNlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlVG9Vc2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlVG9Vc2UubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlVG9Vc2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRhdGE6IG5vZGVUb1VzZS5kYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlVG9SZWN0KG5vZGVXaXRoUG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVOb2RlID0gKGlkLCBub2RlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXROb2RlcygocHJldk5vZGVzKSA9PiBwcmV2Tm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdHlwZW9mIG5vZGVVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBub2RlVXBkYXRlKG5vZGUpIDogbm9kZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc05vZGUobmV4dE5vZGUpID8gbmV4dE5vZGUgOiB7IC4uLm5vZGUsIC4uLm5leHROb2RlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVFZGdlID0gKGlkLCBlZGdlVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICBzZXRFZGdlcygocHJldkVkZ2VzKSA9PiBwcmV2RWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFZGdlID0gdHlwZW9mIGVkZ2VVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBlZGdlVXBkYXRlKGVkZ2UpIDogZWRnZVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSAmJiBpc0VkZ2UobmV4dEVkZ2UpID8gbmV4dEVkZ2UgOiB7IC4uLmVkZ2UsIC4uLm5leHRFZGdlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Tm9kZXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgIGdldE5vZGU6IChpZCkgPT4gZ2V0SW50ZXJuYWxOb2RlKGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlLFxuICAgICAgICAgICAgZ2V0SW50ZXJuYWxOb2RlLFxuICAgICAgICAgICAgZ2V0RWRnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWRnZTogKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmVkZ2VMb29rdXAuZ2V0KGlkKSxcbiAgICAgICAgICAgIHNldE5vZGVzLFxuICAgICAgICAgICAgc2V0RWRnZXMsXG4gICAgICAgICAgICBhZGROb2RlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRFZGdlczogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogW3BheWxvYWRdO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaCgoZWRnZXMpID0+IFsuLi5lZGdlcywgLi4ubmV3RWRnZXNdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b09iamVjdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXSwgdHJhbnNmb3JtIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMubWFwKChuKSA9PiAoeyAuLi5uIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLm1hcCgoZSkgPT4gKHsgLi4uZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVFbGVtZW50czogYXN5bmMgKHsgbm9kZXM6IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXM6IGVkZ2VzVG9SZW1vdmUgPSBbXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcywgZWRnZXMsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBvbkRlbGV0ZSwgb25CZWZvcmVEZWxldGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0gPSBhd2FpdCBnZXRFbGVtZW50c1RvUmVtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZURlbGV0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ0VkZ2VzID0gbWF0Y2hpbmdFZGdlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nTm9kZXMgPSBtYXRjaGluZ05vZGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBtYXRjaGluZ0VkZ2VzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbkVkZ2VzRGVsZXRlPy4obWF0Y2hpbmdFZGdlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbWF0Y2hpbmdOb2Rlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2Rlc0RlbGV0ZT8uKG1hdGNoaW5nTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2RlcyB8fCBoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlPy4oeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWROb2RlczogbWF0Y2hpbmdOb2RlcywgZGVsZXRlZEVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW50ZXJzZWN0aW5nTm9kZXM6IChub2RlT3JSZWN0LCBwYXJ0aWFsbHkgPSB0cnVlLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNOb2Rlc09wdGlvbiA9IG5vZGVzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAobm9kZXMgfHwgc3RvcmUuZ2V0U3RhdGUoKS5ub2RlcykuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUgJiYgIWlzUmVjdCAmJiAobi5pZCA9PT0gbm9kZU9yUmVjdC5pZCB8fCAhaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlUmVjdCA9IG5vZGVUb1JlY3QoaGFzTm9kZXNPcHRpb24gPyBuIDogaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKGN1cnJOb2RlUmVjdCwgbm9kZVJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc05vZGVJbnRlcnNlY3Rpbmc6IChub2RlT3JSZWN0LCBhcmVhLCBwYXJ0aWFsbHkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWN0ID0gaXNSZWN0T2JqZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gaXNSZWN0ID8gbm9kZU9yUmVjdCA6IGdldE5vZGVSZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEobm9kZVJlY3QsIGFyZWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlTm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlKGlkLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShub2RlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLm5vZGUsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLm5vZGUsIGRhdGE6IHsgLi4ubm9kZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRWRnZSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlKGlkLCAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShlZGdlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLmVkZ2UsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLmVkZ2UsIGRhdGE6IHsgLi4uZWRnZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Tm9kZXNCb3VuZHM6IChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNCb3VuZHMobm9kZXMsIHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRIYW5kbGVDb25uZWN0aW9uczogKHsgdHlwZSwgaWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfS0ke3R5cGV9LSR7aWQgPz8gbnVsbH1gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCBkZWxldGVLZXlPcHRpb25zID0geyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfTtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCBkZWxldGVLZXlPcHRpb25zKTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlciAmJiBkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGogPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgbGliOiBzLmxpYixcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGosIHNoYWxsb3cpO1xuICAgIGNvbnN0IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHpvb21BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuWm9vbSA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIGNvbnN0IG9uVHJhbnNmb3JtQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4oeyB4OiB0cmFuc2Zvcm1bMF0sIHk6IHRyYW5zZm9ybVsxXSwgem9vbTogdHJhbnNmb3JtWzJdIH0pO1xuICAgICAgICBpZiAoIWlzQ29udHJvbGxlZFZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQgPSBYWVBhblpvb20oe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHBhbmVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2U6IChwYW5lRHJhZ2dpbmcpID0+IHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nIH0pLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0OiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvbk1vdmVTdGFydCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb206IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlLCBvbk1vdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZT8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ6IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlRW5kLCBvbk1vdmVFbmQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBwYW5ab29tLmN1cnJlbnQuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwYW5ab29tOiBwYW5ab29tLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbeCwgeSwgem9vbV0sXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudC5jbG9zZXN0KCcucmVhY3QtZmxvdycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhblpvb20uY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBsaWIsXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgIF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3JlbmRlcmVyXCIsIHJlZjogem9vbVBhbmUsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkaSA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICB1c2VyU2VsZWN0aW9uUmVjdDogcy51c2VyU2VsZWN0aW9uUmVjdCxcbn0pO1xuZnVuY3Rpb24gVXNlclNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25SZWN0IH0gPSB1c2VTdG9yZShzZWxlY3RvciRpLCBzaGFsbG93KTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgdXNlclNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmNvbnN0IHdyYXBIYW5kbGVyID0gKGhhbmRsZXIsIGNvbnRhaW5lclJlZikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyPy4oZXZlbnQpO1xuICAgIH07XG59O1xuY29uc3Qgc2VsZWN0b3IkaCA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGRyYWdnaW5nOiBzLnBhbmVEcmFnZ2luZyxcbn0pO1xuZnVuY3Rpb24gUGFuZSh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIHNlbGVjdGlvbk9uRHJhZywgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0ZWROb2Rlc0NvdW50ID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IHByZXZTZWxlY3RlZEVkZ2VzQ291bnQgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3QgZWRnZUlkTG9va3VwID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nIH0gPSB1c2VTdG9yZShzZWxlY3RvciRoLCBzaGFsbG93KTtcbiAgICBjb25zdCBoYXNBY3RpdmVTZWxlY3Rpb24gPSBlbGVtZW50c1NlbGVjdGFibGUgJiYgKGlzU2VsZWN0aW5nIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUpO1xuICAgIC8vIFVzZWQgdG8gcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXRzIGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uSW5Qcm9ncmVzcyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgcmVzZXRVc2VyU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLCB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCB9KTtcbiAgICAgICAgcHJldlNlbGVjdGVkTm9kZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgICAgcHJldlNlbGVjdGVkRWRnZXNDb3VudC5jdXJyZW50ID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gV2UgcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXQgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXNldFNlbGVjdGVkRWxlbWVudHMsIGRvbU5vZGUsIGVkZ2VMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50ID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlIHx8XG4gICAgICAgICAgICAhaXNTZWxlY3RpbmcgfHxcbiAgICAgICAgICAgIGV2ZW50LmJ1dHRvbiAhPT0gMCB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXIuY3VycmVudCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBlZGdlSWRMb29rdXAuY3VycmVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGVkZ2VdIG9mIGVkZ2VMb29rdXApIHtcbiAgICAgICAgICAgIGVkZ2VJZExvb2t1cC5jdXJyZW50LnNldChlZGdlLnNvdXJjZSwgZWRnZUlkTG9va3VwLmN1cnJlbnQuZ2V0KGVkZ2Uuc291cmNlKT8uYWRkKGlkKSB8fCBuZXcgU2V0KFtpZF0pKTtcbiAgICAgICAgICAgIGVkZ2VJZExvb2t1cC5jdXJyZW50LnNldChlZGdlLnRhcmdldCwgZWRnZUlkTG9va3VwLmN1cnJlbnQuZ2V0KGVkZ2UudGFyZ2V0KT8uYWRkKGlkKSB8fCBuZXcgU2V0KFtpZF0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIGVkZ2VMb29rdXAsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBnZXROb2Rlc0luc2lkZShub2RlTG9va3VwLCBuZXh0VXNlclNlbGVjdFJlY3QsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QYXJ0aWFsLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0ZWROb2RlIG9mIHNlbGVjdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZUlkcy5hZGQoc2VsZWN0ZWROb2RlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VJZHMgPSBlZGdlSWRMb29rdXAuY3VycmVudC5nZXQoc2VsZWN0ZWROb2RlLmlkKTtcbiAgICAgICAgICAgIGlmIChlZGdlSWRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlZGdlSWQgb2YgZWRnZUlkcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEVkZ2VJZHMuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgIT09IHNlbGVjdGVkTm9kZUlkcy5zaXplKSB7XG4gICAgICAgICAgICBwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgPSBzZWxlY3RlZE5vZGVJZHMuc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIHNlbGVjdGVkTm9kZUlkcywgdHJ1ZSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTZWxlY3RlZEVkZ2VzQ291bnQuY3VycmVudCAhPT0gc2VsZWN0ZWRFZGdlSWRzLnNpemUpIHtcbiAgICAgICAgICAgIHByZXZTZWxlY3RlZEVkZ2VzQ291bnQuY3VycmVudCA9IHNlbGVjdGVkRWRnZUlkcy5zaXplO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzKTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbmV4dFVzZXJTZWxlY3RSZWN0LFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICFzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnJlbGVhc2VQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U2VsZWN0ZWROb2Rlc0NvdW50LmN1cnJlbnQgPiAwKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0VXNlclNlbGVjdGlvbigpO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKHNlbGVjdGlvbktleVByZXNzZWQgfHwgc2VsZWN0aW9uT25EcmFnKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygwKSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmUnLCB7IGRyYWdnYWJsZSwgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvblBvaW50ZXJFbnRlcjogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogb25QYW5lTW91c2VFbnRlciwgb25Qb2ludGVyRG93bjogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyRG93biA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyTW92ZTogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyTW92ZSA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlclVwIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgcmVmOiBjb250YWluZXIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtjaGlsZHJlbiwganN4KFVzZXJTZWxlY3Rpb24sIHt9KV0gfSkpO1xufVxuXG4vLyB0aGlzIGhhbmRsZXIgaXMgY2FsbGVkIGJ5XG4vLyAxLiB0aGUgY2xpY2sgaGFuZGxlciB3aGVuIG5vZGUgaXMgbm90IGRyYWdnYWJsZSBvciBzZWxlY3ROb2Rlc09uRHJhZyA9IGZhbHNlXG4vLyBvclxuLy8gMi4gdGhlIG9uIGRyYWcgc3RhcnQgaGFuZGxlciB3aGVuIG5vZGUgaXMgZHJhZ2dhYmxlIGFuZCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWVcbmZ1bmN0aW9uIGhhbmRsZU5vZGVDbGljayh7IGlkLCBzdG9yZSwgdW5zZWxlY3QgPSBmYWxzZSwgbm9kZVJlZiwgfSkge1xuICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWROb2RlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZUxvb2t1cCwgb25FcnJvciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEyJ10oaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICBpZiAoIW5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlcyhbaWRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5zZWxlY3QgfHwgKG5vZGUuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpKSB7XG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbbm9kZV0sIGVkZ2VzOiBbXSB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGVSZWY/LmN1cnJlbnQ/LmJsdXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgWFlEcmFnIGhlbHBlciBmcm9tIEB4eWZsb3cvc3lzdGVtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHh5RHJhZyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHh5RHJhZy5jdXJyZW50ID0gWFlEcmFnKHtcbiAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBvbk5vZGVNb3VzZURvd246IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0b3A6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IG5vZGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW25vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRpc2FibGVkLCBpc1NlbGVjdGFibGUsIG5vZGVSZWYsIG5vZGVJZF0pO1xuICAgIHJldHVybiBkcmFnZ2luZztcbn1cblxuY29uc3Qgc2VsZWN0ZWRBbmREcmFnZ2FibGUgPSAobm9kZXNEcmFnZ2FibGUpID0+IChuKSA9PiBuLnNlbGVjdGVkICYmIChuLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG4uZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuLyoqXG4gKiBIb29rIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9ucyBieSBwYXNzaW5nIGEgZGlyZWN0aW9uIGFuZCBmYWN0b3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VDYWxsYmFjaygocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVudCwgc25hcFRvR3JpZCwgc25hcEdyaWQsIG5vZGVzRHJhZ2dhYmxlLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkQW5kRHJhZ2dhYmxlKG5vZGVzRHJhZ2dhYmxlKTtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBhIG5vZGUgbW92ZXMgNXB4IG9uIGVhY2gga2V5IHByZXNzXG4gICAgICAgIC8vIGlmIHNuYXAgZ3JpZCBpcyBlbmFibGVkLCB3ZSB1c2UgdGhhdCBmb3IgdGhlIHZlbG9jaXR5XG4gICAgICAgIGNvbnN0IHhWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzBdIDogNTtcbiAgICAgICAgY29uc3QgeVZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMV0gOiA1O1xuICAgICAgICBjb25zdCB4RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueCAqIHhWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgY29uc3QgeURpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnkgKiB5VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCArIHhEaWZmLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSArIHlEaWZmLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZSB9ID0gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgbm9kZVVwZGF0ZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMobm9kZVVwZGF0ZXMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbW92ZVNlbGVjdGVkTm9kZXM7XG59XG5cbmNvbnN0IE5vZGVJZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIgPSBOb2RlSWRDb250ZXh0LlByb3ZpZGVyO1xuTm9kZUlkQ29udGV4dC5Db25zdW1lcjtcbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIHZhbGlkOiBjb25uZWN0aW5nVG8gJiYgaXNWYWxpZCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIEhhbmRsZUNvbXBvbmVudCh7IHR5cGUgPSAnc291cmNlJywgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGlzVmFsaWRDb25uZWN0aW9uLCBpc0Nvbm5lY3RhYmxlID0gdHJ1ZSwgaXNDb25uZWN0YWJsZVN0YXJ0ID0gdHJ1ZSwgaXNDb25uZWN0YWJsZUVuZCA9IHRydWUsIGlkLCBvbkNvbm5lY3QsIGNoaWxkcmVuLCBjbGFzc05hbWUsIG9uTW91c2VEb3duLCBvblRvdWNoU3RhcnQsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgaGFuZGxlSWQgPSBpZCB8fCBudWxsO1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gdHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IHsgY29ubmVjdE9uQ2xpY2ssIG5vUGFuQ2xhc3NOYW1lLCByZklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciRnLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IGNvbm5lY3RpbmdGcm9tLCBjb25uZWN0aW5nVG8sIGNsaWNrQ29ubmVjdGluZywgaXNQb3NzaWJsZUVuZEhhbmRsZSwgY29ubmVjdGlvbkluUHJvY2VzcywgdmFsaWQgfSA9IHVzZVN0b3JlKGNvbm5lY3RpbmdTZWxlY3Rvcihub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEwJ10oKSk7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29ubmVjdEV4dGVuZGVkID0gKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucywgb25Db25uZWN0OiBvbkNvbm5lY3RBY3Rpb24sIGhhc0RlZmF1bHRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgZWRnZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRFZGdlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgc2V0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzZXRFZGdlcyhhZGRFZGdlKGVkZ2VQYXJhbXMsIGVkZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Db25uZWN0QWN0aW9uPy4oZWRnZVBhcmFtcyk7XG4gICAgICAgIG9uQ29ubmVjdD8uKGVkZ2VQYXJhbXMpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTW91c2VUcmlnZ2VyZWQgPSBpc01vdXNlRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICBpZiAoaXNDb25uZWN0YWJsZVN0YXJ0ICYmXG4gICAgICAgICAgICAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogY3VycmVudFN0b3JlLmF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBjdXJyZW50U3RvcmUuZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwOiBjdXJyZW50U3RvcmUubm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBsaWI6IGN1cnJlbnRTdG9yZS5saWIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGZsb3dJZDogY3VycmVudFN0b3JlLnJmSWQsXG4gICAgICAgICAgICAgICAgcGFuQnk6IGN1cnJlbnRTdG9yZS5wYW5CeSxcbiAgICAgICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUuY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogY3VycmVudFN0b3JlLm9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVuZDogY3VycmVudFN0b3JlLm9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUudXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEV4dGVuZGVkLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBjdXJyZW50U3RvcmUuaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3BlZWQ6IGN1cnJlbnRTdG9yZS5hdXRvUGFuU3BlZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNb3VzZVRyaWdnZXJlZCkge1xuICAgICAgICAgICAgb25Nb3VzZURvd24/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSwgbGliLCByZklkOiBmbG93SWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdGF0ZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghbm9kZUlkIHx8ICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUgJiYgIWlzQ29ubmVjdGFibGVTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlKSB7XG4gICAgICAgICAgICBvbkNsaWNrQ29ubmVjdFN0YXJ0Py4oZXZlbnQubmF0aXZlRXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZTogdHlwZSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IHsgbm9kZUlkLCB0eXBlLCBpZDogaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IFhZSGFuZGxlLmlzVmFsaWQoZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZToge1xuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS50eXBlLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFeHRlbmRlZChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uQ2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25DbG9uZS5pblByb2dyZXNzO1xuICAgICAgICBjb25uZWN0aW9uQ2xvbmUudG9Qb3NpdGlvbiA9IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZSA/IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZS5wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIG9uQ2xpY2tDb25uZWN0RW5kPy4oZXZlbnQsIGNvbm5lY3Rpb25DbG9uZSk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IFwiZGF0YS1oYW5kbGVpZFwiOiBoYW5kbGVJZCwgXCJkYXRhLW5vZGVpZFwiOiBub2RlSWQsIFwiZGF0YS1oYW5kbGVwb3NcIjogcG9zaXRpb24sIFwiZGF0YS1pZFwiOiBgJHtyZklkfS0ke25vZGVJZH0tJHtoYW5kbGVJZH0tJHt0eXBlfWAsIGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2hhbmRsZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19faGFuZGxlLSR7cG9zaXRpb259YCxcbiAgICAgICAgICAgICdub2RyYWcnLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAhaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZXN0YXJ0OiBpc0Nvbm5lY3RhYmxlU3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVlbmQ6IGlzQ29ubmVjdGFibGVFbmQsXG4gICAgICAgICAgICAgICAgY2xpY2tjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ2Zyb206IGNvbm5lY3RpbmdGcm9tLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmd0bzogY29ubmVjdGluZ1RvLFxuICAgICAgICAgICAgICAgIHZhbGlkLFxuICAgICAgICAgICAgICAgIC8vIHNob3dzIHdoZXJlIHlvdSBjYW4gc3RhcnQgYSBjb25uZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAvLyBhbmQgd2hlcmUgeW91IGNhbiBlbmQgaXQgd2hpbGUgY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25pbmRpY2F0b3I6IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGlzUG9zc2libGVFbmRIYW5kbGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChjb25uZWN0aW9uSW5Qcm9jZXNzID8gaXNDb25uZWN0YWJsZUVuZCA6IGlzQ29ubmVjdGFibGVTdGFydCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgb25Nb3VzZURvd246IG9uUG9pbnRlckRvd24sIG9uVG91Y2hTdGFydDogb25Qb2ludGVyRG93biwgb25DbGljazogY29ubmVjdE9uQ2xpY2sgPyBvbkNsaWNrIDogdW5kZWZpbmVkLCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVGhlIEhhbmRsZSBjb21wb25lbnQgaXMgYSBVSSBlbGVtZW50IHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IG5vZGVzLlxuICovXG5jb25zdCBIYW5kbGUgPSBtZW1vKGZpeGVkRm9yd2FyZFJlZihIYW5kbGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gSW5wdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2RhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gR3JvdXBOb2RlKCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBPdXRwdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbF0gfSkpO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbmNvbnN0IGJ1aWx0aW5Ob2RlVHlwZXMgPSB7XG4gICAgaW5wdXQ6IElucHV0Tm9kZSxcbiAgICBkZWZhdWx0OiBEZWZhdWx0Tm9kZSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUsXG4gICAgZ3JvdXA6IEdyb3VwTm9kZSxcbn07XG5mdW5jdGlvbiBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgfTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwge1xuICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhIW5vZGUuc2VsZWN0ZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGlzTnVtZXJpYyh3aWR0aCkgPyB3aWR0aCA6IG51bGwsXG4gICAgICAgIGhlaWdodDogaXNOdW1lcmljKGhlaWdodCkgPyBoZWlnaHQgOiBudWxsLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIHRyYW5zZm9ybVN0cmluZzogYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KSB0cmFuc2xhdGUoJHt4fXB4LCR7eX1weClgLFxuICAgIH07XG59O1xuZnVuY3Rpb24gTm9kZXNTZWxlY3Rpb24oeyBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZiwgc2hhbGxvdyk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlLmdldFN0YXRlKCkubm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUoZXZlbnQsIHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24nLCAncmVhY3QtZmxvd19fY29udGFpbmVyJywgbm9QYW5DbGFzc05hbWVdKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtU3RyaW5nLFxuICAgICAgICB9LCBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgfSB9KSB9KSk7XG59XG5cbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuY29uc3Qgc2VsZWN0b3IkZSA9IChzKSA9PiB7XG4gICAgcmV0dXJuIHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHMubm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSB9O1xufTtcbmZ1bmN0aW9uIEZsb3dSZW5kZXJlckNvbXBvbmVudCh7IGNoaWxkcmVuLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogX3Bhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGUpO1xuICAgIGNvbnN0IHNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhzZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MocGFuQWN0aXZhdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuT25EcmFnID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uRHJhZztcbiAgICBjb25zdCBwYW5PblNjcm9sbCA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PblNjcm9sbDtcbiAgICBjb25zdCBfc2VsZWN0aW9uT25EcmFnID0gc2VsZWN0aW9uT25EcmFnICYmIHBhbk9uRHJhZyAhPT0gdHJ1ZTtcbiAgICBjb25zdCBpc1NlbGVjdGluZyA9IHNlbGVjdGlvbktleVByZXNzZWQgfHwgdXNlclNlbGVjdGlvbkFjdGl2ZSB8fCBfc2VsZWN0aW9uT25EcmFnO1xuICAgIHVzZUdsb2JhbEtleUhhbmRsZXIoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSk7XG4gICAgcmV0dXJuIChqc3goWm9vbVBhbmUsIHsgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6ICFzZWxlY3Rpb25LZXlQcmVzc2VkICYmIHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgY2hpbGRyZW46IGpzeHMoUGFuZSwgeyBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBpc1NlbGVjdGluZzogISFpc1NlbGVjdGluZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgc2VsZWN0aW9uS2V5UHJlc3NlZDogc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uT25EcmFnOiBfc2VsZWN0aW9uT25EcmFnLCBjaGlsZHJlbjogW2NoaWxkcmVuLCBub2Rlc1NlbGVjdGlvbkFjdGl2ZSAmJiAoanN4KE5vZGVzU2VsZWN0aW9uLCB7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KSldIH0pIH0pKTtcbn1cbkZsb3dSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdGbG93UmVuZGVyZXInO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gbWVtbyhGbG93UmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciRkID0gKG9ubHlSZW5kZXJWaXNpYmxlKSA9PiAocykgPT4ge1xuICAgIHJldHVybiBvbmx5UmVuZGVyVmlzaWJsZVxuICAgICAgICA/IGdldE5vZGVzSW5zaWRlKHMubm9kZUxvb2t1cCwgeyB4OiAwLCB5OiAwLCB3aWR0aDogcy53aWR0aCwgaGVpZ2h0OiBzLmhlaWdodCB9LCBzLnRyYW5zZm9ybSwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKVxuICAgICAgICA6IEFycmF5LmZyb20ocy5ub2RlTG9va3VwLmtleXMoKSk7XG59O1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIG5vZGUgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2VsZWN0b3IkZChvbmx5UmVuZGVyVmlzaWJsZSksIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZUlkcztcbn1cblxuY29uc3Qgc2VsZWN0b3IkYyA9IChzKSA9PiBzLnVwZGF0ZU5vZGVJbnRlcm5hbHM7XG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgY29uc3QgW3Jlc2l6ZU9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBlbnRyeS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbi8qKlxuICogSG9vayB0byBoYW5kbGUgdGhlIHJlc2l6ZSBvYnNlcnZhdGlvbiArIGludGVybmFsIHVwZGF0ZXMgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIG5vZGVSZWYgLSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldlNvdXJjZVBvc2l0aW9uID0gdXNlUmVmKG5vZGUuc291cmNlUG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUYXJnZXRQb3NpdGlvbiA9IHVzZVJlZihub2RlLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZihub2RlVHlwZSk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IGhhc0RpbWVuc2lvbnMgJiYgISFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCAmJiAhbm9kZS5oaWRkZW4gJiYgKCFpc0luaXRpYWxpemVkIHx8IG9ic2VydmVkTm9kZS5jdXJyZW50ICE9PSBub2RlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG5vZGVSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0sIFtpc0luaXRpYWxpemVkLCBub2RlLmhpZGRlbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIHRoZSBzb3VyY2Ugb3IgaGFuZGxlIHBvc2l0aW9uLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWxzXG4gICAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgdGhlIGVkZ2VzIGFyZSB1cGRhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgY29uc3QgdHlwZUNoYW5nZWQgPSBwcmV2VHlwZS5jdXJyZW50ICE9PSBub2RlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc0NoYW5nZWQgPSBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvc0NoYW5nZWQgPSBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlQ2hhbmdlZCB8fCBzb3VyY2VQb3NDaGFuZ2VkIHx8IHRhcmdldFBvc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZS5jdXJyZW50ID0gbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlTm9kZUludGVybmFscyhuZXcgTWFwKFtbbm9kZS5pZCwgeyBpZDogbm9kZS5pZCwgbm9kZUVsZW1lbnQ6IG5vZGVSZWYuY3VycmVudCwgZm9yY2U6IHRydWUgfV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZS5pZCwgbm9kZVR5cGUsIG5vZGUuc291cmNlUG9zaXRpb24sIG5vZGUudGFyZ2V0UG9zaXRpb25dKTtcbiAgICByZXR1cm4gbm9kZVJlZjtcbn1cblxuZnVuY3Rpb24gTm9kZVdyYXBwZXIoeyBpZCwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrLCBub2Rlc0RyYWdnYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgcmVzaXplT2JzZXJ2ZXIsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQsIG5vZGVUeXBlcywgbm9kZUV4dGVudCwgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCB7IG5vZGUsIGludGVybmFscywgaXNQYXJlbnQgfSA9IHVzZVN0b3JlKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgaXNQYXJlbnQgPSBzLnBhcmVudExvb2t1cC5oYXMoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczogbm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICBpc1BhcmVudCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBsZXQgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bbm9kZVR5cGVdIHx8IGJ1aWx0aW5Ob2RlVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmIChOb2RlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMDMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMyddKG5vZGVUeXBlKSk7XG4gICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBOb2RlQ29tcG9uZW50ID0gYnVpbHRpbk5vZGVUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEobm9kZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIG5vZGUuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gISEobm9kZS5jb25uZWN0YWJsZSB8fCAobm9kZXNDb25uZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5jb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKG5vZGUuZm9jdXNhYmxlIHx8IChub2Rlc0ZvY3VzYWJsZSAmJiB0eXBlb2Ygbm9kZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhc0RpbWVuc2lvbnMgPSBub2RlSGFzRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlTm9kZU9ic2VydmVyKHsgbm9kZSwgbm9kZVR5cGUsIGhhc0RpbWVuc2lvbnMsIHJlc2l6ZU9ic2VydmVyIH0pO1xuICAgIGNvbnN0IGRyYWdnaW5nID0gdXNlRHJhZyh7XG4gICAgICAgIG5vZGVSZWYsXG4gICAgICAgIGRpc2FibGVkOiBub2RlLmhpZGRlbiB8fCAhaXNEcmFnZ2FibGUsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3I6IG5vZGUuZHJhZ0hhbmRsZSxcbiAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICB9KTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZU1vdmVTZWxlY3RlZE5vZGVzKCk7XG4gICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGlubGluZURpbWVuc2lvbnMgPSBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGhhc1BvaW50ZXJFdmVudHMgPSBpc1NlbGVjdGFibGUgfHwgaXNEcmFnZ2FibGUgfHwgb25DbGljayB8fCBvbk1vdXNlRW50ZXIgfHwgb25Nb3VzZU1vdmUgfHwgb25Nb3VzZUxlYXZlO1xuICAgIGNvbnN0IG9uTW91c2VFbnRlckhhbmRsZXIgPSBvbk1vdXNlRW50ZXJcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VFbnRlcihldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmVIYW5kbGVyID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTGVhdmVIYW5kbGVyID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4gb25Db250ZXh0TWVudShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Eb3VibGVDbGlja0hhbmRsZXIgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblNlbGVjdE5vZGVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCBieSBYWURyYWcgb24gZHJhZyBzdGFydCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPXRydWVcbiAgICAgICAgICAgIC8vIGhlcmUgd2Ugb25seSBuZWVkIHRvIGNhbGwgaXQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RyYWdnYWJsZSAmJiBub2RlLnNlbGVjdGVkICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiBgTW92ZWQgc2VsZWN0ZWQgbm9kZSAke2V2ZW50LmtleVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnQXJyb3cnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9LiBOZXcgcG9zaXRpb24sIHg6ICR7fn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fSwgeTogJHt+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX25vZGUtJHtub2RlVHlwZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3ZlcndyaXRhYmxlIGJ5IHBhc3NpbmcgYG5vcGFuYCBhcyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpc1BhcmVudCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIHJlZjogbm9kZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHpJbmRleDogaW50ZXJuYWxzLnosXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fXB4LCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1weClgLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogaGFzUG9pbnRlckV2ZW50cyA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGFzRGltZW5zaW9ucyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIC4uLmlubGluZURpbWVuc2lvbnMsXG4gICAgICAgIH0sIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX25vZGUtJHtpZH1gLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlckhhbmRsZXIsIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZUhhbmRsZXIsIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlSGFuZGxlciwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudUhhbmRsZXIsIG9uQ2xpY2s6IG9uU2VsZWN0Tm9kZUhhbmRsZXIsIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2tIYW5kbGVyLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBpc0ZvY3VzYWJsZSA/ICdidXR0b24nIDogdW5kZWZpbmVkLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIFwiYXJpYS1sYWJlbFwiOiBub2RlLmFyaWFMYWJlbCwgY2hpbGRyZW46IGpzeChQcm92aWRlciwgeyB2YWx1ZTogaWQsIGNoaWxkcmVuOiBqc3goTm9kZUNvbXBvbmVudCwgeyBpZDogaWQsIGRhdGE6IG5vZGUuZGF0YSwgdHlwZTogbm9kZVR5cGUsIHBvc2l0aW9uQWJzb2x1dGVYOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LCBwb3NpdGlvbkFic29sdXRlWTogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSwgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQsIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSwgZGVsZXRhYmxlOiBub2RlLmRlbGV0YWJsZSA/PyB0cnVlLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLCBzb3VyY2VQb3NpdGlvbjogbm9kZS5zb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IG5vZGUudGFyZ2V0UG9zaXRpb24sIGRyYWdnaW5nOiBkcmFnZ2luZywgZHJhZ0hhbmRsZTogbm9kZS5kcmFnSGFuZGxlLCB6SW5kZXg6IGludGVybmFscy56LCBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCwgLi4ubm9kZURpbWVuc2lvbnMgfSkgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRiID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBOb2RlUmVuZGVyZXJDb21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlVmlzaWJsZU5vZGVJZHMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE5vZGVSZW5kZXJlciBhbmRcbiAgICAgICAgICAgIC8vIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAgICAgLy8gbWluaW1pemUgdGhlIGNvc3Qgb2YgdXBkYXRlcyB3aGVuIGluZGl2aWR1YWwgbm9kZXMgY2hhbmdlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHlvdeKAmXJlIGRyYWdnaW5nIGEgc2luZ2xlIG5vZGUsIHRoYXQgbm9kZSBnZXRzXG4gICAgICAgICAgICAvLyB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIHBlciBzZWNvbmQuIElmIGBOb2RlUmVuZGVyZXJgIHdlcmUgdG8gdXBkYXRlXG4gICAgICAgICAgICAvLyBldmVyeSB0aW1lLCBpdCB3b3VsZCBoYXZlIHRvIHJlLXJ1biB0aGUgYG5vZGVzLm1hcCgpYCBsb29wIGV2ZXJ5XG4gICAgICAgICAgICAvLyB0aW1lLiBUaGlzIGdldHMgcHJpY2V5IHdpdGggaHVuZHJlZHMgb2Ygbm9kZXMsIGVzcGVjaWFsbHkgaWYgZXZlcnlcbiAgICAgICAgICAgIC8vIGxvb3AgY3ljbGUgZG9lcyBtb3JlIHRoYW4ganVzdCByZW5kZXJpbmcgYSBKU1ggZWxlbWVudCFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBcyBhIHJlc3VsdCBvZiB0aGlzIGNob2ljZSwgd2UgdG9vayB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBkZWNpc2lvbnM6XG4gICAgICAgICAgICAvLyAtIE5vZGVSZW5kZXJlciBzdWJzY3JpYmVzICpvbmx5KiB0byBub2RlIElEcyDigJMgYW5kIHRoZXJlZm9yZVxuICAgICAgICAgICAgLy8gICByZXJlbmRlciAqb25seSogd2hlbiB2aXNpYmxlIG5vZGVzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICAgICAgLy8gLSBOb2RlUmVuZGVyZXIgcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgdGhlIHJlc3VsdCBvZiB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgIC8vICAgc2hhcmVkIGJldHdlZW4gbm9kZXMgKHN1Y2ggYXMgY3JlYXRpbmcgdGhlIGBSZXNpemVPYnNlcnZlcmBcbiAgICAgICAgICAgIC8vICAgaW5zdGFuY2UsIG9yIHN1YnNjcmliaW5nIHRvIGBzZWxlY3RvcmApLiBUaGlzIG1lYW5zIGV4dHJhIHByb3BcbiAgICAgICAgICAgIC8vICAgZHJpbGxpbmcgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLCBidXQgaXQgbWVhbnMgd2UgbmVlZCB0byBydW5cbiAgICAgICAgICAgIC8vICAgdGhlc2Ugb3BlcmF0aW9ucyBvbmx5IG9uY2Ug4oCTIGluc3RlYWQgb2Ygb25jZSBwZXIgbm9kZS5cbiAgICAgICAgICAgIC8vIC0gQW55IG9wZXJhdGlvbnMgdGhhdCB5b3XigJlkIG5vcm1hbGx5IHdyaXRlIGluc2lkZSBgbm9kZXMubWFwYCBhcmVcbiAgICAgICAgICAgIC8vICAgbW92ZWQgaW50byBgTm9kZUNvbXBvbmVudFdyYXBwZXJgLiBUaGlzIGVuc3VyZXMgdGhleSBhcmVcbiAgICAgICAgICAgIC8vICAgbWVtb3JpemVkIOKAkyBzbyBpZiBgTm9kZVJlbmRlcmVyYCAqaGFzKiB0byByZXJlbmRlciwgaXQgb25seVxuICAgICAgICAgICAgLy8gICBuZWVkcyB0byByZWdlbmVyYXRlIHRoZSBsaXN0IG9mIG5vZGVzLCBub3RoaW5nIGVsc2UuXG4gICAgICAgICAgICBqc3goTm9kZVdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZVR5cGVzOiBwcm9wcy5ub2RlVHlwZXMsIG5vZGVFeHRlbnQ6IHByb3BzLm5vZGVFeHRlbnQsIG9uQ2xpY2s6IHByb3BzLm9uTm9kZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTm9kZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBwcm9wcy5vbk5vZGVNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogcHJvcHMub25Ob2RlTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudTogcHJvcHMub25Ob2RlQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2s6IHByb3BzLm9uTm9kZURvdWJsZUNsaWNrLCBub0RyYWdDbGFzc05hbWU6IHByb3BzLm5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IHByb3BzLm5vUGFuQ2xhc3NOYW1lLCByZklkOiBwcm9wcy5yZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBwcm9wcy5kaXNhYmxlS2V5Ym9hcmRBMTF5LCByZXNpemVPYnNlcnZlcjogcmVzaXplT2JzZXJ2ZXIsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9kZUNsaWNrRGlzdGFuY2U6IHByb3BzLm5vZGVDbGlja0Rpc3RhbmNlLCBvbkVycm9yOiBvbkVycm9yIH0sIG5vZGVJZCkpO1xuICAgICAgICB9KSB9KSk7XG59XG5Ob2RlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTm9kZVJlbmRlcmVyJztcbmNvbnN0IE5vZGVSZW5kZXJlciA9IG1lbW8oTm9kZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIGVkZ2UgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgZWRnZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZUVkZ2VJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBlZGdlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgaWYgKCFvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMuZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlRWRnZUlkcyA9IFtdO1xuICAgICAgICBpZiAocy53aWR0aCAmJiBzLmhlaWdodCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIHMuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNFZGdlVmlzaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVFZGdlSWRzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlRWRnZUlkcztcbiAgICB9LCBbb25seVJlbmRlclZpc2libGVdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VJZHM7XG59XG5cbmNvbnN0IEFycm93U3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgZmlsbDogXCJub25lXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNFwiIH0pKTtcbn07XG5jb25zdCBBcnJvd0Nsb3NlZFN5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0IC01LC00XCIgfSkpO1xufTtcbmNvbnN0IE1hcmtlclN5bWJvbHMgPSB7XG4gICAgW01hcmtlclR5cGUuQXJyb3ddOiBBcnJvd1N5bWJvbCxcbiAgICBbTWFya2VyVHlwZS5BcnJvd0Nsb3NlZF06IEFycm93Q2xvc2VkU3ltYm9sLFxufTtcbmZ1bmN0aW9uIHVzZU1hcmtlclN5bWJvbCh0eXBlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2xFeGlzdHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTWFya2VyU3ltYm9scywgdHlwZSk7XG4gICAgICAgIGlmICghc3ltYm9sRXhpc3RzKSB7XG4gICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA5JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDknXSh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU3ltYm9sc1t0eXBlXTtcbiAgICB9LCBbdHlwZV0pO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5cbmNvbnN0IE1hcmtlciA9ICh7IGlkLCB0eXBlLCBjb2xvciwgd2lkdGggPSAxMi41LCBoZWlnaHQgPSAxMi41LCBtYXJrZXJVbml0cyA9ICdzdHJva2VXaWR0aCcsIHN0cm9rZVdpZHRoLCBvcmllbnQgPSAnYXV0by1zdGFydC1yZXZlcnNlJywgfSkgPT4ge1xuICAgIGNvbnN0IFN5bWJvbCA9IHVzZU1hcmtlclN5bWJvbCh0eXBlKTtcbiAgICBpZiAoIVN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIsIGNoaWxkcmVuOiBqc3goU3ltYm9sLCB7IGNvbG9yOiBjb2xvciwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoIH0pIH0pKTtcbn07XG4vLyB3aGVuIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIGEgcGFnZSBhbmQgeW91IGhpZGUgdGhlIGZpcnN0IG9uZSwgdGhlIG90aGVyIG9uZXMgaGF2ZSBubyBtYXJrZXJzIGFueW1vcmVcbi8vIHdoZW4gdGhleSBkbyBoYXZlIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBpZHMuIFRvIHByZXZlbnQgdGhpcyB0aGUgdXNlciBjYW4gcGFzcyBhIHVuaXF1ZSBpZCB0byB0aGUgcmVhY3QgZmxvdyB3cmFwcGVyXG4vLyB0aGF0IHdlIGNhbiB0aGVuIHVzZSBmb3IgY3JlYXRpbmcgb3VyIHVuaXF1ZSBtYXJrZXIgaWRzXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlcyk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHtcbiAgICAgICAgICAgIGlkOiByZklkLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlclN0YXJ0OiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlclN0YXJ0LFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlckVuZDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbZWRnZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmZJZCwgZGVmYXVsdENvbG9yXSk7XG4gICAgaWYgKCFtYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWFya2VyXCIsIGNoaWxkcmVuOiBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChqc3goTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIHR5cGU6IG1hcmtlci50eXBlLCBjb2xvcjogbWFya2VyLmNvbG9yLCB3aWR0aDogbWFya2VyLndpZHRoLCBoZWlnaHQ6IG1hcmtlci5oZWlnaHQsIG1hcmtlclVuaXRzOiBtYXJrZXIubWFya2VyVW5pdHMsIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsIG9yaWVudDogbWFya2VyLm9yaWVudCB9LCBtYXJrZXIuaWQpKSkgfSkgfSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmZ1bmN0aW9uIEVkZ2VUZXh0Q29tcG9uZW50KHsgeCwgeSwgbGFiZWwsIGxhYmVsU3R5bGUgPSB7fSwgbGFiZWxTaG93QmcgPSB0cnVlLCBsYWJlbEJnU3R5bGUgPSB7fSwgbGFiZWxCZ1BhZGRpbmcgPSBbMiwgNF0sIGxhYmVsQmdCb3JkZXJSYWRpdXMgPSAyLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBbZWRnZVRleHRCYm94LCBzZXRFZGdlVGV4dEJib3hdID0gdXNlU3RhdGUoeyB4OiAxLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0Q2xhc3NlcyA9IGNjKFsncmVhY3QtZmxvd19fZWRnZS10ZXh0d3JhcHBlcicsIGNsYXNzTmFtZV0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlZGdlVGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VUZXh0UmVmLmN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgc2V0RWRnZVRleHRCYm94KHtcbiAgICAgICAgICAgICAgICB4OiB0ZXh0QmJveC54LFxuICAgICAgICAgICAgICAgIHk6IHRleHRCYm94LnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJib3guaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbbGFiZWxdKTtcbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAndW5kZWZpbmVkJyB8fCAhbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImdcIiwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4IC0gZWRnZVRleHRCYm94LndpZHRoIC8gMn0gJHt5IC0gZWRnZVRleHRCYm94LmhlaWdodCAvIDJ9KWAsIGNsYXNzTmFtZTogZWRnZVRleHRDbGFzc2VzLCB2aXNpYmlsaXR5OiBlZGdlVGV4dEJib3gud2lkdGggPyAndmlzaWJsZScgOiAnaGlkZGVuJywgLi4ucmVzdCwgY2hpbGRyZW46IFtsYWJlbFNob3dCZyAmJiAoanN4KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLCBqc3goXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlVGV4dFJlZiwgc3R5bGU6IGxhYmVsU3R5bGUsIGNoaWxkcmVuOiBsYWJlbCB9KSwgY2hpbGRyZW5dIH0pKTtcbn1cbkVkZ2VUZXh0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VUZXh0JztcbmNvbnN0IEVkZ2VUZXh0ID0gbWVtbyhFZGdlVGV4dENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIEJhc2VFZGdlKHsgaWQsIHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBjbGFzc05hbWUsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBpZDogaWQsIHN0eWxlOiBzdHlsZSwgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXBhdGgnLCBjbGFzc05hbWVdKSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCB9KSwgaW50ZXJhY3Rpb25XaWR0aCAmJiAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSksIGxhYmVsICYmIGlzTnVtZXJpYyhsYWJlbFgpICYmIGlzTnVtZXJpYyhsYWJlbFkpID8gKGpzeChFZGdlVGV4dCwgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpIDogbnVsbF0gfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU2ltcGxlQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlJztcblNpbXBsZUJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTbW9vdGhTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBwYXRoT3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNtb290aFN0ZXBFZGdlID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TbW9vdGhTdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZSc7XG5TbW9vdGhTdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIC4uLnByb3BzIH0pID0+IHtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIGlkOiBfaWQsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFN0ZXBFZGdlID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5TdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJhaWdodEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU3RyYWlnaHRFZGdlID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG5jb25zdCBTdHJhaWdodEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblN0cmFpZ2h0RWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgQmV6aWVyRWRnZSA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IEJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcbkJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5jb25zdCBidWlsdGluRWRnZVR5cGVzID0ge1xuICAgIGRlZmF1bHQ6IEJlemllckVkZ2VJbnRlcm5hbCxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlSW50ZXJuYWwsXG4gICAgc3RlcDogU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzbW9vdGhzdGVwOiBTbW9vdGhTdGVwRWRnZUludGVybmFsLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLFxufTtcbmNvbnN0IG51bGxQb3NpdGlvbiA9IHtcbiAgICBzb3VyY2VYOiBudWxsLFxuICAgIHNvdXJjZVk6IG51bGwsXG4gICAgdGFyZ2V0WDogbnVsbCxcbiAgICB0YXJnZXRZOiBudWxsLFxuICAgIHNvdXJjZVBvc2l0aW9uOiBudWxsLFxuICAgIHRhcmdldFBvc2l0aW9uOiBudWxsLFxufTtcblxuY29uc3Qgc2hpZnRYID0gKHgsIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdClcbiAgICAgICAgcmV0dXJuIHggLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KVxuICAgICAgICByZXR1cm4geCArIHNoaWZ0O1xuICAgIHJldHVybiB4O1xufTtcbmNvbnN0IHNoaWZ0WSA9ICh5LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcClcbiAgICAgICAgcmV0dXJuIHkgLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHkgKyBzaGlmdDtcbiAgICByZXR1cm4geTtcbn07XG5jb25zdCBFZGdlVXBkYXRlckNsYXNzTmFtZSA9ICdyZWFjdC1mbG93X19lZGdldXBkYXRlcic7XG5mdW5jdGlvbiBFZGdlQW5jaG9yKHsgcG9zaXRpb24sIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyA9IDEwLCBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0LCB0eXBlLCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VVcGRhdGVBbmNob3JzKHsgaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXMsIGVkZ2UsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBzZXRSZWNvbm5lY3RpbmcsIHNldFVwZGF0ZUhvdmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBvcHBvc2l0ZUhhbmRsZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uQ29ubmVjdCwgZG9tTm9kZSwgaXNWYWxpZENvbm5lY3Rpb24sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBsaWIsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIGNhbmNlbENvbm5lY3Rpb24sIG5vZGVMb29rdXAsIHJmSWQ6IGZsb3dJZCwgcGFuQnksIHVwZGF0ZUNvbm5lY3Rpb24sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc1RhcmdldCA9IG9wcG9zaXRlSGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnO1xuICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIG9uUmVjb25uZWN0U3RhcnQ/LihldmVudCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSk7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS50YXJnZXQsIGlkOiBlZGdlLnRhcmdldEhhbmRsZSA/PyBudWxsLCB0eXBlOiAndGFyZ2V0JyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnNvdXJjZSwgaWQ6IGVkZ2Uuc291cmNlSGFuZGxlID8/IG51bGwsIHR5cGU6ICdzb3VyY2UnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICdzb3VyY2UnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBjZW50ZXJYOiBzb3VyY2VYLCBjZW50ZXJZOiBzb3VyY2VZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksIChpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAndGFyZ2V0JykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgY2VudGVyWDogdGFyZ2V0WCwgY2VudGVyWTogdGFyZ2V0WSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VXcmFwcGVyKHsgaWQsIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25DbGljaywgb25Eb3VibGVDbGljaywgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25FcnJvciwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGxldCBlZGdlID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZUxvb2t1cC5nZXQoaWQpKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGVkZ2UgPSBkZWZhdWx0RWRnZU9wdGlvbnMgPyB7IC4uLmRlZmF1bHRFZGdlT3B0aW9ucywgLi4uZWRnZSB9IDogZWRnZTtcbiAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bZWRnZVR5cGVdIHx8IGJ1aWx0aW5FZGdlVHlwZXNbZWRnZVR5cGVdO1xuICAgIGlmIChFZGdlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTEnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMSddKGVkZ2VUeXBlKSk7XG4gICAgICAgIGVkZ2VUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBFZGdlQ29tcG9uZW50ID0gYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiAnaW1nJywgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIGNoaWxkcmVuOiBbIXJlY29ubmVjdGluZyAmJiAoanN4KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IGVkZ2Uuc291cmNlLCB0YXJnZXQ6IGVkZ2UudGFyZ2V0LCB0eXBlOiBlZGdlLnR5cGUsIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogZWRnZS5hbmltYXRlZCwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkZWxldGFibGU6IGVkZ2UuZGVsZXRhYmxlID8/IHRydWUsIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZGF0YTogZWRnZS5kYXRhLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpLCBpc1JlY29ubmVjdGFibGUgJiYgKGpzeChFZGdlVXBkYXRlQW5jaG9ycywgeyBlZGdlOiBlZGdlLCBpc1JlY29ubmVjdGFibGU6IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc2V0VXBkYXRlSG92ZXI6IHNldFVwZGF0ZUhvdmVyLCBzZXRSZWNvbm5lY3Rpbmc6IHNldFJlY29ubmVjdGluZyB9KSldIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYSA9IChzKSA9PiAoe1xuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIsIHsgaWQ6IGlkLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25DbGljazogb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCByZklkOiByZklkLCBvbkVycm9yOiBvbkVycm9yLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LCBpZCkpO1xuICAgICAgICAgICAgfSldIH0pKTtcbn1cbkVkZ2VSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xuY29uc3QgRWRnZVJlbmRlcmVyID0gbWVtbyhFZGdlUmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkOSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQgeHlmbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBvbkluaXQgaGFuZGxlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ4ID0gKHN0YXRlKSA9PiBzdGF0ZS5wYW5ab29tPy5zeW5jVmlld3BvcnQ7XG4vKipcbiAqIEhvb2sgZm9yIHN5bmNpbmcgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHBhbnpvb20gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3luY1ZpZXdwb3J0ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgc3luY1ZpZXdwb3J0Py4odmlld3BvcnQpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm06IFt2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56b29tXSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2aWV3cG9ydCwgc3luY1ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2VsZWN0b3IkMShzKSB7XG4gICAgcmV0dXJuIHMuY29ubmVjdGlvbi5pblByb2dyZXNzXG4gICAgICAgID8geyAuLi5zLmNvbm5lY3Rpb24sIHRvOiBwb2ludFRvUmVuZGVyZXJQb2ludChzLmNvbm5lY3Rpb24udG8sIHMudHJhbnNmb3JtKSB9XG4gICAgICAgIDogeyAuLi5zLmNvbm5lY3Rpb24gfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGlmIChjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RvcmVTZWxlY3RvciQxKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25TZWxlY3Rvcihjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZVNlbGVjdG9yJDE7XG59XG4vKipcbiAqIEhvb2sgZm9yIGFjY2Vzc2luZyB0aGUgY29ubmVjdGlvbiBzdGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBDb25uZWN0aW9uU3RhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ29ubmVjdGlvbihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKTtcbiAgICByZXR1cm4gdXNlU3RvcmUoY29tYmluZWRTZWxlY3Rvciwgc2hhbGxvdyk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgaXNWYWxpZDogcy5jb25uZWN0aW9uLmlzVmFsaWQsXG4gICAgaW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbn0pO1xuZnVuY3Rpb24gQ29ubmVjdGlvbkxpbmVXcmFwcGVyKHsgY29udGFpbmVyU3R5bGUsIHN0eWxlLCB0eXBlLCBjb21wb25lbnQgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgaXNWYWxpZCwgaW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVuZGVyQ29ubmVjdGlvbiA9ICEhKHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUgJiYgaW5Qcm9ncmVzcyk7XG4gICAgaWYgKCFyZW5kZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiBjb250YWluZXJTdHlsZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb25saW5lIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb25uZWN0aW9uJywgZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKV0pLCBjaGlsZHJlbjoganN4KENvbm5lY3Rpb25MaW5lLCB7IHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSwgQ3VzdG9tQ29tcG9uZW50OiBjb21wb25lbnQsIGlzVmFsaWQ6IGlzVmFsaWQgfSkgfSkgfSkpO1xufVxuY29uc3QgQ29ubmVjdGlvbkxpbmUgPSAoeyBzdHlsZSwgdHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIEN1c3RvbUNvbXBvbmVudCwgaXNWYWxpZCB9KSA9PiB7XG4gICAgY29uc3QgeyBpblByb2dyZXNzLCBmcm9tLCBmcm9tTm9kZSwgZnJvbUhhbmRsZSwgZnJvbVBvc2l0aW9uLCB0bywgdG9Ob2RlLCB0b0hhbmRsZSwgdG9Qb3NpdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpO1xuICAgIGlmICghaW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChDdXN0b21Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChqc3goQ3VzdG9tQ29tcG9uZW50LCB7IGNvbm5lY3Rpb25MaW5lVHlwZTogdHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZTogc3R5bGUsIGZyb21Ob2RlOiBmcm9tTm9kZSwgZnJvbUhhbmRsZTogZnJvbUhhbmRsZSwgZnJvbVg6IGZyb20ueCwgZnJvbVk6IGZyb20ueSwgdG9YOiB0by54LCB0b1k6IHRvLnksIGZyb21Qb3NpdGlvbjogZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uOiB0b1Bvc2l0aW9uLCBjb25uZWN0aW9uU3RhdHVzOiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpLCB0b05vZGU6IHRvTm9kZSwgdG9IYW5kbGU6IHRvSGFuZGxlIH0pKTtcbiAgICB9XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBjb25zdCBwYXRoUGFyYW1zID0ge1xuICAgICAgICBzb3VyY2VYOiBmcm9tLngsXG4gICAgICAgIHNvdXJjZVk6IGZyb20ueSxcbiAgICAgICAgc291cmNlUG9zaXRpb246IGZyb21Qb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0WDogdG8ueCxcbiAgICAgICAgdGFyZ2V0WTogdG8ueSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb246IHRvUG9zaXRpb24sXG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0QmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TaW1wbGVCZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTaW1wbGVCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gICAgICAgICAgICAgICAgLi4ucGF0aFBhcmFtcyxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TbW9vdGhTdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFN0cmFpZ2h0UGF0aChwYXRoUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb24tcGF0aFwiLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuQ29ubmVjdGlvbkxpbmUuZGlzcGxheU5hbWUgPSAnQ29ubmVjdGlvbkxpbmUnO1xuXG5jb25zdCBlbXB0eVR5cGVzID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlT3JFZGdlVHlwZXMgPSBlbXB0eVR5cGVzKSB7XG4gICAgY29uc3QgdHlwZXNSZWYgPSB1c2VSZWYobm9kZU9yRWRnZVR5cGVzKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VkS2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHR5cGVzUmVmLmN1cnJlbnQpLCAuLi5PYmplY3Qua2V5cyhub2RlT3JFZGdlVHlwZXMpXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1c2VkS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1JlZi5jdXJyZW50W2tleV0gIT09IG5vZGVPckVkZ2VUeXBlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMiddKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlc1JlZi5jdXJyZW50ID0gbm9kZU9yRWRnZVR5cGVzO1xuICAgICAgICB9XG4gICAgfSwgW25vZGVPckVkZ2VUeXBlc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBjaGVja2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19wYW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUgJiYgISh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYW5lKS56SW5kZXggPT09ICcxJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEzJ10oJ3JlYWN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja2VkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBHcmFwaFZpZXdDb21wb25lbnQoeyBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Jbml0LCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIGNvbm5lY3Rpb25MaW5lVHlwZSwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBkZWxldGVLZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBlbGVtZW50c1NlbGVjdGFibGUsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBkZWZhdWx0TWFya2VyQ29sb3IsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbCwgb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZSwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQsIHJmSWQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB9KSB7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhub2RlVHlwZXMpO1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcoZWRnZVR5cGVzKTtcbiAgICB1c2VTdHlsZXNMb2FkZWRXYXJuaW5nKCk7XG4gICAgdXNlT25Jbml0SGFuZGxlcihvbkluaXQpO1xuICAgIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIChqc3goRmxvd1JlbmRlcmVyLCB7IG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZTogZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlOiBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlOiBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiAhIXZpZXdwb3J0LCBjaGlsZHJlbjoganN4cyhWaWV3cG9ydCwgeyBjaGlsZHJlbjogW2pzeChFZGdlUmVuZGVyZXIsIHsgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgb25FZGdlQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQ6IHJmSWQgfSksIGpzeChDb25uZWN0aW9uTGluZVdyYXBwZXIsIHsgc3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIHR5cGU6IGNvbm5lY3Rpb25MaW5lVHlwZSwgY29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXJcIiB9KSwganN4KE5vZGVSZW5kZXJlciwgeyBub2RlVHlwZXM6IG5vZGVUeXBlcywgb25Ob2RlQ2xpY2s6IG9uTm9kZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXI6IG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZTogb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlOiBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudTogb25Ob2RlQ29udGV4dE1lbnUsIG5vZGVDbGlja0Rpc3RhbmNlOiBub2RlQ2xpY2tEaXN0YW5jZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgcmZJZDogcmZJZCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbFwiIH0pXSB9KSB9KSk7XG59XG5HcmFwaFZpZXdDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnR3JhcGhWaWV3JztcbmNvbnN0IEdyYXBoVmlldyA9IG1lbW8oR3JhcGhWaWV3Q29tcG9uZW50KTtcblxuY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0Vmlldywgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3Qgbm9kZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJlbnRMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29ubmVjdGlvbkxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlZGdlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0b3JlRWRnZXMgPSBkZWZhdWx0RWRnZXMgPz8gZWRnZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlcyA9IGRlZmF1bHROb2RlcyA/PyBub2RlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVPcmlnaW4gPSBub2RlT3JpZ2luID8/IFswLCAwXTtcbiAgICBjb25zdCBzdG9yZU5vZGVFeHRlbnQgPSBub2RlRXh0ZW50ID8/IGluZmluaXRlRXh0ZW50O1xuICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgc3RvcmVFZGdlcyk7XG4gICAgYWRvcHRVc2VyTm9kZXMoc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogZmFsc2UsXG4gICAgfSk7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFswLCAwLCAxXTtcbiAgICBpZiAoZml0VmlldyAmJiB3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2RlTG9va3VwLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhISgobm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkgJiYgKG5vZGUuaGVpZ2h0IHx8IG5vZGUuaW5pdGlhbEhlaWdodCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhib3VuZHMsIHdpZHRoLCBoZWlnaHQsIDAuNSwgMiwgMC4xKTtcbiAgICAgICAgdHJhbnNmb3JtID0gW3gsIHksIHpvb21dO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZklkOiAnMScsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgbm9kZXM6IHN0b3JlTm9kZXMsXG4gICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIHBhcmVudExvb2t1cCxcbiAgICAgICAgZWRnZXM6IHN0b3JlRWRnZXMsXG4gICAgICAgIGVkZ2VMb29rdXAsXG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAsXG4gICAgICAgIG9uTm9kZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIGhhc0RlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGhhc0RlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHBhblpvb206IG51bGwsXG4gICAgICAgIG1pblpvb206IDAuNSxcbiAgICAgICAgbWF4Wm9vbTogMixcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbk1vZGU6IENvbm5lY3Rpb25Nb2RlLlN0cmljdCxcbiAgICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgICAgcGFuZURyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZURyYWdUaHJlc2hvbGQ6IDEsXG4gICAgICAgIHNuYXBHcmlkOiBbMTUsIDE1XSxcbiAgICAgICAgc25hcFRvR3JpZDogZmFsc2UsXG4gICAgICAgIG5vZGVzRHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICBub2Rlc0Nvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBub2Rlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzUmVjb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGZhbHNlLFxuICAgICAgICBmaXRWaWV3T25Jbml0OiBmYWxzZSxcbiAgICAgICAgZml0Vmlld0RvbmU6IGZhbHNlLFxuICAgICAgICBmaXRWaWV3T25Jbml0T3B0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICBzZWxlY3ROb2Rlc09uRHJhZzogdHJ1ZSxcbiAgICAgICAgbXVsdGlTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsLFxuICAgICAgICBjb25uZWN0T25DbGljazogdHJ1ZSxcbiAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiAnJyxcbiAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZURyYWc6IHRydWUsXG4gICAgICAgIGF1dG9QYW5TcGVlZDogMTUsXG4gICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgICAgICBvbkVycm9yOiBkZXZXYXJuLFxuICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBbXSxcbiAgICAgICAgbGliOiAncmVhY3QnLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldzogZml0VmlldyQxLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9KSA9PiBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+ICh7XG4gICAgLi4uZ2V0SW5pdGlhbFN0YXRlKHsgbm9kZXMsIGVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3JDEsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzIH0pLFxuICAgIHNldE5vZGVzOiAobm9kZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0IH0gPSBnZXQoKTtcbiAgICAgICAgLy8gc2V0Tm9kZXMoKSBpcyBjYWxsZWQgZXhjbHVzaXZlbHkgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zOlxuICAgICAgICAvLyAtIGVpdGhlciB3aGVuIHRoZSBgPFJlYWN0RmxvdyBub2Rlcz5gIHByb3AgaXMgdXBkYXRlZCBpbiB0aGUgY29udHJvbGxlZCBSZWFjdEZsb3cgc2V0dXAsXG4gICAgICAgIC8vIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMsIHdlIHRha2UgdGhlIG5vdGUgb2JqZWN0cyBwYXNzZWQgYnkgdGhlIHVzZXIgYW5kIGV4dGVuZCB0aGVtIHdpdGggZmllbGRzXG4gICAgICAgIC8vIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHsgbm9kZXMgfSk7XG4gICAgfSxcbiAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpO1xuICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICB9LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzKTtcbiAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHRFZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gRXZlcnkgbm9kZSBnZXRzIHJlZ2lzdGVyZCBhdCBhIFJlc2l6ZU9ic2VydmVyLiBXaGVuZXZlciBhIG5vZGVcbiAgICAvLyBjaGFuZ2VzIGl0cyBkaW1lbnNpb25zLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBtZWFzdXJlIHRoZVxuICAgIC8vIG5ldyBkaW1lbnNpb25zIGFuZCB1cGRhdGUgdGhlIG5vZGVzLlxuICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHM6ICh1cGRhdGVzLCBwYXJhbXMgPSB7IHRyaWdnZXJGaXRWaWV3OiB0cnVlIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgZml0Vmlld09uSW5pdCwgZml0Vmlld0RvbmUsIGZpdFZpZXdPbkluaXRPcHRpb25zLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWJ1ZywgZml0Vmlld1N5bmMsIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3QgeyBjaGFuZ2VzLCB1cGRhdGVkSW50ZXJuYWxzIH0gPSB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgZG9tTm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCk7XG4gICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0pO1xuICAgICAgICBpZiAocGFyYW1zLnRyaWdnZXJGaXRWaWV3KSB7XG4gICAgICAgICAgICAvLyB3ZSBjYWxsIGZpdFZpZXcgb25jZSBpbml0aWFsbHkgYWZ0ZXIgYWxsIGRpbWVuc2lvbnMgYXJlIHNldFxuICAgICAgICAgICAgbGV0IG5leHRGaXRWaWV3RG9uZSA9IGZpdFZpZXdEb25lO1xuICAgICAgICAgICAgaWYgKCFmaXRWaWV3RG9uZSAmJiBmaXRWaWV3T25Jbml0KSB7XG4gICAgICAgICAgICAgICAgbmV4dEZpdFZpZXdEb25lID0gZml0Vmlld1N5bmMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5maXRWaWV3T25Jbml0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGZpdFZpZXdPbkluaXRPcHRpb25zPy5ub2RlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlcmUgd2UgYXJlIGNpcm11bXZlbnRpbmcgdGhlIG9uTm9kZXNDaGFuZ2UgaGFuZGxlclxuICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBkaXNwbGF5IG5vZGVzIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIGhhcyBub3QgcHJvdmlkZWQgYW4gb25Ob2Rlc0NoYW5nZSBoYW5kbGVyLlxuICAgICAgICAgICAgLy8gTm9kZXMgYXJlIG9ubHkgcmVuZGVyZWQgaWYgdGhleSBoYXZlIGEgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdoaWNoIHRoZXkgZ2V0IGZyb20gdGhpcyBoYW5kbGVyLlxuICAgICAgICAgICAgc2V0KHsgZml0Vmlld0RvbmU6IG5leHRGaXRWaWV3RG9uZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGFsd2F5cyB3YW50IHRvIHRyaWdnZXIgdXNlU3RvcmUgY2FsbHMgd2hlbmV2ZXIgdXBkYXRlTm9kZUludGVybmFscyBpcyBjYWxsZWRcbiAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoaWxkcmVuID0gW107XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBub2RlRHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtPy5leHBhbmRQYXJlbnQgJiYgZHJhZ0l0ZW0/LnBhcmVudElkICYmIGNoYW5nZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcmVudEV4cGFuZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGRyYWdJdGVtLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kcmFnSXRlbS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5wb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgY2hhbmdlLnBvc2l0aW9uLngpO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5wb3NpdGlvbi55ID0gTWF0aC5tYXgoMCwgY2hhbmdlLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudEV4cGFuZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KCkudHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH0sXG4gICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIHNldE5vZGVzLCBub2RlcywgaGFzRGVmYXVsdE5vZGVzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXROb2Rlcyh1cGRhdGVkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgbm9kZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXJFZGdlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkVkZ2VzQ2hhbmdlLCBzZXRFZGdlcywgZWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEVkZ2VzID0gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FZGdlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwKSk7XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VkRWRnZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkRWRnZUlkc10pKSk7XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoKSwgdHJ1ZSkpO1xuICAgIH0sXG4gICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzOiAoeyBub2RlcywgZWRnZXMgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXM6IHN0b3JlRWRnZXMsIG5vZGVzOiBzdG9yZU5vZGVzLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICBjb25zdCBlZGdlc1RvVW5zZWxlY3QgPSBlZGdlcyA/IGVkZ2VzIDogc3RvcmVFZGdlcztcbiAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlc1RvVW5zZWxlY3QubWFwKChuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVuc2VsZWN0IHRoZSBpbnRlcm5hbCBub2RlIHRoYXQgd2FzIHNlbGVjdGVkIHByZXZpb3VzbHkgYmVmb3JlIHdlXG4gICAgICAgICAgICAgICAgLy8gc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxOb2RlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG4uaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgfSxcbiAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB7IHBhblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICBzZXQoeyBtaW5ab29tIH0pO1xuICAgIH0sXG4gICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgcGFuWm9vbT8uc2V0U2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogKHRyYW5zbGF0ZUV4dGVudCkgPT4ge1xuICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgc2V0KHsgdHJhbnNsYXRlRXh0ZW50IH0pO1xuICAgIH0sXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgIGdldCgpLnBhblpvb20/LnNldENsaWNrRGlzdGFuY2UoY2xpY2tEaXN0YW5jZSk7XG4gICAgfSxcbiAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlcy5yZWR1Y2UoKHJlcywgZWRnZSkgPT4gKGVkZ2Uuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICB9LFxuICAgIHNldE5vZGVFeHRlbnQ6IChuZXh0Tm9kZUV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG5leHROb2RlRXh0ZW50WzBdWzBdID09PSBub2RlRXh0ZW50WzBdWzBdICYmXG4gICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFswXVsxXSA9PT0gbm9kZUV4dGVudFswXVsxXSAmJlxuICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzFdID09PSBub2RlRXh0ZW50WzFdWzFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICBjaGVja0VxdWFsaXR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHNldCh7IG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50IH0pO1xuICAgIH0sXG4gICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIH0sXG4gICAgZml0VmlldzogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBwYW5ab29tLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBub2RlTG9va3VwIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmaXRWaWV3KHtcbiAgICAgICAgICAgIG5vZGVzOiBmaXRWaWV3Tm9kZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICAvLyB3ZSBjYW4ndCBjYWxsIGFuIGFzbnljaHJvbm91cyBmdW5jdGlvbiBpbiB1cGRhdGVOb2RlSW50ZXJuYWxzXG4gICAgLy8gZm9yIHRoYXQgd2UgY3JlYXRlZCB0aGlzIHN5bmMgdmVyc2lvbiBvZiBmaXRWaWV3XG4gICAgZml0Vmlld1N5bmM6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgZml0Vmlldyh7XG4gICAgICAgICAgICBub2RlczogZml0Vmlld05vZGVzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZml0Vmlld05vZGVzLnNpemUgPiAwO1xuICAgIH0sXG4gICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9KSB7XG4gICAgY29uc3QgaXNXcmFwcGVkID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChpc1dyYXBwZWQpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIGl0IHdpdGggYSBmcmFnbWVudCBiZWNhdXNlIGl0J3Mgbm90IGFsbG93ZWQgZm9yIGNoaWxkcmVuIHRvIGJlIGEgUmVhY3ROb2RlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2lzc3Vlcy8xODA1MVxuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDAsXG59O1xuZnVuY3Rpb24gUmVhY3RGbG93KHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgY2xhc3NOYW1lLCBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlLCBvblNlbGVjdGlvbkNoYW5nZSwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RvcCwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uQmVmb3JlRGVsZXRlLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvbkxpbmVUeXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIGRlbGV0ZUtleUNvZGUgPSAnQmFja3NwYWNlJywgc2VsZWN0aW9uS2V5Q29kZSA9ICdTaGlmdCcsIHNlbGVjdGlvbk9uRHJhZyA9IGZhbHNlLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSA9ICdTcGFjZScsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgem9vbUFjdGl2YXRpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBub2RlT3JpZ2luID0gZGVmYXVsdE5vZGVPcmlnaW4sIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0JDEgPSBkZWZhdWx0Vmlld3BvcnQsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCB0cmFuc2xhdGVFeHRlbnQgPSBpbmZpbml0ZUV4dGVudCwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIG5vZGVFeHRlbnQsIGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3Jywgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSA9IDAsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgY2hpbGRyZW4sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgY29ubmVjdE9uQ2xpY2ssIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQsIGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uLCBvbkVycm9yLCBzdHlsZSwgaWQsIG5vZGVEcmFnVGhyZXNob2xkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgd2lkdGgsIGhlaWdodCwgY29sb3JNb2RlID0gJ2xpZ2h0JywgZGVidWcsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICBjb25zdCBjb2xvck1vZGVDbGFzc05hbWUgPSB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgLi4ucmVzdCwgc3R5bGU6IHsgLi4uc3R5bGUsIC4uLndyYXBwZXJTdHlsZSB9LCByZWY6IHJlZiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3cnLCBjbGFzc05hbWUsIGNvbG9yTW9kZUNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX3dyYXBwZXJcIiwgaWQ6IGlkLCBjaGlsZHJlbjoganN4cyhXcmFwcGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBlbGV2YXRlTm9kZXNPblNlbGVjdDogZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBlbGV2YXRlRWRnZXNPblNlbGVjdCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgb25Ob2Rlc0NoYW5nZTogb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZTogb25FZGdlc0NoYW5nZSwgc25hcFRvR3JpZDogc25hcFRvR3JpZCwgc25hcEdyaWQ6IHNuYXBHcmlkLCBjb25uZWN0aW9uTW9kZTogY29ubmVjdGlvbk1vZGUsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljazogY29ubmVjdE9uQ2xpY2ssIGRlZmF1bHRFZGdlT3B0aW9uczogZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3OiBmaXRWaWV3LCBmaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIG9uTm9kZXNEZWxldGU6IG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGU6IG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlOiBvbkRlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgcmZJZDogcmZJZCwgYXV0b1Bhbk9uQ29ubmVjdDogYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWc6IGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQ6IGF1dG9QYW5TcGVlZCwgb25FcnJvcjogb25FcnJvciwgY29ubmVjdGlvblJhZGl1czogY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uLCBzZWxlY3ROb2Rlc09uRHJhZzogc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkOiBub2RlRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZyB9KSwganN4KFNlbGVjdGlvbkxpc3RlbmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KSwgY2hpbGRyZW4sIGpzeChBdHRyaWJ1dGlvbiwgeyBwcm9PcHRpb25zOiBwcm9PcHRpb25zLCBwb3NpdGlvbjogYXR0cmlidXRpb25Qb3NpdGlvbiB9KSwganN4KEExMXlEZXNjcmlwdGlvbnMsIHsgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KV0gfSkgfSkpO1xufVxudmFyIGluZGV4ID0gZml4ZWRGb3J3YXJkUmVmKFJlYWN0Rmxvdyk7XG5cbmNvbnN0IHNlbGVjdG9yJDYgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyJyk7XG5mdW5jdGlvbiBFZGdlTGFiZWxSZW5kZXJlcih7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBlZGdlTGFiZWxSZW5kZXJlciA9IHVzZVN0b3JlKHNlbGVjdG9yJDYpO1xuICAgIGlmICghZWRnZUxhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVkZ2VMYWJlbFJlbmRlcmVyKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNSA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWwnKTtcbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIHVwZGF0aW5nIG5vZGUgaW50ZXJuYWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIGludGVybmFsc1xuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgbm9kZXMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXNcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmNvbnN0IGVkZ2VzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmVkZ2VzO1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IGVkZ2VzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGVkZ2VzXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoZWRnZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuXG5jb25zdCB2aWV3cG9ydFNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxufSk7XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgdmlld3BvcnQgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIG5vZGVzIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHJvdG90eXBpbmcgLyBzaW1wbGUgdXNlIGNhc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpbml0aWFsTm9kZXNcbiAqIEByZXR1cm5zIGFuIGFycmF5IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKSB7XG4gICAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShpbml0aWFsTm9kZXMpO1xuICAgIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0Tm9kZXMoKG5kcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBuZHMpKSwgW10pO1xuICAgIHJldHVybiBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXTtcbn1cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIGVkZ2VzIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHJvdG90eXBpbmcgLyBzaW1wbGUgdXNlIGNhc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpbml0aWFsRWRnZXNcbiAqIEByZXR1cm5zIGFuIGFycmF5IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKSB7XG4gICAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShpbml0aWFsRWRnZXMpO1xuICAgIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0RWRnZXMoKGVkcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZHMpKSwgW10pO1xuICAgIHJldHVybiBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciByZWdpc3RlcmluZyBhbiBvblZpZXdwb3J0Q2hhbmdlIGhhbmRsZXIuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcy5vblN0YXJ0IC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgc3RhcnRzIGNoYW5naW5nXG4gKiBAcGFyYW0gcGFyYW1zLm9uQ2hhbmdlIC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlc1xuICogQHBhcmFtIHBhcmFtcy5vbkVuZCAtIGdldHMgY2FsbGVkIHdoZW4gdGhlIHZpZXdwb3J0IHN0b3BzIGNoYW5naW5nXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciByZWdpc3RlcmluZyBhbiBvblNlbGVjdGlvbkNoYW5nZSBoYW5kbGVyLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBwYXJhbXMub25DaGFuZ2UgLSBUaGUgaGFuZGxlciB0byByZWdpc3RlclxuICovXG5mdW5jdGlvbiB1c2VPblNlbGVjdGlvbkNoYW5nZSh7IG9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLCBvbkNoYW5nZV07XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZmlsdGVyKChmbikgPT4gZm4gIT09IG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dEhhbmRsZXJzIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtvbkNoYW5nZV0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ0ID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKHMubm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCB7IGhpZGRlbiwgaW50ZXJuYWxzIH1dIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMgfHwgIWhpZGRlbikge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCB8fCAhbm9kZUhhc0RpbWVuc2lvbnMoaW50ZXJuYWxzLnVzZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxufTtcbi8qKlxuICogSG9vayB3aGljaCByZXR1cm5zIHRydWUgd2hlbiBhbGwgbm9kZXMgYXJlIGluaXRpYWxpemVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVIaWRkZW5Ob2RlcyAtIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbGwgbm9kZXMgYXJlIGluaXRpYWxpemVkXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciQ0KG9wdGlvbnMpKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiBhIDxIYW5kbGUgLz4gaXMgY29ubmVjdGVkIHRvIGFub3RoZXIgPEhhbmRsZSAvPiBhbmQgZ2V0IHRoZSBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW0udHlwZSAtIGhhbmRsZSB0eXBlICdzb3VyY2UnIG9yICd0YXJnZXQnXG4gKiBAcGFyYW0gcGFyYW0ubm9kZUlkIC0gbm9kZSBpZCAtIGlmIG5vdCBwcm92aWRlZCwgdGhlIG5vZGUgaWQgZnJvbSB0aGUgTm9kZUlkQ29udGV4dCBpcyB1c2VkXG4gKiBAcGFyYW0gcGFyYW0uaWQgLSB0aGUgaGFuZGxlIGlkICh0aGlzIGlzIG9ubHkgbmVlZGVkIGlmIHRoZSBub2RlIGhhcyBtdWx0aXBsZSBoYW5kbGVzIG9mIHRoZSBzYW1lIHR5cGUpXG4gKiBAcGFyYW0gcGFyYW0ub25Db25uZWN0IC0gZ2V0cyBjYWxsZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAqIEBwYXJhbSBwYXJhbS5vbkRpc2Nvbm5lY3QgLSBnZXRzIGNhbGxlZCB3aGVuIGEgY29ubmVjdGlvbiBpcyByZW1vdmVkXG4gKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIGhhbmRsZSBjb25uZWN0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VIYW5kbGVDb25uZWN0aW9ucyh7IHR5cGUsIGlkID0gbnVsbCwgbm9kZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSkge1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9LSR7aWR9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2Rlc0RhdGEobm9kZUlkcykge1xuICAgIGNvbnN0IG5vZGVzRGF0YSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgaXNBcnJheU9mSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWRzKTtcbiAgICAgICAgY29uc3QgX25vZGVJZHMgPSBpc0FycmF5T2ZJZHMgPyBub2RlSWRzIDogW25vZGVJZHNdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBfbm9kZUlkcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbm9kZS5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5T2ZJZHMgPyBkYXRhIDogZGF0YVswXSA/PyBudWxsO1xuICAgIH0sIFtub2RlSWRzXSksIHNoYWxsb3dOb2RlRGF0YSk7XG4gICAgcmV0dXJuIG5vZGVzRGF0YTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIGFuIGludGVybmFsIG5vZGUgYnkgaWRcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgbm9kZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIG5vZGUgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVybmFsTm9kZShpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gcy5ub2RlTG9va3VwLmdldChpZCksIFtpZF0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gTGluZVBhdHRlcm4oeyBkaW1lbnNpb25zLCBsaW5lV2lkdGgsIHZhcmlhbnQsIGNsYXNzTmFtZSB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJwYXRoXCIsIHsgc3Ryb2tlV2lkdGg6IGxpbmVXaWR0aCwgZDogYE0ke2RpbWVuc2lvbnNbMF0gLyAyfSAwIFYke2RpbWVuc2lvbnNbMV19IE0wICR7ZGltZW5zaW9uc1sxXSAvIDJ9IEgke2RpbWVuc2lvbnNbMF19YCwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsIHZhcmlhbnQsIGNsYXNzTmFtZV0pIH0pKTtcbn1cbmZ1bmN0aW9uIERvdFBhdHRlcm4oeyByYWRpdXMsIGNsYXNzTmFtZSB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBjeDogcmFkaXVzLCBjeTogcmFkaXVzLCByOiByYWRpdXMsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19iYWNrZ3JvdW5kLXBhdHRlcm4nLCAnZG90cycsIGNsYXNzTmFtZV0pIH0pKTtcbn1cblxudmFyIEJhY2tncm91bmRWYXJpYW50O1xuKGZ1bmN0aW9uIChCYWNrZ3JvdW5kVmFyaWFudCkge1xuICAgIEJhY2tncm91bmRWYXJpYW50W1wiTGluZXNcIl0gPSBcImxpbmVzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJEb3RzXCJdID0gXCJkb3RzXCI7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJDcm9zc1wiXSA9IFwiY3Jvc3NcIjtcbn0pKEJhY2tncm91bmRWYXJpYW50IHx8IChCYWNrZ3JvdW5kVmFyaWFudCA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRTaXplID0ge1xuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzXTogMSxcbiAgICBbQmFja2dyb3VuZFZhcmlhbnQuTGluZXNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zc106IDYsXG59O1xuY29uc3Qgc2VsZWN0b3IkMyA9IChzKSA9PiAoeyB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLCBwYXR0ZXJuSWQ6IGBwYXR0ZXJuLSR7cy5yZklkfWAgfSk7XG5mdW5jdGlvbiBCYWNrZ3JvdW5kQ29tcG9uZW50KHsgaWQsIHZhcmlhbnQgPSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzLCBcbi8vIG9ubHkgdXNlZCBmb3IgZG90cyBhbmQgY3Jvc3NcbmdhcCA9IDIwLCBcbi8vIG9ubHkgdXNlZCBmb3IgbGluZXMgYW5kIGNyb3NzXG5zaXplLCBsaW5lV2lkdGggPSAxLCBvZmZzZXQgPSAwLCBjb2xvciwgYmdDb2xvciwgc3R5bGUsIGNsYXNzTmFtZSwgcGF0dGVybkNsYXNzTmFtZSwgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGF0dGVybklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciQzLCBzaGFsbG93KTtcbiAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IHNpemUgfHwgZGVmYXVsdFNpemVbdmFyaWFudF07XG4gICAgY29uc3QgaXNEb3RzID0gdmFyaWFudCA9PT0gQmFja2dyb3VuZFZhcmlhbnQuRG90cztcbiAgICBjb25zdCBpc0Nyb3NzID0gdmFyaWFudCA9PT0gQmFja2dyb3VuZFZhcmlhbnQuQ3Jvc3M7XG4gICAgY29uc3QgZ2FwWFkgPSBBcnJheS5pc0FycmF5KGdhcCkgPyBnYXAgOiBbZ2FwLCBnYXBdO1xuICAgIGNvbnN0IHNjYWxlZEdhcCA9IFtnYXBYWVswXSAqIHRyYW5zZm9ybVsyXSB8fCAxLCBnYXBYWVsxXSAqIHRyYW5zZm9ybVsyXSB8fCAxXTtcbiAgICBjb25zdCBzY2FsZWRTaXplID0gcGF0dGVyblNpemUgKiB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3Qgb2Zmc2V0WFkgPSBBcnJheS5pc0FycmF5KG9mZnNldCkgPyBvZmZzZXQgOiBbb2Zmc2V0LCBvZmZzZXRdO1xuICAgIGNvbnN0IHBhdHRlcm5EaW1lbnNpb25zID0gaXNDcm9zcyA/IFtzY2FsZWRTaXplLCBzY2FsZWRTaXplXSA6IHNjYWxlZEdhcDtcbiAgICBjb25zdCBzY2FsZWRPZmZzZXQgPSBbXG4gICAgICAgIG9mZnNldFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEgKyBwYXR0ZXJuRGltZW5zaW9uc1swXSAvIDIsXG4gICAgICAgIG9mZnNldFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDEgKyBwYXR0ZXJuRGltZW5zaW9uc1sxXSAvIDIsXG4gICAgXTtcbiAgICBjb25zdCBfcGF0dGVybklkID0gYCR7cGF0dGVybklkfSR7aWQgPyBpZCA6ICcnfWA7XG4gICAgcmV0dXJuIChqc3hzKFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQnLCBjbGFzc05hbWVdKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgLi4uY29udGFpbmVyU3R5bGUsXG4gICAgICAgICAgICAnLS14eS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogYmdDb2xvcixcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtcGF0dGVybi1jb2xvci1wcm9wcyc6IGNvbG9yLFxuICAgICAgICB9LCByZWY6IHJlZiwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19iYWNrZ3JvdW5kXCIsIGNoaWxkcmVuOiBbanN4KFwicGF0dGVyblwiLCB7IGlkOiBfcGF0dGVybklkLCB4OiB0cmFuc2Zvcm1bMF0gJSBzY2FsZWRHYXBbMF0sIHk6IHRyYW5zZm9ybVsxXSAlIHNjYWxlZEdhcFsxXSwgd2lkdGg6IHNjYWxlZEdhcFswXSwgaGVpZ2h0OiBzY2FsZWRHYXBbMV0sIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCBwYXR0ZXJuVHJhbnNmb3JtOiBgdHJhbnNsYXRlKC0ke3NjYWxlZE9mZnNldFswXX0sLSR7c2NhbGVkT2Zmc2V0WzFdfSlgLCBjaGlsZHJlbjogaXNEb3RzID8gKGpzeChEb3RQYXR0ZXJuLCB7IHJhZGl1czogc2NhbGVkU2l6ZSAvIDIsIGNsYXNzTmFtZTogcGF0dGVybkNsYXNzTmFtZSB9KSkgOiAoanN4KExpbmVQYXR0ZXJuLCB7IGRpbWVuc2lvbnM6IHBhdHRlcm5EaW1lbnNpb25zLCBsaW5lV2lkdGg6IGxpbmVXaWR0aCwgdmFyaWFudDogdmFyaWFudCwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSB9KSwganN4KFwicmVjdFwiLCB7IHg6IFwiMFwiLCB5OiBcIjBcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBmaWxsOiBgdXJsKCMke19wYXR0ZXJuSWR9KWAgfSldIH0pKTtcbn1cbkJhY2tncm91bmRDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnQmFja2dyb3VuZCc7XG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gQ29udHJvbEJ1dHRvbih7IGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkge1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzLWJ1dHRvbicsIGNsYXNzTmFtZV0pLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciQyID0gKHMpID0+ICh7XG4gICAgaXNJbnRlcmFjdGl2ZTogcy5ub2Rlc0RyYWdnYWJsZSB8fCBzLm5vZGVzQ29ubmVjdGFibGUgfHwgcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgbWluWm9vbVJlYWNoZWQ6IHMudHJhbnNmb3JtWzJdIDw9IHMubWluWm9vbSxcbiAgICBtYXhab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPj0gcy5tYXhab29tLFxufSk7XG5mdW5jdGlvbiBDb250cm9sc0NvbXBvbmVudCh7IHN0eWxlLCBzaG93Wm9vbSA9IHRydWUsIHNob3dGaXRWaWV3ID0gdHJ1ZSwgc2hvd0ludGVyYWN0aXZlID0gdHJ1ZSwgZml0Vmlld09wdGlvbnMsIG9uWm9vbUluLCBvblpvb21PdXQsIG9uRml0Vmlldywgb25JbnRlcmFjdGl2ZUNoYW5nZSwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSAnYm90dG9tLWxlZnQnLCBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsID0gJ1JlYWN0IEZsb3cgY29udHJvbHMnLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgaXNJbnRlcmFjdGl2ZSwgbWluWm9vbVJlYWNoZWQsIG1heFpvb21SZWFjaGVkIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCBjaGlsZHJlbjogW3Nob3dab29tICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KENvbnRyb2xCdXR0b24sIHsgb25DbGljazogb25ab29tSW5IYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbWluXCIsIHRpdGxlOiBcInpvb20gaW5cIiwgXCJhcmlhLWxhYmVsXCI6IFwiem9vbSBpblwiLCBkaXNhYmxlZDogbWF4Wm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goUGx1c0ljb24sIHt9KSB9KSwganN4KENvbnRyb2xCdXR0b24sIHsgb25DbGljazogb25ab29tT3V0SGFuZGxlciwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLXpvb21vdXRcIiwgdGl0bGU6IFwiem9vbSBvdXRcIiwgXCJhcmlhLWxhYmVsXCI6IFwiem9vbSBvdXRcIiwgZGlzYWJsZWQ6IG1pblpvb21SZWFjaGVkLCBjaGlsZHJlbjoganN4KE1pbnVzSWNvbiwge30pIH0pXSB9KSksIHNob3dGaXRWaWV3ICYmIChqc3goQ29udHJvbEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtZml0dmlld1wiLCBvbkNsaWNrOiBvbkZpdFZpZXdIYW5kbGVyLCB0aXRsZTogXCJmaXQgdmlld1wiLCBcImFyaWEtbGFiZWxcIjogXCJmaXQgdmlld1wiLCBjaGlsZHJlbjoganN4KEZpdFZpZXdJY29uLCB7fSkgfSkpLCBzaG93SW50ZXJhY3RpdmUgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1pbnRlcmFjdGl2ZVwiLCBvbkNsaWNrOiBvblRvZ2dsZUludGVyYWN0aXZpdHksIHRpdGxlOiBcInRvZ2dsZSBpbnRlcmFjdGl2aXR5XCIsIFwiYXJpYS1sYWJlbFwiOiBcInRvZ2dsZSBpbnRlcmFjdGl2aXR5XCIsIGNoaWxkcmVuOiBpc0ludGVyYWN0aXZlID8ganN4KFVubG9ja0ljb24sIHt9KSA6IGpzeChMb2NrSWNvbiwge30pIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn1cbkNvbnRyb2xzQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0NvbnRyb2xzJztcbmNvbnN0IENvbnRyb2xzID0gbWVtbyhDb250cm9sc0NvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIE1pbmlNYXBOb2RlQ29tcG9uZW50KHsgaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCBjb2xvciwgc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoLCBjbGFzc05hbWUsIGJvcmRlclJhZGl1cywgc2hhcGVSZW5kZXJpbmcsIHNlbGVjdGVkLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kQ29sb3IgfSA9IHN0eWxlIHx8IHt9O1xuICAgIGNvbnN0IGZpbGwgPSAoY29sb3IgfHwgYmFja2dyb3VuZCB8fCBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHJldHVybiAoanN4KFwicmVjdFwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwLW5vZGUnLCB7IHNlbGVjdGVkIH0sIGNsYXNzTmFtZV0pLCB4OiB4LCB5OiB5LCByeDogYm9yZGVyUmFkaXVzLCByeTogYm9yZGVyUmFkaXVzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZToge1xuICAgICAgICAgICAgZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrID8gKGV2ZW50KSA9PiBvbkNsaWNrKGV2ZW50LCBpZCkgOiB1bmRlZmluZWQgfSkpO1xufVxuY29uc3QgTWluaU1hcE5vZGUgPSBtZW1vKE1pbmlNYXBOb2RlQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3JOb2RlSWRzID0gKHMpID0+IHMubm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbmNvbnN0IGdldEF0dHJGdW5jdGlvbiA9IChmdW5jKSA9PiBmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBmdW5jIDogKCkgPT4gZnVuYztcbmZ1bmN0aW9uIE1pbmlNYXBOb2Rlcyh7IG5vZGVTdHJva2VDb2xvciwgbm9kZUNvbG9yLCBub2RlQ2xhc3NOYW1lID0gJycsIG5vZGVCb3JkZXJSYWRpdXMgPSA1LCBub2RlU3Ryb2tlV2lkdGgsIFxuLy8gV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuLy8gYSBjb21wb25lbnQgcHJvcGVybHkuXG5ub2RlQ29tcG9uZW50OiBOb2RlQ29tcG9uZW50ID0gTWluaU1hcE5vZGUsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUoc2VsZWN0b3JOb2RlSWRzLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDb2xvcik7XG4gICAgY29uc3Qgbm9kZVN0cm9rZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlU3Ryb2tlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVDbGFzc05hbWVGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNoYXBlUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgISF3aW5kb3cuY2hyb21lID8gJ2NyaXNwRWRnZXMnIDogJ2dlb21ldHJpY1ByZWNpc2lvbic7XG4gICAgcmV0dXJuIChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IChcbiAgICAgICAgLy8gVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBNaW5pTWFwTm9kZXMgYW5kXG4gICAgICAgIC8vIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY29zdCBvZiB1cGRhdGVzIHdoZW4gaW5kaXZpZHVhbCBub2RlcyBjaGFuZ2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvciBtb3JlIGRldGFpbHMsIHNlZSBhIHNpbWlsYXIgY29tbWl0IGluIGBOb2RlUmVuZGVyZXIvaW5kZXgudHN4YC5cbiAgICAgICAganN4KE5vZGVDb21wb25lbnRXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVDb2xvckZ1bmM6IG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmM6IG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jOiBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIE5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQsIG9uQ2xpY2s6IG9uQ2xpY2ssIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZyB9LCBub2RlSWQpKSkgfSkpO1xufVxuZnVuY3Rpb24gTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcih7IGlkLCBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZywgTm9kZUNvbXBvbmVudCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5oaWRkZW4gfHwgIW5vZGVIYXNEaW1lbnNpb25zKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb2RlQ29tcG9uZW50LCB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiBub2RlLnN0eWxlLCBzZWxlY3RlZDogISFub2RlLnNlbGVjdGVkLCBjbGFzc05hbWU6IG5vZGVDbGFzc05hbWVGdW5jKG5vZGUpLCBjb2xvcjogbm9kZUNvbG9yRnVuYyhub2RlKSwgYm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBzdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yRnVuYyhub2RlKSwgc3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrLCBpZDogbm9kZS5pZCB9KSk7XG59XG5jb25zdCBOb2RlQ29tcG9uZW50V3JhcHBlciA9IG1lbW8oTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcik7XG52YXIgTWluaU1hcE5vZGVzJDEgPSBtZW1vKE1pbmlNYXBOb2Rlcyk7XG5cbmNvbnN0IGRlZmF1bHRXaWR0aCA9IDIwMDtcbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNTA7XG5jb25zdCBzZWxlY3RvciQxID0gKHMpID0+IHtcbiAgICBjb25zdCB2aWV3QkIgPSB7XG4gICAgICAgIHg6IC1zLnRyYW5zZm9ybVswXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB5OiAtcy50cmFuc2Zvcm1bMV0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHMud2lkdGggLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCAvIHMudHJhbnNmb3JtWzJdLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlld0JCLFxuICAgICAgICBib3VuZGluZ1JlY3Q6IHMubm9kZUxvb2t1cC5zaXplID4gMCA/IGdldEJvdW5kc09mUmVjdHMoZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXApLCB2aWV3QkIpIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgICAgIHBhblpvb206IHMucGFuWm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBzLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgZmxvd1dpZHRoOiBzLndpZHRoLFxuICAgICAgICBmbG93SGVpZ2h0OiBzLmhlaWdodCxcbiAgICB9O1xufTtcbmNvbnN0IEFSSUFfTEFCRUxfS0VZID0gJ3JlYWN0LWZsb3dfX21pbmltYXAtZGVzYyc7XG5mdW5jdGlvbiBNaW5pTWFwQ29tcG9uZW50KHsgc3R5bGUsIGNsYXNzTmFtZSwgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vLyBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4vLyBhIGNvbXBvbmVudCBwcm9wZXJseS5cbm5vZGVDb21wb25lbnQsIGJnQ29sb3IsIG1hc2tDb2xvciwgbWFza1N0cm9rZUNvbG9yLCBtYXNrU3Ryb2tlV2lkdGgsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcsIG9uQ2xpY2ssIG9uTm9kZUNsaWNrLCBwYW5uYWJsZSA9IGZhbHNlLCB6b29tYWJsZSA9IGZhbHNlLCBhcmlhTGFiZWwgPSAnUmVhY3QgRmxvdyBtaW5pIG1hcCcsIGludmVyc2VQYW4sIHpvb21TdGVwID0gMTAsIG9mZnNldFNjYWxlID0gNSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzdmcgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyBib3VuZGluZ1JlY3QsIHZpZXdCQiwgcmZJZCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHN0eWxlPy53aWR0aCA/PyBkZWZhdWx0V2lkdGg7XG4gICAgY29uc3QgZWxlbWVudEhlaWdodCA9IHN0eWxlPy5oZWlnaHQgPz8gZGVmYXVsdEhlaWdodDtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCB2aWV3U2NhbGUgPSBNYXRoLm1heChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCB2aWV3V2lkdGggPSB2aWV3U2NhbGUgKiBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgdmlld0hlaWdodCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0U2NhbGUgKiB2aWV3U2NhbGU7XG4gICAgY29uc3QgeCA9IGJvdW5kaW5nUmVjdC54IC0gKHZpZXdXaWR0aCAtIGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHkgPSBib3VuZGluZ1JlY3QueSAtICh2aWV3SGVpZ2h0IC0gYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyIC0gb2Zmc2V0O1xuICAgIGNvbnN0IHdpZHRoID0gdmlld1dpZHRoICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBoZWlnaHQgPSB2aWV3SGVpZ2h0ICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCBsYWJlbGxlZEJ5ID0gYCR7QVJJQV9MQUJFTF9LRVl9LSR7cmZJZH1gO1xuICAgIGNvbnN0IHZpZXdTY2FsZVJlZiA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBtaW5pbWFwSW5zdGFuY2UgPSB1c2VSZWYoKTtcbiAgICB2aWV3U2NhbGVSZWYuY3VycmVudCA9IHZpZXdTY2FsZTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3ZnLmN1cnJlbnQgJiYgcGFuWm9vbSkge1xuICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQgPSBYWU1pbmltYXAoe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHN2Zy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRWaWV3U2NhbGU6ICgpID0+IHZpZXdTY2FsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW3Bhblpvb21dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgIHdpZHRoOiBmbG93V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGZsb3dIZWlnaHQsXG4gICAgICAgICAgICBpbnZlcnNlUGFuLFxuICAgICAgICAgICAgcGFubmFibGUsXG4gICAgICAgICAgICB6b29tU3RlcCxcbiAgICAgICAgICAgIHpvb21hYmxlLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFubmFibGUsIHpvb21hYmxlLCBpbnZlcnNlUGFuLCB6b29tU3RlcCwgdHJhbnNsYXRlRXh0ZW50LCBmbG93V2lkdGgsIGZsb3dIZWlnaHRdKTtcbiAgICBjb25zdCBvblN2Z0NsaWNrID0gb25DbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnBvaW50ZXIoZXZlbnQpIHx8IFswLCAwXTtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblN2Z05vZGVDbGljayA9IG9uTm9kZUNsaWNrXG4gICAgICAgID8gdXNlQ2FsbGJhY2soKGV2ZW50LCBub2RlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBvbk5vZGVDbGljayhldmVudCwgbm9kZSk7XG4gICAgICAgIH0sIFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBiZ0NvbG9yID09PSAnc3RyaW5nJyA/IGJnQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbWFza1N0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBtYXNrU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbWFza1N0cm9rZVdpZHRoICogdmlld1NjYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG5vZGVTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2Ygbm9kZVN0cm9rZVdpZHRoID09PSAnc3RyaW5nJyA/IG5vZGVTdHJva2VXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAnLCBjbGFzc05hbWVdKSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19taW5pbWFwXCIsIGNoaWxkcmVuOiBqc3hzKFwic3ZnXCIsIHsgd2lkdGg6IGVsZW1lbnRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50SGVpZ2h0LCB2aWV3Qm94OiBgJHt4fSAke3l9ICR7d2lkdGh9ICR7aGVpZ2h0fWAsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLXN2Z1wiLCByb2xlOiBcImltZ1wiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5LCByZWY6IHN2Zywgb25DbGljazogb25TdmdDbGljaywgY2hpbGRyZW46IFthcmlhTGFiZWwgJiYganN4KFwidGl0bGVcIiwgeyBpZDogbGFiZWxsZWRCeSwgY2hpbGRyZW46IGFyaWFMYWJlbCB9KSwganN4KE1pbmlNYXBOb2RlcyQxLCB7IG9uQ2xpY2s6IG9uU3ZnTm9kZUNsaWNrLCBub2RlQ29sb3I6IG5vZGVDb2xvciwgbm9kZVN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3IsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVDbGFzc05hbWU6IG5vZGVDbGFzc05hbWUsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBub2RlQ29tcG9uZW50OiBub2RlQ29tcG9uZW50IH0pLCBqc3goXCJwYXRoXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtbWFza1wiLCBkOiBgTSR7eCAtIG9mZnNldH0sJHt5IC0gb2Zmc2V0fWgke3dpZHRoICsgb2Zmc2V0ICogMn12JHtoZWlnaHQgKyBvZmZzZXQgKiAyfWgkey13aWR0aCAtIG9mZnNldCAqIDJ9elxuICAgICAgICBNJHt2aWV3QkIueH0sJHt2aWV3QkIueX1oJHt2aWV3QkIud2lkdGh9diR7dmlld0JCLmhlaWdodH1oJHstdmlld0JCLndpZHRofXpgLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0pXSB9KSB9KSk7XG59XG5NaW5pTWFwQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ01pbmlNYXAnO1xuY29uc3QgTWluaU1hcCA9IG1lbW8oTWluaU1hcENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIFJlc2l6ZUNvbnRyb2woeyBub2RlSWQsIHBvc2l0aW9uLCB2YXJpYW50ID0gUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlLCBjbGFzc05hbWUsIHN0eWxlID0ge30sIGNoaWxkcmVuLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGlkID0gdHlwZW9mIG5vZGVJZCA9PT0gJ3N0cmluZycgPyBub2RlSWQgOiBjb250ZXh0Tm9kZUlkO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCByZXNpemVDb250cm9sUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRlZmF1bHRQb3NpdGlvbiA9IHZhcmlhbnQgPT09IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUgPyAncmlnaHQnIDogJ2JvdHRvbS1yaWdodCc7XG4gICAgY29uc3QgY29udHJvbFBvc2l0aW9uID0gcG9zaXRpb24gPz8gZGVmYXVsdFBvc2l0aW9uO1xuICAgIGNvbnN0IHJlc2l6ZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFyZXNpemVDb250cm9sUmVmLmN1cnJlbnQgfHwgIWlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNpemVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudCA9IFhZUmVzaXplcih7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogcmVzaXplQ29udHJvbFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmVJdGVtczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAoY2hhbmdlLCBjaGlsZENoYW5nZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VyTm9kZUNoYW5nZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB7IHg6IGNoYW5nZS54LCB5OiBjaGFuZ2UueSB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjaGFuZ2Uud2lkdGggPz8gbm9kZS5tZWFzdXJlZC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYW5nZS5oZWlnaHQgPz8gbm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGFuZ2UueCA/PyBub2RlLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGFuZ2UueSA/PyBub2RlLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgd2lkdGgsIGhlaWdodCB9LCBub2RlLnBhcmVudElkLCBub2RlTG9va3VwLCBvcmlnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChbY2hpbGRdLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLnBhcmVudEV4cGFuZENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgcGFyZW50IHdhcyBleHBhbmRlZCBieSB0aGUgY2hpbGQgbm9kZSwgaXRzIHBvc2l0aW9uIHdpbGwgYmUgY2xhbXBlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCwwIHdoZW4gbm9kZSBvcmlnaW4gaXMgMCwwIGFuZCB0byB3aWR0aCwgaGVpZ2h0IGlmIGl0J3MgMSwxXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueCA9IGNoYW5nZS54ID8gTWF0aC5tYXgob3JpZ2luWzBdICogd2lkdGgsIGNoYW5nZS54KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi55ID0gY2hhbmdlLnkgPyBNYXRoLm1heChvcmlnaW5bMV0gKiBoZWlnaHQsIGNoYW5nZS55KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBuZXh0UG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IC4uLm5leHRQb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNoYW5nZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNoYW5nZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjaGFuZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGRpbWVuc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZENoYW5nZSBvZiBjaGlsZENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVuZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkudHJpZ2dlck5vZGVDaGFuZ2VzKFtkaW1lbnNpb25DaGFuZ2VdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzaXplci5jdXJyZW50LnVwZGF0ZSh7XG4gICAgICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgICAgICBib3VuZGFyaWVzOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGgsXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICAgICAgb25SZXNpemUsXG4gICAgICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNpemVyLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgbWluV2lkdGgsXG4gICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIG1heEhlaWdodCxcbiAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0LFxuICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgIHNob3VsZFJlc2l6ZSxcbiAgICBdKTtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzTmFtZXMgPSBjb250cm9sUG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICBjb25zdCBjb2xvclN0eWxlUHJvcCA9IHZhcmlhbnQgPT09IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUgPyAnYm9yZGVyQ29sb3InIDogJ2JhY2tncm91bmRDb2xvcic7XG4gICAgY29uc3QgY29udHJvbFN0eWxlID0gY29sb3IgPyB7IC4uLnN0eWxlLCBbY29sb3JTdHlsZVByb3BdOiBjb2xvciB9IDogc3R5bGU7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcmVzaXplLWNvbnRyb2wnLCAnbm9kcmFnJywgLi4ucG9zaXRpb25DbGFzc05hbWVzLCB2YXJpYW50LCBjbGFzc05hbWVdKSwgcmVmOiByZXNpemVDb250cm9sUmVmLCBzdHlsZTogY29udHJvbFN0eWxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuY29uc3QgTm9kZVJlc2l6ZUNvbnRyb2wgPSBtZW1vKFJlc2l6ZUNvbnRyb2wpO1xuXG5mdW5jdGlvbiBOb2RlUmVzaXplcih7IG5vZGVJZCwgaXNWaXNpYmxlID0gdHJ1ZSwgaGFuZGxlQ2xhc3NOYW1lLCBoYW5kbGVTdHlsZSwgbGluZUNsYXNzTmFtZSwgbGluZVN0eWxlLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHNob3VsZFJlc2l6ZSwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCB9KSB7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1hZX1JFU0laRVJfTElORV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGxpbmVDbGFzc05hbWUsIHN0eWxlOiBsaW5lU3R5bGUsIG5vZGVJZDogbm9kZUlkLCBwb3NpdGlvbjogcG9zaXRpb24sIHZhcmlhbnQ6IFJlc2l6ZUNvbnRyb2xWYXJpYW50LkxpbmUsIGNvbG9yOiBjb2xvciwgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydCwga2VlcEFzcGVjdFJhdGlvOiBrZWVwQXNwZWN0UmF0aW8sIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKSwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsIHN0eWxlOiBoYW5kbGVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpXSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yID0gKHN0YXRlKSA9PiBzdGF0ZS5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcmVuZGVyZXInKTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyUG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VTdG9yZShzZWxlY3Rvcik7XG4gICAgaWYgKCF3cmFwcGVyUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB3cmFwcGVyUmVmKTtcbn1cblxuY29uc3Qgbm9kZUVxdWFsaXR5Rm4gPSAoYSwgYikgPT4gYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCB8fFxuICAgIGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgfHxcbiAgICBhPy5tZWFzdXJlZC53aWR0aCAhPT0gYj8ubWVhc3VyZWQud2lkdGggfHxcbiAgICBhPy5tZWFzdXJlZC5oZWlnaHQgIT09IGI/Lm1lYXN1cmVkLmhlaWdodCB8fFxuICAgIGE/LnNlbGVjdGVkICE9PSBiPy5zZWxlY3RlZCB8fFxuICAgIGE/LmludGVybmFscy56ICE9PSBiPy5pbnRlcm5hbHMuejtcbmNvbnN0IG5vZGVzRXF1YWxpdHlGbiA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBhKSB7XG4gICAgICAgIGlmIChub2RlRXF1YWxpdHlGbihub2RlLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IHN0b3JlU2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG4gICAgc2VsZWN0ZWROb2Rlc0NvdW50OiBzdGF0ZS5ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpLmxlbmd0aCxcbn0pO1xuZnVuY3Rpb24gTm9kZVRvb2xiYXIoeyBub2RlSWQsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCBpc1Zpc2libGUsIHBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBvZmZzZXQgPSAxMCwgYWxpZ24gPSAnY2VudGVyJywgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IG5vZGVzU2VsZWN0b3IgPSB1c2VDYWxsYmFjaygoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZUlkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkKSA/IG5vZGVJZCA6IFtub2RlSWQgfHwgY29udGV4dE5vZGVJZCB8fCAnJ107XG4gICAgICAgIGNvbnN0IGludGVybmFsTm9kZXMgPSBub2RlSWRzLnJlZHVjZSgocmVzLCBpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE5vZGVzO1xuICAgIH0sIFtub2RlSWQsIGNvbnRleHROb2RlSWRdKTtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIG5vZGVzRXF1YWxpdHlGbik7XG4gICAgY29uc3QgeyB4LCB5LCB6b29tLCBzZWxlY3RlZE5vZGVzQ291bnQgfSA9IHVzZVN0b3JlKHN0b3JlU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIC8vIGlmIGlzVmlzaWJsZSBpcyBub3Qgc2V0LCB3ZSBzaG93IHRoZSB0b29sYmFyIG9ubHkgaWYgaXRzIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIG5vIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHR5cGVvZiBpc1Zpc2libGUgPT09ICdib29sZWFuJ1xuICAgICAgICA/IGlzVmlzaWJsZVxuICAgICAgICA6IG5vZGVzLnNpemUgPT09IDEgJiYgbm9kZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlLnNlbGVjdGVkICYmIHNlbGVjdGVkTm9kZXNDb3VudCA9PT0gMTtcbiAgICBpZiAoIWlzQWN0aXZlIHx8ICFub2Rlcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlUmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IG5vZGVzQXJyYXkgPSBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKTtcbiAgICBjb25zdCB6SW5kZXggPSBNYXRoLm1heCguLi5ub2Rlc0FycmF5Lm1hcCgobm9kZSkgPT4gbm9kZS5pbnRlcm5hbHMueiArIDEpKTtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0cmFuc2Zvcm06IGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB7IHgsIHksIHpvb20gfSwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pLFxuICAgICAgICB6SW5kZXgsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goTm9kZVRvb2xiYXJQb3J0YWwsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHN0eWxlOiB3cmFwcGVyU3R5bGUsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2RlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgXCJkYXRhLWlkXCI6IG5vZGVzQXJyYXkucmVkdWNlKChhY2MsIG5vZGUpID0+IGAke2FjY30ke25vZGUuaWR9IGAsICcnKS50cmltKCksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmV4cG9ydCB7IEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50LCBCYXNlRWRnZSwgQmV6aWVyRWRnZSwgQ29udHJvbEJ1dHRvbiwgQ29udHJvbHMsIEVkZ2VMYWJlbFJlbmRlcmVyLCBFZGdlVGV4dCwgSGFuZGxlLCBNaW5pTWFwLCBOb2RlUmVzaXplQ29udHJvbCwgTm9kZVJlc2l6ZXIsIE5vZGVUb29sYmFyLCBQYW5lbCwgaW5kZXggYXMgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgU2ltcGxlQmV6aWVyRWRnZSwgU21vb3RoU3RlcEVkZ2UsIFN0ZXBFZGdlLCBTdHJhaWdodEVkZ2UsIFZpZXdwb3J0UG9ydGFsLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBpc0VkZ2UsIGlzTm9kZSwgdXNlQ29ubmVjdGlvbiwgdXNlRWRnZXMsIHVzZUVkZ2VzU3RhdGUsIHVzZUhhbmRsZUNvbm5lY3Rpb25zLCB1c2VJbnRlcm5hbE5vZGUsIHVzZUtleVByZXNzLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjYyIsImVycm9yTWVzc2FnZXMiLCJpbmZpbml0ZUV4dGVudCIsImlzSW5wdXRET01Ob2RlIiwiZ2V0Rml0Vmlld05vZGVzIiwiZ2V0RGltZW5zaW9ucyIsImZpdFZpZXciLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJYWVBhblpvb20iLCJQYW5PblNjcm9sbE1vZGUiLCJTZWxlY3Rpb25Nb2RlIiwiZ2V0RXZlbnRQb3NpdGlvbiIsImdldE5vZGVzSW5zaWRlIiwiWFlEcmFnIiwic25hcFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9kZVBvc2l0aW9uIiwiUG9zaXRpb24iLCJDb25uZWN0aW9uTW9kZSIsImlzTW91c2VFdmVudCIsIlhZSGFuZGxlIiwiZ2V0SG9zdEZvckVsZW1lbnQiLCJhZGRFZGdlIiwiZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyIsImlzTnVtZXJpYyIsIm5vZGVIYXNEaW1lbnNpb25zIiwiZ2V0Tm9kZURpbWVuc2lvbnMiLCJlbGVtZW50U2VsZWN0aW9uS2V5cyIsImlzRWRnZVZpc2libGUiLCJNYXJrZXJUeXBlIiwiY3JlYXRlTWFya2VySWRzIiwiZ2V0QmV6aWVyRWRnZUNlbnRlciIsImdldFNtb290aFN0ZXBQYXRoIiwiZ2V0U3RyYWlnaHRQYXRoIiwiZ2V0QmV6aWVyUGF0aCIsImdldEVkZ2VQb3NpdGlvbiIsImdldEVsZXZhdGVkRWRnZVpJbmRleCIsImdldE1hcmtlcklkIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsIkNvbm5lY3Rpb25MaW5lVHlwZSIsInVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAiLCJhZG9wdFVzZXJOb2RlcyIsImluaXRpYWxDb25uZWN0aW9uIiwiZGV2V2FybiIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImhhbmRsZUV4cGFuZFBhcmVudCIsInBhbkJ5IiwiaXNNYWNPcyIsImFyZUNvbm5lY3Rpb25NYXBzRXF1YWwiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwic2hhbGxvd05vZGVEYXRhIiwiWFlNaW5pbWFwIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlSZXNpemVyIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsIlhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyIsImdldE5vZGVUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImZvcndhcmRSZWYiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRvIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJzZWxlY3RvciRuIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsIkF0dHJpYnV0aW9uIiwicHJvT3B0aW9ucyIsImhpZGVBdHRyaWJ1dGlvbiIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJzZWxlY3RvciRtIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkRWRnZXMiLCJub2RlIiwibm9kZUxvb2t1cCIsInNlbGVjdGVkIiwicHVzaCIsImludGVybmFscyIsInVzZXJOb2RlIiwiZWRnZSIsImVkZ2VMb29rdXAiLCJzZWxlY3RJZCIsIm9iaiIsImFyZUVxdWFsIiwiYSIsImIiLCJtYXAiLCJTZWxlY3Rpb25MaXN0ZW5lcklubmVyIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJwYXJhbXMiLCJub2RlcyIsImVkZ2VzIiwib25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImZvckVhY2giLCJmbiIsImNoYW5nZVNlbGVjdG9yIiwiU2VsZWN0aW9uTGlzdGVuZXIiLCJzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVmYXVsdE5vZGVPcmlnaW4iLCJkZWZhdWx0Vmlld3BvcnQiLCJ4IiwieSIsInpvb20iLCJyZWFjdEZsb3dGaWVsZHNUb1RyYWNrIiwiZmllbGRzVG9UcmFjayIsInNlbGVjdG9yJGwiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwic2V0TWluWm9vbSIsInNldE1heFpvb20iLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXROb2RlRXh0ZW50IiwicmVzZXQiLCJzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyIsInNldFBhbmVDbGlja0Rpc3RhbmNlIiwiaW5pdFByZXZWYWx1ZXMiLCJ0cmFuc2xhdGVFeHRlbnQiLCJub2RlT3JpZ2luIiwibWluWm9vbSIsIm1heFpvb20iLCJlbGVtZW50c1NlbGVjdGFibGUiLCJub1BhbkNsYXNzTmFtZSIsInBhbmVDbGlja0Rpc3RhbmNlIiwiU3RvcmVVcGRhdGVyIiwicHJvcHMiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJwcmV2aW91c0ZpZWxkcyIsImN1cnJlbnQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwicHJldmlvdXNGaWVsZFZhbHVlIiwiZml0Vmlld09uSW5pdCIsImZpdFZpZXdPbkluaXRPcHRpb25zIiwiZ2V0TWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJ1c2VDb2xvck1vZGVDbGFzcyIsImNvbG9yTW9kZSIsImNvbG9yTW9kZUNsYXNzIiwic2V0Q29sb3JNb2RlQ2xhc3MiLCJtZWRpYVF1ZXJ5IiwidXBkYXRlQ29sb3JNb2RlQ2xhc3MiLCJtYXRjaGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0RG9jIiwiZG9jdW1lbnQiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJvcHRpb25zIiwiYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIiLCJrZXlQcmVzc2VkIiwic2V0S2V5UHJlc3NlZCIsIm1vZGlmaWVyUHJlc3NlZCIsInByZXNzZWRLZXlzIiwiU2V0Iiwia2V5Q29kZXMiLCJrZXlzVG9XYXRjaCIsImtleUNvZGVBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiZmlsdGVyIiwia2MiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsInByZXZlbnREZWZhdWx0IiwidXBIYW5kbGVyIiwiY2xlYXIiLCJkZWxldGUiLCJrZXkiLCJyZXNldEhhbmRsZXIiLCJpc1VwIiwibGVuZ3RoIiwic2l6ZSIsInNvbWUiLCJldmVyeSIsImsiLCJoYXMiLCJldmVudENvZGUiLCJpbmNsdWRlcyIsInVzZVZpZXdwb3J0SGVscGVyIiwiem9vbUluIiwicGFuWm9vbSIsInNjYWxlQnkiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiem9vbU91dCIsInpvb21UbyIsInpvb21MZXZlbCIsInNjYWxlVG8iLCJnZXRab29tIiwidHJhbnNmb3JtIiwic2V0Vmlld3BvcnQiLCJ2aWV3cG9ydCIsInRYIiwidFkiLCJ0Wm9vbSIsImdldFZpZXdwb3J0IiwiZG9tTm9kZSIsImZpdFZpZXdOb2RlcyIsInNldENlbnRlciIsIm5leHRab29tIiwiY2VudGVyWCIsImNlbnRlclkiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcFRvR3JpZCIsInNuYXBHcmlkIiwiZG9tWCIsImRvbVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3JyZWN0ZWRQb3NpdGlvbiIsImZsb3dUb1NjcmVlblBvc2l0aW9uIiwiZmxvd1Bvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJlbGVtZW50cyIsInVwZGF0ZWRFbGVtZW50cyIsImNoYW5nZXNNYXAiLCJNYXAiLCJhZGRJdGVtQ2hhbmdlcyIsImNoYW5nZSIsInR5cGUiLCJzZXQiLCJlbGVtZW50Q2hhbmdlcyIsImdldCIsImVsZW1lbnQiLCJ1cGRhdGVkRWxlbWVudCIsImFwcGx5Q2hhbmdlIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJkcmFnZ2luZyIsImRpbWVuc2lvbnMiLCJtZWFzdXJlZCIsInNldEF0dHJpYnV0ZXMiLCJyZXNpemluZyIsImFwcGx5Tm9kZUNoYW5nZXMiLCJhcHBseUVkZ2VDaGFuZ2VzIiwiY3JlYXRlU2VsZWN0aW9uQ2hhbmdlIiwiZ2V0U2VsZWN0aW9uQ2hhbmdlcyIsIml0ZW1zIiwic2VsZWN0ZWRJZHMiLCJtdXRhdGVJdGVtIiwid2lsbEJlU2VsZWN0ZWQiLCJnZXRFbGVtZW50c0RpZmZDaGFuZ2VzIiwibG9va3VwIiwiaXRlbXNMb29rdXAiLCJlbnRyaWVzIiwibG9va3VwSXRlbSIsInN0b3JlSXRlbSIsIm5leHROb2RlIiwiZWxlbWVudFRvUmVtb3ZlQ2hhbmdlIiwiaXNOb2RlIiwiaXNFZGdlIiwiZml4ZWRGb3J3YXJkUmVmIiwicmVuZGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZVF1ZXVlIiwicnVuUXVldWUiLCJzaG91bGRGbHVzaCIsInNldFNob3VsZEZsdXNoIiwicXVldWUiLCJjcmVhdGVRdWV1ZSIsInF1ZXVlSXRlbXMiLCJjYiIsIkJhdGNoQ29udGV4dCIsIkJhdGNoUHJvdmlkZXIiLCJub2RlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdE5vZGVzIiwib25Ob2Rlc0NoYW5nZSIsIm5leHQiLCJwYXlsb2FkIiwibm9kZVF1ZXVlIiwiZWRnZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHRFZGdlcyIsIm9uRWRnZXNDaGFuZ2UiLCJlZGdlUXVldWUiLCJ2YWx1ZSIsInVzZUJhdGNoQ29udGV4dCIsImJhdGNoQ29udGV4dCIsInNlbGVjdG9yJGsiLCJ1c2VSZWFjdEZsb3ciLCJ2aWV3cG9ydEhlbHBlciIsInZpZXdwb3J0SW5pdGlhbGl6ZWQiLCJnZW5lcmFsSGVscGVyIiwiZ2V0SW50ZXJuYWxOb2RlIiwiZ2V0Tm9kZVJlY3QiLCJub2RlVG9Vc2UiLCJwYXJlbnRJZCIsIm5vZGVXaXRoUG9zaXRpb24iLCJkYXRhIiwidXBkYXRlTm9kZSIsIm5vZGVVcGRhdGUiLCJyZXBsYWNlIiwicHJldk5vZGVzIiwidXBkYXRlRWRnZSIsImVkZ2VVcGRhdGUiLCJwcmV2RWRnZXMiLCJuZXh0RWRnZSIsImdldE5vZGVzIiwibiIsImdldE5vZGUiLCJnZXRFZGdlcyIsImUiLCJnZXRFZGdlIiwiYWRkTm9kZXMiLCJuZXdOb2RlcyIsImFkZEVkZ2VzIiwibmV3RWRnZXMiLCJ0b09iamVjdCIsImRlbGV0ZUVsZW1lbnRzIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbk5vZGVzRGVsZXRlIiwib25FZGdlc0RlbGV0ZSIsInRyaWdnZXJOb2RlQ2hhbmdlcyIsInRyaWdnZXJFZGdlQ2hhbmdlcyIsIm9uRGVsZXRlIiwib25CZWZvcmVEZWxldGUiLCJtYXRjaGluZ05vZGVzIiwibWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ05vZGVzIiwiZWRnZUNoYW5nZXMiLCJub2RlQ2hhbmdlcyIsImRlbGV0ZWROb2RlcyIsImRlbGV0ZWRFZGdlcyIsImdldEludGVyc2VjdGluZ05vZGVzIiwibm9kZU9yUmVjdCIsInBhcnRpYWxseSIsImlzUmVjdCIsIm5vZGVSZWN0IiwiaGFzTm9kZXNPcHRpb24iLCJpbnRlcm5hbE5vZGUiLCJwb3NpdGlvbkFic29sdXRlIiwiY3Vyck5vZGVSZWN0Iiwib3ZlcmxhcHBpbmdBcmVhIiwicGFydGlhbGx5VmlzaWJsZSIsImlzTm9kZUludGVyc2VjdGluZyIsImFyZWEiLCJ1cGRhdGVOb2RlRGF0YSIsImRhdGFVcGRhdGUiLCJuZXh0RGF0YSIsInVwZGF0ZUVkZ2VEYXRhIiwiZ2V0SGFuZGxlQ29ubmVjdGlvbnMiLCJub2RlSWQiLCJmcm9tIiwiY29ubmVjdGlvbkxvb2t1cCIsInZhbHVlcyIsImRlbGV0ZUtleU9wdGlvbnMiLCJ3aW4kMSIsInVzZUdsb2JhbEtleUhhbmRsZXIiLCJkZWxldGVLZXlDb2RlIiwibXVsdGlTZWxlY3Rpb25LZXlDb2RlIiwiZGVsZXRlS2V5UHJlc3NlZCIsIm11bHRpU2VsZWN0aW9uS2V5UHJlc3NlZCIsIm5vZGVzU2VsZWN0aW9uQWN0aXZlIiwibXVsdGlTZWxlY3Rpb25BY3RpdmUiLCJ1c2VSZXNpemVIYW5kbGVyIiwidXBkYXRlRGltZW5zaW9ucyIsIm9uRXJyb3IiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImNvbnRhaW5lclN0eWxlIiwidG9wIiwibGVmdCIsInNlbGVjdG9yJGoiLCJsaWIiLCJab29tUGFuZSIsIm9uUGFuZUNvbnRleHRNZW51Iiwiem9vbU9uU2Nyb2xsIiwiem9vbU9uUGluY2giLCJwYW5PblNjcm9sbCIsInBhbk9uU2Nyb2xsU3BlZWQiLCJwYW5PblNjcm9sbE1vZGUiLCJGcmVlIiwiem9vbU9uRG91YmxlQ2xpY2siLCJwYW5PbkRyYWciLCJ6b29tQWN0aXZhdGlvbktleUNvZGUiLCJwcmV2ZW50U2Nyb2xsaW5nIiwibm9XaGVlbENsYXNzTmFtZSIsIm9uVmlld3BvcnRDaGFuZ2UiLCJpc0NvbnRyb2xsZWRWaWV3cG9ydCIsInpvb21QYW5lIiwiem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkIiwib25UcmFuc2Zvcm1DaGFuZ2UiLCJvbkRyYWdnaW5nQ2hhbmdlIiwicGFuZURyYWdnaW5nIiwib25QYW5ab29tU3RhcnQiLCJ2cCIsIm9uVmlld3BvcnRDaGFuZ2VTdGFydCIsIm9uTW92ZVN0YXJ0Iiwib25QYW5ab29tIiwib25Nb3ZlIiwib25QYW5ab29tRW5kIiwib25WaWV3cG9ydENoYW5nZUVuZCIsIm9uTW92ZUVuZCIsImNsb3Nlc3QiLCJkZXN0cm95IiwidXBkYXRlIiwicmVmIiwic2VsZWN0b3IkaSIsInVzZXJTZWxlY3Rpb25SZWN0IiwiVXNlclNlbGVjdGlvbiIsImlzQWN0aXZlIiwid3JhcEhhbmRsZXIiLCJoYW5kbGVyIiwiY29udGFpbmVyUmVmIiwic2VsZWN0b3IkaCIsIlBhbmUiLCJpc1NlbGVjdGluZyIsInNlbGVjdGlvbktleVByZXNzZWQiLCJzZWxlY3Rpb25Nb2RlIiwiRnVsbCIsInNlbGVjdGlvbk9uRHJhZyIsIm9uU2VsZWN0aW9uU3RhcnQiLCJvblNlbGVjdGlvbkVuZCIsIm9uUGFuZUNsaWNrIiwib25QYW5lU2Nyb2xsIiwib25QYW5lTW91c2VFbnRlciIsIm9uUGFuZU1vdXNlTW92ZSIsIm9uUGFuZU1vdXNlTGVhdmUiLCJjb250YWluZXIiLCJwcmV2U2VsZWN0ZWROb2Rlc0NvdW50IiwicHJldlNlbGVjdGVkRWRnZXNDb3VudCIsImNvbnRhaW5lckJvdW5kcyIsImVkZ2VJZExvb2t1cCIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwicmVzZXRVc2VyU2VsZWN0aW9uIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwic291cmNlIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsIlBhcnRpYWwiLCJzZWxlY3RlZEVkZ2VJZHMiLCJzZWxlY3RlZE5vZGVJZHMiLCJzZWxlY3RlZE5vZGUiLCJlZGdlSWRzIiwiZWRnZUlkIiwib25Qb2ludGVyVXAiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJkcmFnZ2FibGUiLCJzZWxlY3Rpb24iLCJvblBvaW50ZXJFbnRlciIsIm9uUG9pbnRlckxlYXZlIiwiaGFuZGxlTm9kZUNsaWNrIiwidW5zZWxlY3QiLCJub2RlUmVmIiwiYWRkU2VsZWN0ZWROb2RlcyIsInVuc2VsZWN0Tm9kZXNBbmRFZGdlcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJsdXIiLCJ1c2VEcmFnIiwiZGlzYWJsZWQiLCJub0RyYWdDbGFzc05hbWUiLCJoYW5kbGVTZWxlY3RvciIsImlzU2VsZWN0YWJsZSIsIm5vZGVDbGlja0Rpc3RhbmNlIiwic2V0RHJhZ2dpbmciLCJ4eURyYWciLCJnZXRTdG9yZUl0ZW1zIiwib25Ob2RlTW91c2VEb3duIiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdG9wIiwic2VsZWN0ZWRBbmREcmFnZ2FibGUiLCJub2Rlc0RyYWdnYWJsZSIsInVzZU1vdmVTZWxlY3RlZE5vZGVzIiwibW92ZVNlbGVjdGVkTm9kZXMiLCJub2RlRXh0ZW50IiwidXBkYXRlTm9kZVBvc2l0aW9ucyIsIm5vZGVVcGRhdGVzIiwiaXNTZWxlY3RlZCIsInhWZWxvIiwieVZlbG8iLCJ4RGlmZiIsImRpcmVjdGlvbiIsImZhY3RvciIsInlEaWZmIiwibmV4dFBvc2l0aW9uIiwiTm9kZUlkQ29udGV4dCIsIkNvbnN1bWVyIiwidXNlTm9kZUlkIiwic2VsZWN0b3IkZyIsImNvbm5lY3RPbkNsaWNrIiwiY29ubmVjdGluZ1NlbGVjdG9yIiwiaGFuZGxlSWQiLCJzdGF0ZSIsImNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlIiwiY2xpY2tIYW5kbGUiLCJjb25uZWN0aW9uTW9kZSIsImNvbm5lY3Rpb24iLCJmcm9tSGFuZGxlIiwidG9IYW5kbGUiLCJpc1ZhbGlkIiwiY29ubmVjdGluZ1RvIiwiY29ubmVjdGluZ0Zyb20iLCJjbGlja0Nvbm5lY3RpbmciLCJpc1Bvc3NpYmxlRW5kSGFuZGxlIiwiU3RyaWN0IiwiY29ubmVjdGlvbkluUHJvY2VzcyIsInZhbGlkIiwiSGFuZGxlQ29tcG9uZW50IiwiVG9wIiwiaXNWYWxpZENvbm5lY3Rpb24iLCJpc0Nvbm5lY3RhYmxlIiwiaXNDb25uZWN0YWJsZVN0YXJ0IiwiaXNDb25uZWN0YWJsZUVuZCIsIm9uQ29ubmVjdCIsIm9uTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0IiwiaXNUYXJnZXQiLCJvbkNvbm5lY3RFeHRlbmRlZCIsImRlZmF1bHRFZGdlT3B0aW9ucyIsIm9uQ29ubmVjdEFjdGlvbiIsImVkZ2VQYXJhbXMiLCJpc01vdXNlVHJpZ2dlcmVkIiwiY3VycmVudFN0b3JlIiwiYXV0b1Bhbk9uQ29ubmVjdCIsImNvbm5lY3Rpb25SYWRpdXMiLCJmbG93SWQiLCJjYW5jZWxDb25uZWN0aW9uIiwib25Db25uZWN0U3RhcnQiLCJvbkNvbm5lY3RFbmQiLCJ1cGRhdGVDb25uZWN0aW9uIiwiZ2V0VHJhbnNmb3JtIiwiZ2V0RnJvbUhhbmRsZSIsImF1dG9QYW5TcGVlZCIsIm9uQ2xpY2tDb25uZWN0U3RhcnQiLCJvbkNsaWNrQ29ubmVjdEVuZCIsImlzVmFsaWRDb25uZWN0aW9uU3RvcmUiLCJjb25uZWN0aW9uU3RhdGUiLCJoYW5kbGVUeXBlIiwiZG9jIiwiaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyIiwiaGFuZGxlIiwiZnJvbU5vZGVJZCIsImZyb21IYW5kbGVJZCIsImZyb21UeXBlIiwiY29ubmVjdGlvbkNsb25lIiwic3RydWN0dXJlZENsb25lIiwiaW5Qcm9ncmVzcyIsInRvUG9zaXRpb24iLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJkaXNwbGF5TmFtZSIsIkZsb3dSZW5kZXJlciIsInNlbGVjdG9yJGQiLCJvbmx5UmVuZGVyVmlzaWJsZSIsInVzZVZpc2libGVOb2RlSWRzIiwibm9kZUlkcyIsInNlbGVjdG9yJGMiLCJ1c2VSZXNpemVPYnNlcnZlciIsInVwZGF0ZXMiLCJlbnRyeSIsImdldEF0dHJpYnV0ZSIsIm5vZGVFbGVtZW50IiwiZm9yY2UiLCJkaXNjb25uZWN0IiwidXNlTm9kZU9ic2VydmVyIiwibm9kZVR5cGUiLCJoYXNEaW1lbnNpb25zIiwib2JzZXJ2ZWROb2RlIiwicHJldlNvdXJjZVBvc2l0aW9uIiwicHJldlRhcmdldFBvc2l0aW9uIiwicHJldlR5cGUiLCJpc0luaXRpYWxpemVkIiwiaGlkZGVuIiwidHlwZUNoYW5nZWQiLCJzb3VyY2VQb3NDaGFuZ2VkIiwidGFyZ2V0UG9zQ2hhbmdlZCIsIk5vZGVXcmFwcGVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwibm9kZXNDb25uZWN0YWJsZSIsIm5vZGVzRm9jdXNhYmxlIiwibm9kZVR5cGVzIiwiaXNQYXJlbnQiLCJwYXJlbnRMb29rdXAiLCJOb2RlQ29tcG9uZW50IiwiaXNEcmFnZ2FibGUiLCJzZWxlY3RhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhTGFiZWwiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwidmlzaWJsZUVkZ2VJZHMiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIkFycm93U3ltYm9sIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsImZpbGwiLCJwb2ludHMiLCJBcnJvd0Nsb3NlZFN5bWJvbCIsIk1hcmtlclN5bWJvbHMiLCJBcnJvdyIsIkFycm93Q2xvc2VkIiwidXNlTWFya2VyU3ltYm9sIiwic3ltYm9sIiwic3ltYm9sRXhpc3RzIiwiTWFya2VyIiwibWFya2VyVW5pdHMiLCJvcmllbnQiLCJTeW1ib2wiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInZpZXdCb3giLCJyZWZYIiwicmVmWSIsIk1hcmtlckRlZmluaXRpb25zIiwiZGVmYXVsdENvbG9yIiwibWFya2VycyIsImRlZmF1bHRNYXJrZXJTdGFydCIsIm1hcmtlclN0YXJ0IiwiZGVmYXVsdE1hcmtlckVuZCIsIm1hcmtlckVuZCIsIm1hcmtlciIsIk1hcmtlckRlZmluaXRpb25zJDEiLCJFZGdlVGV4dENvbXBvbmVudCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VUZXh0QmJveCIsInNldEVkZ2VUZXh0QmJveCIsImVkZ2VUZXh0Q2xhc3NlcyIsImVkZ2VUZXh0UmVmIiwidGV4dEJib3giLCJnZXRCQm94IiwicngiLCJyeSIsImR5IiwiRWRnZVRleHQiLCJCYXNlRWRnZSIsInBhdGgiLCJsYWJlbFgiLCJsYWJlbFkiLCJpbnRlcmFjdGlvbldpZHRoIiwiZCIsInN0cm9rZU9wYWNpdHkiLCJnZXRDb250cm9sIiwicG9zIiwieDEiLCJ5MSIsIngyIiwieTIiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInNvdXJjZUNvbnRyb2xYIiwic291cmNlQ29udHJvbFkiLCJ0YXJnZXRDb250cm9sWCIsInRhcmdldENvbnRyb2xZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjcmVhdGVTaW1wbGVCZXppZXJFZGdlIiwiX2lkIiwiaXNJbnRlcm5hbCIsIlNpbXBsZUJlemllckVkZ2UiLCJTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwiLCJjcmVhdGVTbW9vdGhTdGVwRWRnZSIsInBhdGhPcHRpb25zIiwiYm9yZGVyUmFkaXVzIiwib2Zmc2V0IiwiU21vb3RoU3RlcEVkZ2UiLCJTbW9vdGhTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RlcEVkZ2UiLCJTdGVwRWRnZSIsIlN0ZXBFZGdlSW50ZXJuYWwiLCJjcmVhdGVTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2VJbnRlcm5hbCIsImNyZWF0ZUJlemllckVkZ2UiLCJjdXJ2YXR1cmUiLCJCZXppZXJFZGdlIiwiQmV6aWVyRWRnZUludGVybmFsIiwiYnVpbHRpbkVkZ2VUeXBlcyIsInN0cmFpZ2h0Iiwic3RlcCIsInNtb290aHN0ZXAiLCJzaW1wbGViZXppZXIiLCJudWxsUG9zaXRpb24iLCJzaGlmdFgiLCJzaGlmdCIsInNoaWZ0WSIsIkVkZ2VVcGRhdGVyQ2xhc3NOYW1lIiwiRWRnZUFuY2hvciIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsImVsZXZhdGVOb2Rlc09uU2VsZWN0IiwiZml0Vmlld0RvbmUiLCJhdXRvUGFuT25Ob2RlRHJhZyIsImRlYnVnIiwiY3JlYXRlU3RvcmUiLCJmaXRWaWV3JDEiLCJjaGVja0VxdWFsaXR5IiwidHJpZ2dlckZpdFZpZXciLCJmaXRWaWV3U3luYyIsInVwZGF0ZWRJbnRlcm5hbHMiLCJuZXh0Rml0Vmlld0RvbmUiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJyZWN0IiwibWF4IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwiaXMiLCJSZWFjdEZsb3dQcm92aWRlciIsImluaXRpYWxOb2RlcyIsImluaXRpYWxFZGdlcyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImZpdFZpZXdPcHRpb25zIiwiYXR0cmlidXRpb25Qb3NpdGlvbiIsImNvbG9yTW9kZUNsYXNzTmFtZSIsInNlbGVjdG9yJDYiLCJFZGdlTGFiZWxSZW5kZXJlciIsImVkZ2VMYWJlbFJlbmRlcmVyIiwic2VsZWN0b3IkNSIsIlZpZXdwb3J0UG9ydGFsIiwidmlld1BvcnRhbERpdiIsInVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVJZHMiLCJ1cGRhdGVJZCIsIm5vZGVzU2VsZWN0b3IiLCJ1c2VOb2RlcyIsImVkZ2VzU2VsZWN0b3IiLCJ1c2VFZGdlcyIsInZpZXdwb3J0U2VsZWN0b3IiLCJ1c2VWaWV3cG9ydCIsInVzZU5vZGVzU3RhdGUiLCJuZHMiLCJ1c2VFZGdlc1N0YXRlIiwiZWRzIiwidXNlT25WaWV3cG9ydENoYW5nZSIsIm9uU3RhcnQiLCJvbkNoYW5nZSIsIm9uRW5kIiwidXNlT25TZWxlY3Rpb25DaGFuZ2UiLCJuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsIm5leHRIYW5kbGVycyIsInNlbGVjdG9yJDQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJkZWZhdWx0T3B0aW9ucyIsInVzZU5vZGVzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplZCIsInVzZUhhbmRsZUNvbm5lY3Rpb25zIiwib25EaXNjb25uZWN0IiwiX25vZGVJZCIsImN1cnJlbnROb2RlSWQiLCJwcmV2Q29ubmVjdGlvbnMiLCJjb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsInVzZU5vZGVzRGF0YSIsIm5vZGVzRGF0YSIsImlzQXJyYXlPZklkcyIsIl9ub2RlSWRzIiwidXNlSW50ZXJuYWxOb2RlIiwiTGluZVBhdHRlcm4iLCJsaW5lV2lkdGgiLCJ2YXJpYW50IiwiRG90UGF0dGVybiIsIkJhY2tncm91bmRWYXJpYW50IiwiZGVmYXVsdFNpemUiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsInNlbGVjdG9yJDMiLCJwYXR0ZXJuSWQiLCJCYWNrZ3JvdW5kQ29tcG9uZW50IiwiZ2FwIiwiYmdDb2xvciIsInBhdHRlcm5DbGFzc05hbWUiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJvZmZzZXRYWSIsInBhdHRlcm5EaW1lbnNpb25zIiwic2NhbGVkT2Zmc2V0IiwiX3BhdHRlcm5JZCIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJCYWNrZ3JvdW5kIiwiUGx1c0ljb24iLCJ4bWxucyIsIk1pbnVzSWNvbiIsIkZpdFZpZXdJY29uIiwiTG9ja0ljb24iLCJVbmxvY2tJY29uIiwiQ29udHJvbEJ1dHRvbiIsInNlbGVjdG9yJDIiLCJpc0ludGVyYWN0aXZlIiwibWluWm9vbVJlYWNoZWQiLCJtYXhab29tUmVhY2hlZCIsIkNvbnRyb2xzQ29tcG9uZW50Iiwic2hvd1pvb20iLCJzaG93Rml0VmlldyIsInNob3dJbnRlcmFjdGl2ZSIsIm9uWm9vbUluIiwib25ab29tT3V0Iiwib25GaXRWaWV3Iiwib25JbnRlcmFjdGl2ZUNoYW5nZSIsIm9yaWVudGF0aW9uIiwib25ab29tSW5IYW5kbGVyIiwib25ab29tT3V0SGFuZGxlciIsIm9uRml0Vmlld0hhbmRsZXIiLCJvblRvZ2dsZUludGVyYWN0aXZpdHkiLCJvcmllbnRhdGlvbkNsYXNzIiwidGl0bGUiLCJDb250cm9scyIsIk1pbmlNYXBOb2RlQ29tcG9uZW50Iiwic3Ryb2tlQ29sb3IiLCJzaGFwZVJlbmRlcmluZyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNaW5pTWFwTm9kZSIsInNlbGVjdG9yTm9kZUlkcyIsImdldEF0dHJGdW5jdGlvbiIsImZ1bmMiLCJGdW5jdGlvbiIsIk1pbmlNYXBOb2RlcyIsIm5vZGVTdHJva2VDb2xvciIsIm5vZGVDb2xvciIsIm5vZGVDbGFzc05hbWUiLCJub2RlQm9yZGVyUmFkaXVzIiwibm9kZVN0cm9rZVdpZHRoIiwibm9kZUNvbXBvbmVudCIsIm5vZGVDb2xvckZ1bmMiLCJub2RlU3Ryb2tlQ29sb3JGdW5jIiwibm9kZUNsYXNzTmFtZUZ1bmMiLCJjaHJvbWUiLCJOb2RlQ29tcG9uZW50V3JhcHBlciIsIk5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIiLCJNaW5pTWFwTm9kZXMkMSIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJzZWxlY3RvciQxIiwidmlld0JCIiwiYm91bmRpbmdSZWN0IiwiZmxvd1dpZHRoIiwiZmxvd0hlaWdodCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcENvbXBvbmVudCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbVN0ZXAiLCJvZmZzZXRTY2FsZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJsYWJlbGxlZEJ5Iiwidmlld1NjYWxlUmVmIiwibWluaW1hcEluc3RhbmNlIiwiZ2V0Vmlld1NjYWxlIiwib25TdmdDbGljayIsInBvaW50ZXIiLCJvblN2Z05vZGVDbGljayIsImZpbGxSdWxlIiwiTWluaU1hcCIsIlJlc2l6ZUNvbnRyb2wiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4SGVpZ2h0Iiwia2VlcEFzcGVjdFJhdGlvIiwic2hvdWxkUmVzaXplIiwib25SZXNpemVTdGFydCIsIm9uUmVzaXplIiwib25SZXNpemVFbmQiLCJjb250ZXh0Tm9kZUlkIiwicmVzaXplQ29udHJvbFJlZiIsImRlZmF1bHRQb3NpdGlvbiIsIkxpbmUiLCJjb250cm9sUG9zaXRpb24iLCJyZXNpemVyIiwiY2hpbGRDaGFuZ2VzIiwib3JpZ2luIiwiY2hpbGQiLCJwb3NpdGlvbkNoYW5nZSIsImRpbWVuc2lvbkNoYW5nZSIsImNoaWxkQ2hhbmdlIiwiYm91bmRhcmllcyIsInBvc2l0aW9uQ2xhc3NOYW1lcyIsImNvbG9yU3R5bGVQcm9wIiwiY29udHJvbFN0eWxlIiwiTm9kZVJlc2l6ZUNvbnRyb2wiLCJOb2RlUmVzaXplciIsImlzVmlzaWJsZSIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZVN0eWxlIiwibGluZUNsYXNzTmFtZSIsImxpbmVTdHlsZSIsIk5vZGVUb29sYmFyUG9ydGFsIiwid3JhcHBlclJlZiIsIm5vZGVFcXVhbGl0eUZuIiwibm9kZXNFcXVhbGl0eUZuIiwic3RvcmVTZWxlY3RvciIsInNlbGVjdGVkTm9kZXNDb3VudCIsIk5vZGVUb29sYmFyIiwiYWxpZ24iLCJpbnRlcm5hbE5vZGVzIiwibm9kZXNBcnJheSIsImFjYyIsInRyaW0iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitView: () => (/* binding */ fitView),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getFitViewNodes: () => (/* binding */ getFitViewNodes),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\n\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is useable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is useable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * Pass in a node, and get connected nodes where edge.source === node.id\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the source is the given node\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * Pass in a node, and get connected nodes where edge.target === node.id\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the target is the given node\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Internal function for determining a bounding box that contains all given nodes in an array.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for\n * @param params.nodeOrigin - Origin of the nodes: [0, 0] - top left, [0.5, 0.5] - center\n * @returns Bounding box enclosing all nodes\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0], nodeLookup: undefined }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * Get all connecting edges for a given set of nodes\n * @param nodes - Nodes you want to get the connected edges for\n * @param edges - All edges\n * @returns Array of edges that connect any of the given nodes with each other\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitView({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(false);\n    }\n    const bounds = getInternalNodesBounds(nodes);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, { duration: options?.duration });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + node.measured.width * origin[0],\n            y: positionAbsolute.y - parentY + node.measured.height * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Returns a viewport that encloses the given bounds with optional padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport\n * @param width - Width of the viewport\n * @param height  - Height of the viewport\n * @param minZoom - Minimum zoom level of the resulting viewport\n * @param maxZoom - Maximum zoom level of the resulting viewport\n * @param padding - Optional padding around the bounds\n * @returns A transforned {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n  { x: 0, y: 0, width: 100, height: 100},\n  1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return { x, y, zoom: clampedZoom };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    let nextParentId = parentId;\n    const positionAbsolute = { ...position };\n    while (nextParentId) {\n        const parent = nodeLookup.get(nextParentId);\n        nextParentId = parent?.parentId;\n        if (parent) {\n            const origin = parent.origin || nodeOrigin;\n            positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n            positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n        }\n    }\n    return positionAbsolute;\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x, y }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    const isInput = inputTags.includes(target?.nodeName) || target?.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target?.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n// The handle bounds are calculated relative to the node element.\n// We store them in the internals object of the node in order to avoid\n// unnecessary recalculations.\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * Get a bezier path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @param params.curvature - The curvature of the bezier edge\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n});\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, }) {\n    if (!elevateOnSelect) {\n        return zIndex;\n    }\n    const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;\n    const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1000);\n    return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges\n * @remarks It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an Edge or a Connection you want to add\n * @param edges -  The array of all current edges\n * @returns A new array of edges with the new edge added\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to reconnect an existing edge with new properties\n * @param oldEdge - The edge you want to update\n * @param newConnection - The new connection you want to update the edge with\n * @param edges - The array of all current edges\n * @param options.shouldReplaceId - should the id of the old edge be replaced with the new connection id\n * @returns the updated edges array\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Get a straight path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n    });\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n// ith this function we try to mimic a orthogonal edge routing behaviour\n// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x ?? defaultCenterX;\n        centerY = center.y ?? defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * Get a smooth step path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n    });\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    // position === Position.Top\n    // we set the x any y position of the toolbar based on the nodes position\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        node.internals = {\n            ...node.internals,\n            positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n            z,\n        };\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ > childZ ? parentZ : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                // We move all child nodes in the oppsite direction\n                // so the x,y changes of the parent do not move the children\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            node.internals = {\n                ...node.internals,\n                handleBounds: undefined,\n            };\n            updatedInternals = true;\n        }\n        else {\n            const dimensions = getDimensions(update.nodeElement);\n            const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n            const doUpdate = !!(dimensions.width &&\n                dimensions.height &&\n                (dimensionChanged || !node.internals.handleBounds || update.force));\n            if (doUpdate) {\n                const nodeBounds = update.nodeElement.getBoundingClientRect();\n                const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n                let { positionAbsolute } = node.internals;\n                if (node.parentId && node.extent === 'parent') {\n                    positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n                }\n                else if (extent) {\n                    positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n                }\n                node.measured = dimensions;\n                node.internals = {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                };\n                if (node.parentId) {\n                    updateChildNode(node, nodeLookup, parentLookup, { nodeOrigin });\n                }\n                updatedInternals = true;\n                if (dimensionChanged) {\n                    changes.push({\n                        id: node.id,\n                        type: 'dimensions',\n                        dimensions,\n                    });\n                    if (node.expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id: node.id,\n                            parentId: node.parentId,\n                            rect: nodeToRect(node, nodeOrigin),\n                        });\n                    }\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source, target, sourceHandle = null, targetHandle = null } = edge;\n        const sourceKey = `${source}-source-${sourceHandle}`;\n        const targetKey = `${target}-target-${targetHandle}`;\n        const prevSource = connectionLookup.get(sourceKey) || new Map();\n        const prevTarget = connectionLookup.get(targetKey) || new Map();\n        const connection = { edgeId: edge.id, source, target, sourceHandle, targetHandle };\n        edgeLookup.set(edge.id, edge);\n        connectionLookup.set(sourceKey, prevSource.set(`${target}-${targetHandle}`, connection));\n        connectionLookup.set(targetKey, prevTarget.set(`${source}-${sourceHandle}`, connection));\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n// returns two params:\n// 1. the dragged node (or the first of the list, if we are dragging a node selection)\n// 2. array of selected nodes (for multi selections)\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }, dragEvent) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };\n            if (dragItems.size > 1 && nodeExtent) {\n                const rect = getInternalNodesBounds(dragItems);\n                nodesBox = rectToBox(rect);\n            }\n            for (const [id, dragItem] of dragItems) {\n                if (!nodeLookup.has(id)) {\n                    // if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                    // and we don't need to update it anymore\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = snapPosition(nextPosition, snapGrid);\n                }\n                // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                // based on its position so that the node stays at it's position relative to the selection.\n                let adjustedNodeExtent = [\n                    [nodeExtent[0][0], nodeExtent[0][1]],\n                    [nodeExtent[1][0], nodeExtent[1][1]],\n                ];\n                if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed } = getStoreItems();\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos, null);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            abortDrag = false;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid });\n            lastPos = pointerPos;\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid });\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                // dragEvent = event.sourceEvent as MouseEvent;\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos, event.sourceEvent);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                updateNodePositions(dragItems, false);\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n// this distance is used for the area around the user pointer\n// while doing a connection for finding the closest nodes\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    const newConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    updateConnection(newConnection);\n    let previousConnection = newConnection;\n    onConnectStart?.(event, { nodeId, handleId, handleType });\n    function onPointerMove(event) {\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        handleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: closestHandle && isValid\n                ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        // we don't want to trigger an update when the connection\n        // is snapped to the same handle as before\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        // it's important to get a fresh reference from the store here\n        // in order to get the latest state of onConnectEnd\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { inProgress, ...connectionState } = previousConnection;\n        const finalConnectionState = {\n            ...connectionState,\n            toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n        };\n        onConnectEnd?.(event, finalConnectionState);\n        if (edgeUpdaterType) {\n            onReconnectEnd?.(event, finalConnectionState);\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, false);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            const transform = getTransform();\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst getD3Transition = (selection, duration = 0, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        // increase scroll speed in firefox\n        // firefox: deltaMode === 1; chrome: deltaMode === 0\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        // for pan on scroll we need to handle the event calls on our own\n        // we can't use the start, zoom and end events from d3-zoom\n        // because start and move gets called on every scroll event and not once at the beginning\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && event.type === 'wheel' && !event.ctrlKey;\n        if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.transform(getD3Transition(d3Selection, options?.duration, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        // We cannot add zoomOnDoubleClick to the filter above because\n        // double tapping on touch screens circumvents the filter and\n        // dblclick.zoom is fired on the selection directly\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleTo(getD3Transition(d3Selection, options?.duration, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleBy(getD3Transition(d3Selection, options?.duration, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            // Collect all child nodes to correct their relative positions when top/left changes\n            // Determine largest minimal extent the parent node is allowed to resize to\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                // when top/left changes, correct the relative positions of child nodes\n                // so that they stay in the same position\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width = isWidthChange ? width : prevValues.width;\n                change.height = isHeightChange ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.();\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNnQjtBQUNhOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRCx3Q0FBd0MsS0FBSztBQUM3Qyw2QkFBNkIsZ0NBQWdDLGlDQUFpQyxZQUFZLGNBQWMsc0RBQXNELGNBQWMsR0FBRztBQUMvTDtBQUNBLDBDQUEwQyxTQUFTO0FBQ25ELHVDQUF1QyxHQUFHO0FBQzFDLHdHQUF3RyxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLCtEQUErRDtBQUNuRiw0RUFBNEUsaUNBQWlDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTY4QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxydXNsYVxcT25lRHJpdmVcXNCg0LDQsdC+0YfQuNC5INGB0YLQvtC7XFxnaXR2ZXJzZS1jaWNkXFxnaXR2ZXJzZS1jbGllbnRcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xcc3lzdGVtXFxkaXN0XFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRyYWcgfSBmcm9tICdkMy1kcmFnJztcbmltcG9ydCB7IHNlbGVjdCwgcG9pbnRlciB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyB6b29tLCB6b29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gfSBmcm9tICdkMy16b29tJztcblxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBlcnJvcjAwMTogKCkgPT4gJ1tSZWFjdCBGbG93XTogU2VlbXMgbGlrZSB5b3UgaGF2ZSBub3QgdXNlZCB6dXN0YW5kIHByb3ZpZGVyIGFzIGFuIGFuY2VzdG9yLiBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjMDAxJyxcbiAgICBlcnJvcjAwMjogKCkgPT4gXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBjcmVhdGVkIGEgbmV3IG5vZGVUeXBlcyBvciBlZGdlVHlwZXMgb2JqZWN0LiBJZiB0aGlzIHdhc24ndCBvbiBwdXJwb3NlIHBsZWFzZSBkZWZpbmUgdGhlIG5vZGVUeXBlcy9lZGdlVHlwZXMgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IG9yIG1lbW9pemUgdGhlbS5cIixcbiAgICBlcnJvcjAwMzogKG5vZGVUeXBlKSA9PiBgTm9kZSB0eXBlIFwiJHtub2RlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAwNDogKCkgPT4gJ1RoZSBSZWFjdCBGbG93IHBhcmVudCBjb250YWluZXIgbmVlZHMgYSB3aWR0aCBhbmQgYSBoZWlnaHQgdG8gcmVuZGVyIHRoZSBncmFwaC4nLFxuICAgIGVycm9yMDA1OiAoKSA9PiAnT25seSBjaGlsZCBub2RlcyBjYW4gdXNlIGEgcGFyZW50IGV4dGVudC4nLFxuICAgIGVycm9yMDA2OiAoKSA9PiBcIkNhbid0IGNyZWF0ZSBlZGdlLiBBbiBlZGdlIG5lZWRzIGEgc291cmNlIGFuZCBhIHRhcmdldC5cIixcbiAgICBlcnJvcjAwNzogKGlkKSA9PiBgVGhlIG9sZCBlZGdlIHdpdGggaWQ9JHtpZH0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwOTogKHR5cGUpID0+IGBNYXJrZXIgdHlwZSBcIiR7dHlwZX1cIiBkb2Vzbid0IGV4aXN0LmAsXG4gICAgZXJyb3IwMDg6IChoYW5kbGVUeXBlLCB7IGlkLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9KSA9PiBgQ291bGRuJ3QgY3JlYXRlIGVkZ2UgZm9yICR7aGFuZGxlVHlwZX0gaGFuZGxlIGlkOiBcIiR7aGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyBzb3VyY2VIYW5kbGUgOiB0YXJnZXRIYW5kbGV9XCIsIGVkZ2UgaWQ6ICR7aWR9LmAsXG4gICAgZXJyb3IwMTA6ICgpID0+ICdIYW5kbGU6IE5vIG5vZGUgaWQgZm91bmQuIE1ha2Ugc3VyZSB0byBvbmx5IHVzZSBhIEhhbmRsZSBpbnNpZGUgYSBjdXN0b20gTm9kZS4nLFxuICAgIGVycm9yMDExOiAoZWRnZVR5cGUpID0+IGBFZGdlIHR5cGUgXCIke2VkZ2VUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDEyOiAoaWQpID0+IGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0LCBpdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBpcyBkZWxldGVkIGJlZm9yZSB0aGUgXCJvbk5vZGVDbGlja1wiIGhhbmRsZXIgaXMgY2FsbGVkLmAsXG4gICAgZXJyb3IwMTM6IChsaWIgPSAncmVhY3QnKSA9PiBgSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW4ndCBsb2FkZWQgdGhlIHN0eWxlcy4gUGxlYXNlIGltcG9ydCAnQHh5Zmxvdy8ke2xpYn0vZGlzdC9zdHlsZS5jc3MnIG9yIGJhc2UuY3NzIHRvIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHdvcmtpbmcgcHJvcGVybHkuYCxcbn07XG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgZWxlbWVudFNlbGVjdGlvbktleXMgPSBbJ0VudGVyJywgJyAnLCAnRXNjYXBlJ107XG5cbnZhciBDb25uZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk1vZGUpIHtcbiAgICBDb25uZWN0aW9uTW9kZVtcIlN0cmljdFwiXSA9IFwic3RyaWN0XCI7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJMb29zZVwiXSA9IFwibG9vc2VcIjtcbn0pKENvbm5lY3Rpb25Nb2RlIHx8IChDb25uZWN0aW9uTW9kZSA9IHt9KSk7XG52YXIgUGFuT25TY3JvbGxNb2RlO1xuKGZ1bmN0aW9uIChQYW5PblNjcm9sbE1vZGUpIHtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJGcmVlXCJdID0gXCJmcmVlXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoUGFuT25TY3JvbGxNb2RlIHx8IChQYW5PblNjcm9sbE1vZGUgPSB7fSkpO1xudmFyIFNlbGVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiUGFydGlhbFwiXSA9IFwicGFydGlhbFwiO1xuICAgIFNlbGVjdGlvbk1vZGVbXCJGdWxsXCJdID0gXCJmdWxsXCI7XG59KShTZWxlY3Rpb25Nb2RlIHx8IChTZWxlY3Rpb25Nb2RlID0ge30pKTtcbmNvbnN0IGluaXRpYWxDb25uZWN0aW9uID0ge1xuICAgIGluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgZnJvbTogbnVsbCxcbiAgICBmcm9tSGFuZGxlOiBudWxsLFxuICAgIGZyb21Qb3NpdGlvbjogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0bzogbnVsbCxcbiAgICB0b0hhbmRsZTogbnVsbCxcbiAgICB0b1Bvc2l0aW9uOiBudWxsLFxuICAgIHRvTm9kZTogbnVsbCxcbn07XG5cbnZhciBDb25uZWN0aW9uTGluZVR5cGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25MaW5lVHlwZSkge1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIkJlemllclwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0cmFpZ2h0XCJdID0gXCJzdHJhaWdodFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0ZXBcIl0gPSBcInN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTbW9vdGhTdGVwXCJdID0gXCJzbW9vdGhzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU2ltcGxlQmV6aWVyXCJdID0gXCJzaW1wbGViZXppZXJcIjtcbn0pKENvbm5lY3Rpb25MaW5lVHlwZSB8fCAoQ29ubmVjdGlvbkxpbmVUeXBlID0ge30pKTtcbnZhciBNYXJrZXJUeXBlO1xuKGZ1bmN0aW9uIChNYXJrZXJUeXBlKSB7XG4gICAgTWFya2VyVHlwZVtcIkFycm93XCJdID0gXCJhcnJvd1wiO1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd0Nsb3NlZFwiXSA9IFwiYXJyb3djbG9zZWRcIjtcbn0pKE1hcmtlclR5cGUgfHwgKE1hcmtlclR5cGUgPSB7fSkpO1xuXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgUG9zaXRpb25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgUG9zaXRpb25bXCJUb3BcIl0gPSBcInRvcFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwoYSwgYikge1xuICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhIHx8ICFiIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhLnNpemUgJiYgIWIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdlIGNhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgY29ubmVjdGlvbnMgaW4gYSB0aGF0IGFyZSBub3QgaW4gYlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKGEsIGIsIGNiKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBbXTtcbiAgICBhLmZvckVhY2goKGNvbm5lY3Rpb24sIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWI/LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaWZmLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgY2IoZGlmZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQgPT09IG51bGwgPyBudWxsIDogaXNWYWxpZCA/ICd2YWxpZCcgOiAnaW52YWxpZCc7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2VhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYSBOb2RlXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBOb2RlXG4gKi9cbmNvbnN0IGlzTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdwb3NpdGlvbicgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG5jb25zdCBpc0ludGVybmFsTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdpbnRlcm5hbHMnIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuLyoqXG4gKiBQYXNzIGluIGEgbm9kZSwgYW5kIGdldCBjb25uZWN0ZWQgbm9kZXMgd2hlcmUgZWRnZS5zb3VyY2UgPT09IG5vZGUuaWRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbVxuICogQHBhcmFtIG5vZGVzIC0gVGhlIGFycmF5IG9mIGFsbCBub2Rlc1xuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWdlcyB3aGVyZSB0aGUgc291cmNlIGlzIHRoZSBnaXZlbiBub2RlXG4gKi9cbmNvbnN0IGdldE91dGdvZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIG91dGdvZXJJZHMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IG91dGdvZXJJZHMuaGFzKG4uaWQpKTtcbn07XG4vKipcbiAqIFBhc3MgaW4gYSBub2RlLCBhbmQgZ2V0IGNvbm5lY3RlZCBub2RlcyB3aGVyZSBlZGdlLnRhcmdldCA9PT0gbm9kZS5pZFxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNvbm5lY3RlZCBub2RlcyBmcm9tXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgb3ZlciBlZ2VzIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGdpdmVuIG5vZGVcbiAqL1xuY29uc3QgZ2V0SW5jb21lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaW5jb21lcnNJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS50YXJnZXQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIGluY29tZXJzSWRzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChuKSA9PiBpbmNvbWVyc0lkcy5oYXMobi5pZCkpO1xufTtcbmNvbnN0IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4gPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBjb25zdCBvZmZzZXRYID0gd2lkdGggKiBvcmlnaW5bMF07XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGhlaWdodCAqIG9yaWdpblsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggLSBvZmZzZXRYLFxuICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgLSBvZmZzZXRZLFxuICAgIH07XG59O1xuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXkuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3JcbiAqIEBwYXJhbSBwYXJhbXMubm9kZU9yaWdpbiAtIE9yaWdpbiBvZiB0aGUgbm9kZXM6IFswLCAwXSAtIHRvcCBsZWZ0LCBbMC41LCAwLjVdIC0gY2VudGVyXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlc1xuICovXG5jb25zdCBnZXROb2Rlc0JvdW5kcyA9IChub2RlcywgcGFyYW1zID0geyBub2RlT3JpZ2luOiBbMCwgMF0sIG5vZGVMb29rdXA6IHVuZGVmaW5lZCB9KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgYGdldE5vZGVzQm91bmRzYCBmcm9tIGB1c2VSZWFjdEZsb3dgL2B1c2VTdmVsdGVGbG93YCBob29rIHRvIGVuc3VyZSBjb3JyZWN0IHZhbHVlcyBmb3Igc3ViIGZsb3dzLiBJZiBub3QgcG9zc2libGUsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYSBub2RlTG9va3VwIHRvIHN1cHBvcnQgc3ViIGZsb3dzLicpO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlT3JJZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0lkID0gdHlwZW9mIG5vZGVPcklkID09PSAnc3RyaW5nJztcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gIXBhcmFtcy5ub2RlTG9va3VwICYmICFpc0lkID8gbm9kZU9ySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBpc0lkXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgOiAhaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGVPcklkKVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZC5pZClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlT3JJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQm94ID0gY3VycmVudE5vZGUgPyBub2RlVG9Cb3goY3VycmVudE5vZGUsIHBhcmFtcy5ub2RlT3JpZ2luKSA6IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHNPZkJveGVzKGN1cnJCb3gsIG5vZGVCb3gpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vKipcbiAqIERldGVybWluZXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXlcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzID0gKG5vZGVMb29rdXAsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgaWYgKG5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGxldCBib3ggPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlVG9Cb3gobm9kZSk7XG4gICAgICAgICAgICBib3ggPSBnZXRCb3VuZHNPZkJveGVzKGJveCwgbm9kZUJveCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuY29uc3QgZ2V0Tm9kZXNJbnNpZGUgPSAobm9kZXMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIC4uLnBvaW50VG9SZW5kZXJlclBvaW50KHJlY3QsIFt0eCwgdHksIHRTY2FsZV0pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVkLCBzZWxlY3RhYmxlID0gdHJ1ZSwgaGlkZGVuID0gZmFsc2UgfSA9IG5vZGU7XG4gICAgICAgIGlmICgoZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyAmJiAhc2VsZWN0YWJsZSkgfHwgaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVkLndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbnVsbDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBudWxsO1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoID8/IDApICogKGhlaWdodCA/PyAwKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBmb3JjZUluaXRpYWxSZW5kZXIgPSAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBmb3JjZUluaXRpYWxSZW5kZXIgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZU5vZGVzO1xufTtcbi8qKlxuICogR2V0IGFsbCBjb25uZWN0aW5nIGVkZ2VzIGZvciBhIGdpdmVuIHNldCBvZiBub2Rlc1xuICogQHBhcmFtIG5vZGVzIC0gTm9kZXMgeW91IHdhbnQgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgZWRnZXMgZm9yXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXNcbiAqIEByZXR1cm5zIEFycmF5IG9mIGVkZ2VzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIGdpdmVuIG5vZGVzIHdpdGggZWFjaCBvdGhlclxuICovXG5jb25zdCBnZXRDb25uZWN0ZWRFZGdlcyA9IChub2RlcywgZWRnZXMpID0+IHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldCgpO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZUlkcy5hZGQobm9kZS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gbm9kZUlkcy5oYXMoZWRnZS5zb3VyY2UpIHx8IG5vZGVJZHMuaGFzKGVkZ2UudGFyZ2V0KSk7XG59O1xuZnVuY3Rpb24gZ2V0Rml0Vmlld05vZGVzKG5vZGVMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb3B0aW9uTm9kZUlkcyA9IG9wdGlvbnM/Lm5vZGVzID8gbmV3IFNldChvcHRpb25zLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpIDogbnVsbDtcbiAgICBub2RlTG9va3VwLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gbi5tZWFzdXJlZC53aWR0aCAmJiBuLm1lYXN1cmVkLmhlaWdodCAmJiAob3B0aW9ucz8uaW5jbHVkZUhpZGRlbk5vZGVzIHx8ICFuLmhpZGRlbik7XG4gICAgICAgIGlmIChpc1Zpc2libGUgJiYgKCFvcHRpb25Ob2RlSWRzIHx8IG9wdGlvbk5vZGVJZHMuaGFzKG4uaWQpKSkge1xuICAgICAgICAgICAgZml0Vmlld05vZGVzLnNldChuLmlkLCBuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaXRWaWV3Tm9kZXM7XG59XG5hc3luYyBmdW5jdGlvbiBmaXRWaWV3KHsgbm9kZXMsIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIG1pblpvb20sIG1heFpvb20gfSwgb3B0aW9ucykge1xuICAgIGlmIChub2Rlcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBib3VuZHMgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucz8ubWluWm9vbSA/PyBtaW5ab29tLCBvcHRpb25zPy5tYXhab29tID8/IG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIG5leHQgcG9zaXRpb24gb2YgYSBub2RlLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBub2RlJ3MgZXh0ZW50LCBwYXJlbnQgbm9kZSwgYW5kIG9yaWdpbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7IG5vZGVJZCwgbmV4dFBvc2l0aW9uLCBub2RlTG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdLCBub2RlRXh0ZW50LCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50SWQgPyBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIDogeyB4OiAwLCB5OiAwIH07XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBsZXQgZXh0ZW50ID0gbm9kZUV4dGVudDtcbiAgICBpZiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnICYmICFub2RlLmV4cGFuZFBhcmVudCkge1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3I/LignMDA1JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDUnXSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50Tm9kZS5tZWFzdXJlZC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudE5vZGUubWVhc3VyZWQuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHBhcmVudFdpZHRoICYmIHBhcmVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudE5vZGUgJiYgaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSkge1xuICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMF1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFswXVsxXSArIHBhcmVudFldLFxuICAgICAgICAgICAgW25vZGUuZXh0ZW50WzFdWzBdICsgcGFyZW50WCwgbm9kZS5leHRlbnRbMV1bMV0gKyBwYXJlbnRZXSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIGV4dGVudCwgbm9kZS5tZWFzdXJlZClcbiAgICAgICAgOiBuZXh0UG9zaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uQWJzb2x1dGUueCAtIHBhcmVudFggKyBub2RlLm1lYXN1cmVkLndpZHRoICogb3JpZ2luWzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55IC0gcGFyZW50WSArIG5vZGUubWVhc3VyZWQuaGVpZ2h0ICogb3JpZ2luWzFdLFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vKipcbiAqIFBhc3MgaW4gbm9kZXMgJiBlZGdlcyB0byBkZWxldGUsIGdldCBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzIHRoYXQgYWN0dWFsbHkgY2FuIGJlIGRlbGV0ZWRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhcmFtLm5vZGVzVG9SZW1vdmUgLSBUaGUgbm9kZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXNUb1JlbW92ZSAtIFRoZSBlZGdlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5ub2RlcyAtIEFsbCBub2Rlc1xuICogQHBhcmFtIHBhcmFtLmVkZ2VzIC0gQWxsIGVkZ2VzXG4gKiBAcGFyYW0gcGFyYW0ub25CZWZvcmVEZWxldGUgLSBDYWxsYmFjayB0byBjaGVjayB3aGljaCBub2RlcyBhbmQgZWRnZXMgY2FuIGJlIGRlbGV0ZWRcbiAqIEByZXR1cm5zIG5vZGVzOiBub2RlcyB0aGF0IGNhbiBiZSBkZWxldGVkLCBlZGdlczogZWRnZXMgdGhhdCBjYW4gYmUgZGVsZXRlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFbGVtZW50c1RvUmVtb3ZlKHsgbm9kZXNUb1JlbW92ZSA9IFtdLCBlZGdlc1RvUmVtb3ZlID0gW10sIG5vZGVzLCBlZGdlcywgb25CZWZvcmVEZWxldGUsIH0pIHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldChub2Rlc1RvUmVtb3ZlLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICAgIGNvbnN0IG1hdGNoaW5nTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUuZGVsZXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IG5vZGVJZHMuaGFzKG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBwYXJlbnRIaXQgPSAhaXNJbmNsdWRlZCAmJiBub2RlLnBhcmVudElkICYmIG1hdGNoaW5nTm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkIHx8IHBhcmVudEhpdCkge1xuICAgICAgICAgICAgbWF0Y2hpbmdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VJZHMgPSBuZXcgU2V0KGVkZ2VzVG9SZW1vdmUubWFwKChlZGdlKSA9PiBlZGdlLmlkKSk7XG4gICAgY29uc3QgZGVsZXRhYmxlRWRnZXMgPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UuZGVsZXRhYmxlICE9PSBmYWxzZSk7XG4gICAgY29uc3QgY29ubmVjdGVkRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlcyhtYXRjaGluZ05vZGVzLCBkZWxldGFibGVFZGdlcyk7XG4gICAgY29uc3QgbWF0Y2hpbmdFZGdlcyA9IGNvbm5lY3RlZEVkZ2VzO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBkZWxldGFibGVFZGdlcykge1xuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gZWRnZUlkcy5oYXMoZWRnZS5pZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkICYmICFtYXRjaGluZ0VkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGVkZ2UuaWQpKSB7XG4gICAgICAgICAgICBtYXRjaGluZ0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbkJlZm9yZURlbGV0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb25CZWZvcmVEZWxldGVSZXN1bHQgPSBhd2FpdCBvbkJlZm9yZURlbGV0ZSh7XG4gICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID8geyBlZGdlczogbWF0Y2hpbmdFZGdlcywgbm9kZXM6IG1hdGNoaW5nTm9kZXMgfSA6IHsgZWRnZXM6IFtdLCBub2RlczogW10gfTtcbiAgICB9XG4gICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0O1xufVxuXG5jb25zdCBjbGFtcCA9ICh2YWwsIG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbmNvbnN0IGNsYW1wUG9zaXRpb24gPSAocG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSwgZXh0ZW50LCBkaW1lbnNpb25zKSA9PiAoe1xuICAgIHg6IGNsYW1wKHBvc2l0aW9uLngsIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzBdIC0gKGRpbWVuc2lvbnM/LndpZHRoID8/IDApKSxcbiAgICB5OiBjbGFtcChwb3NpdGlvbi55LCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVsxXSAtIChkaW1lbnNpb25zPy5oZWlnaHQgPz8gMCkpLFxufSk7XG5mdW5jdGlvbiBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoY2hpbGRQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7IHdpZHRoOiBwYXJlbnRXaWR0aCwgaGVpZ2h0OiBwYXJlbnRIZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgcmV0dXJuIGNsYW1wUG9zaXRpb24oY2hpbGRQb3NpdGlvbiwgW1xuICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgIF0sIGNoaWxkRGltZW5zaW9ucyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmcgd2hlbiB0aGUgbW91c2UgaXMgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmFsdWUgLSBPbmUgZGltZW5zaW9uYWwgcG9pdGlvbiBvZiB0aGUgbW91c2UgKHggb3IgeSlcbiAqIEBwYXJhbSBtaW4gLSBNaW5pbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEBwYXJhbSBtYXggLSBNYXhpbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEByZXR1cm5zIC0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZ1xuICovXG5jb25zdCBjYWxjQXV0b1BhblZlbG9jaXR5ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtaW4pLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gLWNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWF4KSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgY2FsY0F1dG9QYW4gPSAocG9zLCBib3VuZHMsIHNwZWVkID0gMTUsIGRpc3RhbmNlID0gNDApID0+IHtcbiAgICBjb25zdCB4TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy54LCBkaXN0YW5jZSwgYm91bmRzLndpZHRoIC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgY29uc3QgeU1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueSwgZGlzdGFuY2UsIGJvdW5kcy5oZWlnaHQgLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICByZXR1cm4gW3hNb3ZlbWVudCwgeU1vdmVtZW50XTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZkJveGVzID0gKGJveDEsIGJveDIpID0+ICh7XG4gICAgeDogTWF0aC5taW4oYm94MS54LCBib3gyLngpLFxuICAgIHk6IE1hdGgubWluKGJveDEueSwgYm94Mi55KSxcbiAgICB4MjogTWF0aC5tYXgoYm94MS54MiwgYm94Mi54MiksXG4gICAgeTI6IE1hdGgubWF4KGJveDEueTIsIGJveDIueTIpLFxufSk7XG5jb25zdCByZWN0VG9Cb3ggPSAoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG59KTtcbmNvbnN0IGJveFRvUmVjdCA9ICh7IHgsIHksIHgyLCB5MiB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogeDIgLSB4LFxuICAgIGhlaWdodDogeTIgLSB5LFxufSk7XG5jb25zdCBub2RlVG9SZWN0ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwLFxuICAgIH07XG59O1xuY29uc3Qgbm9kZVRvQm94ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHgyOiB4ICsgKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCksXG4gICAgICAgIHkyOiB5ICsgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCksXG4gICAgfTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZlJlY3RzID0gKHJlY3QxLCByZWN0MikgPT4gYm94VG9SZWN0KGdldEJvdW5kc09mQm94ZXMocmVjdFRvQm94KHJlY3QxKSwgcmVjdFRvQm94KHJlY3QyKSkpO1xuY29uc3QgZ2V0T3ZlcmxhcHBpbmdBcmVhID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGNvbnN0IHhPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueCArIHJlY3RBLndpZHRoLCByZWN0Qi54ICsgcmVjdEIud2lkdGgpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCkpO1xuICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueSArIHJlY3RBLmhlaWdodCwgcmVjdEIueSArIHJlY3RCLmhlaWdodCkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh4T3ZlcmxhcCAqIHlPdmVybGFwKTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNSZWN0T2JqZWN0ID0gKG9iaikgPT4gaXNOdW1lcmljKG9iai53aWR0aCkgJiYgaXNOdW1lcmljKG9iai5oZWlnaHQpICYmIGlzTnVtZXJpYyhvYmoueCkgJiYgaXNOdW1lcmljKG9iai55KTtcbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBpc051bWVyaWMgPSAobikgPT4gIWlzTmFOKG4pICYmIGlzRmluaXRlKG4pO1xuLy8gdXNlZCBmb3IgYTExeSBrZXkgYm9hcmQgY29udHJvbHMgZm9yIG5vZGVzIGFuZCBlZGdlc1xuY29uc3QgZGV2V2FybiA9IChpZCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtSZWFjdCBGbG93XTogJHttZXNzYWdlfSBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3Qgc25hcFBvc2l0aW9uID0gKHBvc2l0aW9uLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChwb3NpdGlvbi54IC8gc25hcEdyaWRbMF0pLFxuICAgICAgICB5OiBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9zaXRpb24ueSAvIHNuYXBHcmlkWzFdKSxcbiAgICB9O1xufTtcbmNvbnN0IHBvaW50VG9SZW5kZXJlclBvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6ICh4IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAoeSAtIHR5KSAvIHRTY2FsZSxcbiAgICB9O1xuICAgIHJldHVybiBzbmFwVG9HcmlkID8gc25hcFBvc2l0aW9uKHBvc2l0aW9uLCBzbmFwR3JpZCkgOiBwb3NpdGlvbjtcbn07XG5jb25zdCByZW5kZXJlclBvaW50VG9Qb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiB0U2NhbGUgKyB0eCxcbiAgICAgICAgeTogeSAqIHRTY2FsZSArIHR5LFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgdmlld3BvcnQgdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdpdGggb3B0aW9uYWwgcGFkZGluZy5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFlvdSBjYW4gZGV0ZXJtaW5lIGJvdW5kcyBvZiBub2RlcyB3aXRoIHtAbGluayBnZXROb2Rlc0JvdW5kc30gYW5kIHtAbGluayBnZXRCb3VuZHNPZlJlY3RzfVxuICogQHBhcmFtIGJvdW5kcyAtIEJvdW5kcyB0byBmaXQgaW5zaWRlIHZpZXdwb3J0XG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBoZWlnaHQgIC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIG1pblpvb20gLSBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydFxuICogQHBhcmFtIG1heFpvb20gLSBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydFxuICogQHBhcmFtIHBhZGRpbmcgLSBPcHRpb25hbCBwYWRkaW5nIGFyb3VuZCB0aGUgYm91bmRzXG4gKiBAcmV0dXJucyBBIHRyYW5zZm9ybmVkIHtAbGluayBWaWV3cG9ydH0gdGhhdCBlbmNsb3NlcyB0aGUgZ2l2ZW4gYm91bmRzIHdoaWNoIHlvdSBjYW4gcGFzcyB0byBlLmcuIHtAbGluayBzZXRWaWV3cG9ydH1cbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKFxuICB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwfSxcbiAgMTIwMCwgODAwLCAwLjUsIDIpO1xuICovXG5jb25zdCBnZXRWaWV3cG9ydEZvckJvdW5kcyA9IChib3VuZHMsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20sIHBhZGRpbmcpID0+IHtcbiAgICBjb25zdCB4Wm9vbSA9IHdpZHRoIC8gKGJvdW5kcy53aWR0aCAqICgxICsgcGFkZGluZykpO1xuICAgIGNvbnN0IHlab29tID0gaGVpZ2h0IC8gKGJvdW5kcy5oZWlnaHQgKiAoMSArIHBhZGRpbmcpKTtcbiAgICBjb25zdCB6b29tID0gTWF0aC5taW4oeFpvb20sIHlab29tKTtcbiAgICBjb25zdCBjbGFtcGVkWm9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclggPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIGJvdW5kc0NlbnRlclggKiBjbGFtcGVkWm9vbTtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC8gMiAtIGJvdW5kc0NlbnRlclkgKiBjbGFtcGVkWm9vbTtcbiAgICByZXR1cm4geyB4LCB5LCB6b29tOiBjbGFtcGVkWm9vbSB9O1xufTtcbmNvbnN0IGlzTWFjT3MgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5kZXhPZignTWFjJykgPj0gMDtcbmZ1bmN0aW9uIGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgZXh0ZW50ICE9PSAncGFyZW50Jztcbn1cbmZ1bmN0aW9uIGdldE5vZGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGgpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQpICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGNoaWxkIHBvc2l0aW9uIHRvIGFib3NsdXRlIHBvc2l0aW9uXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEBwYXJhbSBwYXJlbnRJZFxuICogQHBhcmFtIG5vZGVMb29rdXBcbiAqIEBwYXJhbSBub2RlT3JpZ2luXG4gKiBAcmV0dXJucyBhbiBpbnRlcm5hbCBub2RlIHdpdGggYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHBvc2l0aW9uLCBkaW1lbnNpb25zID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIHBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKSB7XG4gICAgbGV0IG5leHRQYXJlbnRJZCA9IHBhcmVudElkO1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgd2hpbGUgKG5leHRQYXJlbnRJZCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChuZXh0UGFyZW50SWQpO1xuICAgICAgICBuZXh0UGFyZW50SWQgPSBwYXJlbnQ/LnBhcmVudElkO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luIHx8IG5vZGVPcmlnaW47XG4gICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUueSArPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSAtIChkaW1lbnNpb25zLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LCB7IHNuYXBHcmlkID0gWzAsIDBdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBwb2ludGVyUG9zID0gcG9pbnRUb1JlbmRlcmVyUG9pbnQoeyB4LCB5IH0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgeyB4OiB4U25hcHBlZCwgeTogeVNuYXBwZWQgfSA9IHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9pbnRlclBvcywgc25hcEdyaWQpIDogcG9pbnRlclBvcztcbiAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgIHJldHVybiB7XG4gICAgICAgIHhTbmFwcGVkLFxuICAgICAgICB5U25hcHBlZCxcbiAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICB9O1xufVxuY29uc3QgZ2V0RGltZW5zaW9ucyA9IChub2RlKSA9PiAoe1xuICAgIHdpZHRoOiBub2RlLm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogbm9kZS5vZmZzZXRIZWlnaHQsXG59KTtcbmNvbnN0IGdldEhvc3RGb3JFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IGlzSW5wdXQgPSBpbnB1dFRhZ3MuaW5jbHVkZXModGFyZ2V0Py5ub2RlTmFtZSkgfHwgdGFyZ2V0Py5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldD8uY2xvc2VzdCgnLm5va2V5Jyk7XG59XG5jb25zdCBpc01vdXNlRXZlbnQgPSAoZXZlbnQpID0+ICdjbGllbnRYJyBpbiBldmVudDtcbmNvbnN0IGdldEV2ZW50UG9zaXRpb24gPSAoZXZlbnQsIGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IGlzTW91c2UgPSBpc01vdXNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGV2dFggPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRYO1xuICAgIGNvbnN0IGV2dFkgPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WSA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2dFggLSAoYm91bmRzPy5sZWZ0ID8/IDApLFxuICAgICAgICB5OiBldnRZIC0gKGJvdW5kcz8udG9wID8/IDApLFxuICAgIH07XG59O1xuLy8gVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbi8vIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbi8vIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuY29uc3QgZ2V0SGFuZGxlQm91bmRzID0gKHR5cGUsIG5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlSWQpID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7dHlwZX1gKTtcbiAgICBpZiAoIWhhbmRsZXMgfHwgIWhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShoYW5kbGVzKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVCb3VuZHMgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaGFuZGxlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wKSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRCZXppZXJFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZLCB0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFksIH0pIHtcbiAgICAvLyBjdWJpYyBiZXppZXIgdD0wLjUgbWlkIHBvaW50LCBub3QgdGhlIGFjdHVhbCBtaWQgcG9pbnQsIGJ1dCBlYXN5IHRvIGNhbGN1bGF0ZVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3NTE2MTAxL2hvdy10by1maW5kLWRpc3RhbmNlLW1pZC1wb2ludC1vZi1iZXppZXItY3VydmVcbiAgICBjb25zdCBjZW50ZXJYID0gc291cmNlWCAqIDAuMTI1ICsgc291cmNlQ29udHJvbFggKiAwLjM3NSArIHRhcmdldENvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRYICogMC4xMjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHNvdXJjZVkgKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0WSAqIDAuMTI1O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmFicyhjZW50ZXJYIC0gc291cmNlWCk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguYWJzKGNlbnRlclkgLSBzb3VyY2VZKTtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIG9mZnNldFgsIG9mZnNldFldO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbi8qKlxuICogR2V0IGEgYmV6aWVyIHBhdGggZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlIChkZWZhdWx0OiBQb3NpdGlvbi5Cb3R0b20pXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0UG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLlRvcClcbiAqIEBwYXJhbSBwYXJhbXMuY3VydmF0dXJlIC0gVGhlIGN1cnZhdHVyZSBvZiB0aGUgYmV6aWVyIGVkZ2VcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gICAgXG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbn0pO1xuICovXG5mdW5jdGlvbiBnZXRCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjdXJ2YXR1cmUgPSAwLjI1LCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cblxuLy8gdGhpcyBpcyB1c2VkIGZvciBzdHJhaWdodCBlZGdlcyBhbmQgc2ltcGxlIHNtb290aHN0ZXAgZWRnZXMgKExUUiwgUlRMLCBCVFQsIFRUQilcbmZ1bmN0aW9uIGdldEVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgeE9mZnNldCA9IE1hdGguYWJzKHRhcmdldFggLSBzb3VyY2VYKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWCA9IHRhcmdldFggPCBzb3VyY2VYID8gdGFyZ2V0WCArIHhPZmZzZXQgOiB0YXJnZXRYIC0geE9mZnNldDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WSAtIHNvdXJjZVkpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gdGFyZ2V0WSA8IHNvdXJjZVkgPyB0YXJnZXRZICsgeU9mZnNldCA6IHRhcmdldFkgLSB5T2Zmc2V0O1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgeE9mZnNldCwgeU9mZnNldF07XG59XG5mdW5jdGlvbiBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCBzZWxlY3RlZCA9IGZhbHNlLCB6SW5kZXggPSAwLCBlbGV2YXRlT25TZWxlY3QgPSBmYWxzZSwgfSkge1xuICAgIGlmICghZWxldmF0ZU9uU2VsZWN0KSB7XG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VPckNvbm5lY3RlZE5vZGVTZWxlY3RlZCA9IHNlbGVjdGVkIHx8IHRhcmdldE5vZGUuc2VsZWN0ZWQgfHwgc291cmNlTm9kZS5zZWxlY3RlZDtcbiAgICBjb25zdCBzZWxlY3RlZFpJbmRleCA9IE1hdGgubWF4KHNvdXJjZU5vZGUuaW50ZXJuYWxzLnogfHwgMCwgdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiB8fCAwLCAxMDAwKTtcbiAgICByZXR1cm4gekluZGV4ICsgKGVkZ2VPckNvbm5lY3RlZE5vZGVTZWxlY3RlZCA/IHNlbGVjdGVkWkluZGV4IDogMCk7XG59XG5mdW5jdGlvbiBpc0VkZ2VWaXNpYmxlKHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtIH0pIHtcbiAgICBjb25zdCBlZGdlQm94ID0gZ2V0Qm91bmRzT2ZCb3hlcyhub2RlVG9Cb3goc291cmNlTm9kZSksIG5vZGVUb0JveCh0YXJnZXROb2RlKSk7XG4gICAgaWYgKGVkZ2VCb3gueCA9PT0gZWRnZUJveC54Mikge1xuICAgICAgICBlZGdlQm94LngyICs9IDE7XG4gICAgfVxuICAgIGlmIChlZGdlQm94LnkgPT09IGVkZ2VCb3gueTIpIHtcbiAgICAgICAgZWRnZUJveC55MiArPSAxO1xuICAgIH1cbiAgICBjb25zdCB2aWV3UmVjdCA9IHtcbiAgICAgICAgeDogLXRyYW5zZm9ybVswXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXRyYW5zZm9ybVsxXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIHRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRPdmVybGFwcGluZ0FyZWEodmlld1JlY3QsIGJveFRvUmVjdChlZGdlQm94KSkgPiAwO1xufVxuY29uc3QgZ2V0RWRnZUlkID0gKHsgc291cmNlLCBzb3VyY2VIYW5kbGUsIHRhcmdldCwgdGFyZ2V0SGFuZGxlIH0pID0+IGB4eS1lZGdlX18ke3NvdXJjZX0ke3NvdXJjZUhhbmRsZSB8fCAnJ30tJHt0YXJnZXR9JHt0YXJnZXRIYW5kbGUgfHwgJyd9YDtcbmNvbnN0IGNvbm5lY3Rpb25FeGlzdHMgPSAoZWRnZSwgZWRnZXMpID0+IHtcbiAgICByZXR1cm4gZWRnZXMuc29tZSgoZWwpID0+IGVsLnNvdXJjZSA9PT0gZWRnZS5zb3VyY2UgJiZcbiAgICAgICAgZWwudGFyZ2V0ID09PSBlZGdlLnRhcmdldCAmJlxuICAgICAgICAoZWwuc291cmNlSGFuZGxlID09PSBlZGdlLnNvdXJjZUhhbmRsZSB8fCAoIWVsLnNvdXJjZUhhbmRsZSAmJiAhZWRnZS5zb3VyY2VIYW5kbGUpKSAmJlxuICAgICAgICAoZWwudGFyZ2V0SGFuZGxlID09PSBlZGdlLnRhcmdldEhhbmRsZSB8fCAoIWVsLnRhcmdldEhhbmRsZSAmJiAhZWRnZS50YXJnZXRIYW5kbGUpKSk7XG59O1xuLyoqXG4gKiBUaGlzIHV0aWwgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhZGQgYSBuZXcgRWRnZSB0byBhbiBhcnJheSBvZiBlZGdlc1xuICogQHJlbWFya3MgSXQgYWxzbyBwZXJmb3JtcyBzb21lIHZhbGlkYXRpb24gdG8gbWFrZSBzdXJlIHlvdSBkb24ndCBhZGQgYW4gaW52YWxpZCBlZGdlIG9yIGR1cGxpY2F0ZSBhbiBleGlzdGluZyBvbmUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gZWRnZVBhcmFtcyAtIEVpdGhlciBhbiBFZGdlIG9yIGEgQ29ubmVjdGlvbiB5b3Ugd2FudCB0byBhZGRcbiAqIEBwYXJhbSBlZGdlcyAtICBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXNcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIGVkZ2VzIHdpdGggdGhlIG5ldyBlZGdlIGFkZGVkXG4gKi9cbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2VCYXNlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnNvdXJjZUhhbmRsZTtcbiAgICB9XG4gICAgaWYgKGVkZ2UudGFyZ2V0SGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnRhcmdldEhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG4vKipcbiAqIEEgaGFuZHkgdXRpbGl0eSB0byByZWNvbm5lY3QgYW4gZXhpc3RpbmcgZWRnZSB3aXRoIG5ldyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gb2xkRWRnZSAtIFRoZSBlZGdlIHlvdSB3YW50IHRvIHVwZGF0ZVxuICogQHBhcmFtIG5ld0Nvbm5lY3Rpb24gLSBUaGUgbmV3IGNvbm5lY3Rpb24geW91IHdhbnQgdG8gdXBkYXRlIHRoZSBlZGdlIHdpdGhcbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlc1xuICogQHBhcmFtIG9wdGlvbnMuc2hvdWxkUmVwbGFjZUlkIC0gc2hvdWxkIHRoZSBpZCBvZiB0aGUgb2xkIGVkZ2UgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IGNvbm5lY3Rpb24gaWRcbiAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGVkZ2VzIGFycmF5XG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzdHJhaWdodCBwYXRoIGZyb20gc291cmNlIHRvIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWCAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVkgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc291cmNlIGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0WSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaGFuZGxlXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGxhYmVsWCBhbmQgbGFiZWxZIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aCkgYW5kIG9mZnNldFgsIG9mZnNldFkgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbFxuICogQGV4YW1wbGVcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gICAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICAgIFxuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAgICB9KTtcbiAqL1xuZnVuY3Rpb24gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICB9KTtcbiAgICByZXR1cm4gW2BNICR7c291cmNlWH0sJHtzb3VyY2VZfUwgJHt0YXJnZXRYfSwke3RhcmdldFl9YCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldO1xufVxuXG5jb25zdCBoYW5kbGVEaXJlY3Rpb25zID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IHsgeDogMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IHsgeDogMCwgeTogMSB9LFxufTtcbmNvbnN0IGdldERpcmVjdGlvbiA9ICh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgfSkgPT4ge1xuICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdCB8fCBzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS54IDwgdGFyZ2V0LnggPyB7IHg6IDEsIHk6IDAgfSA6IHsgeDogLTEsIHk6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS55IDwgdGFyZ2V0LnkgPyB7IHg6IDAsIHk6IDEgfSA6IHsgeDogMCwgeTogLTEgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coYi54IC0gYS54LCAyKSArIE1hdGgucG93KGIueSAtIGEueSwgMikpO1xuLy8gaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGEgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4vLyBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbmZ1bmN0aW9uIGdldFBvaW50cyh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGNlbnRlciwgb2Zmc2V0LCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbZGVmYXVsdENlbnRlclgsIGRlZmF1bHRDZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgIH0pO1xuICAgIC8vIG9wcG9zaXRlIGhhbmRsZSBwb3NpdGlvbnMsIGRlZmF1bHQgY2FzZVxuICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICogdGFyZ2V0RGlyW2RpckFjY2Vzc29yXSA9PT0gLTEpIHtcbiAgICAgICAgY2VudGVyWCA9IGNlbnRlci54ID8/IGRlZmF1bHRDZW50ZXJYO1xuICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgPz8gZGVmYXVsdENlbnRlclk7XG4gICAgICAgIC8vICAgIC0tLT5cbiAgICAgICAgLy8gICAgfFxuICAgICAgICAvLyA+LS0tXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vICAgIHxcbiAgICAgICAgLy8gIC0tLVxuICAgICAgICAvLyAgfFxuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gdmVydGljYWxTcGxpdCA6IGhvcml6b250YWxTcGxpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBob3Jpem9udGFsU3BsaXQgOiB2ZXJ0aWNhbFNwbGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2VUYXJnZXQgbWVhbnMgd2UgdGFrZSB4IGZyb20gc291cmNlIGFuZCB5IGZyb20gdGFyZ2V0LCB0YXJnZXRTb3VyY2UgaXMgdGhlIG9wcG9zaXRlXG4gICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldCA9IFt7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiB0YXJnZXRHYXBwZWQueSB9XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0gW3sgeDogdGFyZ2V0R2FwcGVkLngsIHk6IHNvdXJjZUdhcHBlZC55IH1dO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXMgZWRnZXMgd2l0aCBzYW1lIGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci54ID09PSBjdXJyRGlyID8gdGFyZ2V0U291cmNlIDogc291cmNlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnkgPT09IGN1cnJEaXIgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHNvdXJjZVtkaXJBY2Nlc3Nvcl0gLSB0YXJnZXRbZGlyQWNjZXNzb3JdKTtcbiAgICAgICAgICAgIC8vIGlmIGFuIGVkZ2UgZ29lcyBmcm9tIHJpZ2h0IHRvIHJpZ2h0IGZvciBleGFtcGxlIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIGFuZCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UueCBhbmQgdGFyZ2V0LnggaXMgbGVzcyB0aGFuIHRoZSBvZmZzZXQsIHRoZSBhZGRlZCBwb2ludCBhbmQgdGhlIGdhcHBlZCBzb3VyY2UvdGFyZ2V0IHdpbGwgb3ZlcmxhcC4gVGhpcyBsZWFkcyB0byBhIHdlaXJkIGVkZ2UgcGF0aC4gVG8gYXZvaWQgdGhpcyB3ZSBhZGQgYSBnYXBPZmZzZXQgdG8gdGhlIHNvdXJjZS90YXJnZXRcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcE9mZnNldCA9IE1hdGgubWluKG9mZnNldCAtIDEsIG9mZnNldCAtIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAoc291cmNlR2FwcGVkW2RpckFjY2Vzc29yXSA+IHNvdXJjZVtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0R2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9ICh0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JdID4gdGFyZ2V0W2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGFyZSBjb25kaXRpb25zIGZvciBoYW5kbGluZyBtaXhlZCBoYW5kbGUgcG9zaXRpb25zIGxpa2UgUmlnaHQgLT4gQm90dG9tIGZvciBleGFtcGxlXG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiAhPT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpckFjY2Vzc29yT3Bwb3NpdGUgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lRGlyID0gc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gdGFyZ2V0RGlyW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlR3RUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdID4gdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTHRUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdIDwgdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcFNvdXJjZVRhcmdldCA9IChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSkpIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gIT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pKSk7XG4gICAgICAgICAgICBpZiAoZmxpcFNvdXJjZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlR2FwUG9pbnQgPSB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0R2FwUG9pbnQgPSB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgbWF4WERpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueCAtIHBvaW50c1swXS54KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueCAtIHBvaW50c1swXS54KSk7XG4gICAgICAgIGNvbnN0IG1heFlEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSkpO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBlZGdlXG4gICAgICAgIGlmIChtYXhYRGlzdGFuY2UgPj0gbWF4WURpc3RhbmNlKSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gKHNvdXJjZUdhcFBvaW50LnggKyB0YXJnZXRHYXBQb2ludC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gcG9pbnRzWzBdLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gcG9pbnRzWzBdLng7XG4gICAgICAgICAgICBjZW50ZXJZID0gKHNvdXJjZUdhcFBvaW50LnkgKyB0YXJnZXRHYXBQb2ludC55KSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IFtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgLi4ucG9pbnRzLFxuICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIF07XG4gICAgcmV0dXJuIFtwYXRoUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldO1xufVxuZnVuY3Rpb24gZ2V0QmVuZChhLCBiLCBjLCBzaXplKSB7XG4gICAgY29uc3QgYmVuZFNpemUgPSBNYXRoLm1pbihkaXN0YW5jZShhLCBiKSAvIDIsIGRpc3RhbmNlKGIsIGMpIC8gMiwgc2l6ZSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiO1xuICAgIC8vIG5vIGJlbmRcbiAgICBpZiAoKGEueCA9PT0geCAmJiB4ID09PSBjLngpIHx8IChhLnkgPT09IHkgJiYgeSA9PT0gYy55KSkge1xuICAgICAgICByZXR1cm4gYEwke3h9ICR7eX1gO1xuICAgIH1cbiAgICAvLyBmaXJzdCBzZWdtZW50IGlzIGhvcml6b250YWxcbiAgICBpZiAoYS55ID09PSB5KSB7XG4gICAgICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBgTCAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1RICR7eH0sJHt5fSAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1gO1xuICAgIH1cbiAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gMSA6IC0xO1xuICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGBMICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfVEgJHt4fSwke3l9ICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fWA7XG59XG4vKipcbiAqIEdldCBhIHNtb290aCBzdGVwIHBhdGggZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlIChkZWZhdWx0OiBQb3NpdGlvbi5Cb3R0b20pXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0UG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLlRvcClcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gICAgXG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gICAgfSk7XG4gKi9cbmZ1bmN0aW9uIGdldFNtb290aFN0ZXBQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBib3JkZXJSYWRpdXMgPSA1LCBjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXQgPSAyMCwgfSkge1xuICAgIGNvbnN0IFtwb2ludHMsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFBvaW50cyh7XG4gICAgICAgIHNvdXJjZTogeyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH0sXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHsgeDogdGFyZ2V0WCwgeTogdGFyZ2V0WSB9LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgY2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgb2Zmc2V0LFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvLyBwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wXG4gICAgLy8gd2Ugc2V0IHRoZSB4IGFueSB5IHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIGJhc2VkIG9uIHRoZSBub2RlcyBwb3NpdGlvblxuICAgIGxldCBwb3MgPSBbXG4gICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGggKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LngsXG4gICAgICAgIG5vZGVSZWN0LnkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSAtIG9mZnNldCxcbiAgICBdO1xuICAgIC8vIGFuZCB0aGFuIHNoaWZ0IGl0IGJhc2VkIG9uIHRoZSBhbGlnbm1lbnQuIFRoZSBzaGlmdCB2YWx1ZXMgYXJlIGluICUuXG4gICAgbGV0IHNoaWZ0ID0gWy0xMDAgKiBhbGlnbm1lbnRPZmZzZXQsIC0xMDBdO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHBvcyA9IFtcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueCArIG5vZGVSZWN0LndpZHRoKSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWzAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcG9zWzFdID0gKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnkgKyBvZmZzZXQ7XG4gICAgICAgICAgICBzaGlmdFsxXSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIG5vZGVSZWN0LnggKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzaGlmdCA9IFstMTAwLCAtMTAwICogYWxpZ25tZW50T2Zmc2V0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHRyYW5zbGF0ZSgke3NoaWZ0WzBdfSUsICR7c2hpZnRbMV19JSlgO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgZGVmYXVsdHM6IHt9LFxufTtcbmNvbnN0IGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgaW5jb21pbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmNvbWluZykge1xuICAgICAgICBpZiAoaW5jb21pbmdba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0eXBlY2FzdCBpcyBzYWZlIGhlcmUsIGJlY2F1c2Ugd2UgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbmNvbWluZ1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIF9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkpO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCB0bXBMb29rdXAgPSBuZXcgTWFwKG5vZGVMb29rdXApO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBfb3B0aW9ucz8uZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBub2RlTG9va3VwLmNsZWFyKCk7XG4gICAgcGFyZW50TG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB1c2VyTm9kZSBvZiBub2Rlcykge1xuICAgICAgICBsZXQgaW50ZXJuYWxOb2RlID0gdG1wTG9va3VwLmdldCh1c2VyTm9kZS5pZCk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5jaGVja0VxdWFsaXR5ICYmIHVzZXJOb2RlID09PSBpbnRlcm5hbE5vZGU/LmludGVybmFscy51c2VyTm9kZSkge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHVzZXJOb2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudCh1c2VyTm9kZS5leHRlbnQpID8gdXNlck5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKHVzZXJOb2RlKSk7XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX29wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4udXNlck5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHVzZXJOb2RlLm1lYXN1cmVkPy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB1c2VyTm9kZS5tZWFzdXJlZD8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGNsYW1wZWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlciByZS1pbml0aWFsaXplcyB0aGUgbm9kZSBvciByZW1vdmVzIGBtZWFzdXJlZGAgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgcmVzZXQgdGhlIGhhbmRsZUJvdW5kcyBzbyB0aGF0IHRoZSBub2RlIGdldHMgcmUtbWVhc3VyZWRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiAhdXNlck5vZGUubWVhc3VyZWQgPyB1bmRlZmluZWQgOiBpbnRlcm5hbE5vZGU/LmludGVybmFscy5oYW5kbGVCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIHo6IGNhbGN1bGF0ZVoodXNlck5vZGUsIHNlbGVjdGVkTm9kZVopLFxuICAgICAgICAgICAgICAgICAgICB1c2VyTm9kZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyTm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKGludGVybmFsTm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudExvb2t1cChub2RlLCBwYXJlbnRMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gcGFyZW50TG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudExvb2t1cC5zZXQobm9kZS5wYXJlbnRJZCwgbmV3IE1hcChbW25vZGUuaWQsIG5vZGVdXSkpO1xuICAgIH1cbn1cbi8qKlxuICogVXBkYXRlcyBwb3NpdGlvbkFic29sdXRlIGFuZCB6SW5kZXggb2YgYSBjaGlsZCBub2RlIGFuZCB0aGUgcGFyZW50TG9va3VwLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZE5vZGUobm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCB9ID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJlbnQgbm9kZSAke3BhcmVudElkfSBub3QgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgbm9kZXMgYXJlIGluIGZyb250IG9mIHRoZWlyIGNoaWxkIG5vZGVzIGluIHRoZSBub2RlcyBhcnJheS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBjb25zdCB7IHgsIHksIHogfSA9IGNhbGN1bGF0ZUNoaWxkWFlaKG5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0geCAhPT0gcG9zaXRpb25BYnNvbHV0ZS54IHx8IHkgIT09IHBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBpZiAocG9zaXRpb25DaGFuZ2VkIHx8IHogIT09IG5vZGUuaW50ZXJuYWxzLnopIHtcbiAgICAgICAgbm9kZS5pbnRlcm5hbHMgPSB7XG4gICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IHBvc2l0aW9uQ2hhbmdlZCA/IHsgeCwgeSB9IDogcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgIHosXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlWihub2RlLCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgcmV0dXJuIChpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwKSArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hpbGRYWVooY2hpbGROb2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIGNvbnN0IGNoaWxkRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKGNoaWxkTm9kZSk7XG4gICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihjaGlsZE5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGlzQ29vcmRpbmF0ZUV4dGVudChjaGlsZE5vZGUuZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBjaGlsZE5vZGUuZXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpXG4gICAgICAgIDogcG9zaXRpb25XaXRoT3JpZ2luO1xuICAgIGxldCBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbih7IHg6IHBhcmVudFggKyBjbGFtcGVkUG9zaXRpb24ueCwgeTogcGFyZW50WSArIGNsYW1wZWRQb3NpdGlvbi55IH0sIG5vZGVFeHRlbnQsIGNoaWxkRGltZW5zaW9ucyk7XG4gICAgaWYgKGNoaWxkTm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoYWJzb2x1dGVQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnROb2RlKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRaID0gY2FsY3VsYXRlWihjaGlsZE5vZGUsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHBhcmVudFogPSBwYXJlbnROb2RlLmludGVybmFscy56ID8/IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYWJzb2x1dGVQb3NpdGlvbi54LFxuICAgICAgICB5OiBhYnNvbHV0ZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IHBhcmVudFogPiBjaGlsZFogPyBwYXJlbnRaIDogY2hpbGRaLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVFeHBhbmRQYXJlbnQoY2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBwYXJlbnRFeHBhbnNpb25zID0gbmV3IE1hcCgpO1xuICAgIC8vIGRldGVybWluZSB0aGUgZXhwYW5kZWQgcmVjdGFuZ2xlIHRoZSBjaGlsZCBub2RlcyB3b3VsZCB0YWtlIGZvciBlYWNoIHBhcmVudFxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQoY2hpbGQucGFyZW50SWQpO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudEV4cGFuc2lvbnMuZ2V0KGNoaWxkLnBhcmVudElkKT8uZXhwYW5kZWRSZWN0ID8/IG5vZGVUb1JlY3QocGFyZW50KTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRSZWN0ID0gZ2V0Qm91bmRzT2ZSZWN0cyhwYXJlbnRSZWN0LCBjaGlsZC5yZWN0KTtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5zZXQoY2hpbGQucGFyZW50SWQsIHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbnNpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuZm9yRWFjaCgoeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9LCBwYXJlbnRJZCkgPT4ge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiAmIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBwYXJlbnQgZXhwYW5kcyBpbiB3aWR0aCBhbmQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSBleHBhbmRlZFJlY3QueCA8IHBvc2l0aW9uQWJzb2x1dGUueCA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS54IC0gZXhwYW5kZWRSZWN0LngpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnkgPCBwb3NpdGlvbkFic29sdXRlLnkgPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueSAtIGV4cGFuZGVkUmVjdC55KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoLCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC53aWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoZGltZW5zaW9ucy5oZWlnaHQsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LmhlaWdodCkpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhDaGFuZ2UgPSAobmV3V2lkdGggLSBkaW1lbnNpb25zLndpZHRoKSAqIG9yaWdpblswXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodENoYW5nZSA9IChuZXdIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodCkgKiBvcmlnaW5bMV07XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKHhDaGFuZ2UgPiAwIHx8IHlDaGFuZ2UgPiAwIHx8IHdpZHRoQ2hhbmdlIHx8IGhlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBhcmVudC5wb3NpdGlvbi54IC0geENoYW5nZSArIHdpZHRoQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGFyZW50LnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgaGVpZ2h0Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdlIG1vdmUgYWxsIGNoaWxkIG5vZGVzIGluIHRoZSBvcHBzaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHNvIHRoZSB4LHkgY2hhbmdlcyBvZiB0aGUgcGFyZW50IGRvIG5vdCBtb3ZlIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5nZXQocGFyZW50SWQpPy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaWQgPT09IGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54ICsgeENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgKyB5Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBleHBhbmRlZFJlY3Qud2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBleHBhbmRlZFJlY3QuaGVpZ2h0IHx8IHhDaGFuZ2UgfHwgeUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAoeENoYW5nZSA/IG9yaWdpblswXSAqIHhDaGFuZ2UgLSB3aWR0aENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgKyAoeUNoYW5nZSA/IG9yaWdpblsxXSAqIHlDaGFuZ2UgLSBoZWlnaHRDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcueHlmbG93X192aWV3cG9ydCcpO1xuICAgIGxldCB1cGRhdGVkSW50ZXJuYWxzID0gZmFsc2U7XG4gICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10sIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnROb2RlKTtcbiAgICBjb25zdCB7IG0yMjogem9vbSB9ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhSZWFkT25seShzdHlsZS50cmFuc2Zvcm0pO1xuICAgIC8vIGluIHRoaXMgYXJyYXkgd2UgY29sbGVjdCBub2RlcywgdGhhdCBtaWdodCB0cmlnZ2VyIGNoYW5nZXMgKGxpa2UgZXhwYW5kaW5nIHBhcmVudClcbiAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KHVwZGF0ZS5pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2RlLmludGVybmFscyA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKHVwZGF0ZS5ub2RlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2VkID0gbm9kZS5tZWFzdXJlZC53aWR0aCAhPT0gZGltZW5zaW9ucy53aWR0aCB8fCBub2RlLm1lYXN1cmVkLmhlaWdodCAhPT0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBkb1VwZGF0ZSA9ICEhKGRpbWVuc2lvbnMud2lkdGggJiZcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgIChkaW1lbnNpb25DaGFuZ2VkIHx8ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdXBkYXRlLmZvcmNlKSk7XG4gICAgICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlQm91bmRzID0gdXBkYXRlLm5vZGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IG5vZGVFeHRlbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQocG9zaXRpb25BYnNvbHV0ZSwgZGltZW5zaW9ucywgbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25BYnNvbHV0ZSwgZXh0ZW50LCBkaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5tZWFzdXJlZCA9IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0SGFuZGxlQm91bmRzKCdzb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXRIYW5kbGVCb3VuZHMoJ3RhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUobm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDogbm9kZVRvUmVjdChub2RlLCBub2RlT3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIH0pIHtcbiAgICBpZiAoIXBhblpvb20gfHwgKCFkZWx0YS54ICYmICFkZWx0YS55KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdHJhbnNmb3JtWzBdICsgZGVsdGEueCxcbiAgICAgICAgeTogdHJhbnNmb3JtWzFdICsgZGVsdGEueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGFuZ2VkID0gISFuZXh0Vmlld3BvcnQgJiZcbiAgICAgICAgKG5leHRWaWV3cG9ydC54ICE9PSB0cmFuc2Zvcm1bMF0gfHwgbmV4dFZpZXdwb3J0LnkgIT09IHRyYW5zZm9ybVsxXSB8fCBuZXh0Vmlld3BvcnQuayAhPT0gdHJhbnNmb3JtWzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybUNoYW5nZWQpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcykge1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuY2xlYXIoKTtcbiAgICBlZGdlTG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlLCB0YXJnZXQsIHNvdXJjZUhhbmRsZSA9IG51bGwsIHRhcmdldEhhbmRsZSA9IG51bGwgfSA9IGVkZ2U7XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleSA9IGAke3NvdXJjZX0tc291cmNlLSR7c291cmNlSGFuZGxlfWA7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGAke3RhcmdldH0tdGFyZ2V0LSR7dGFyZ2V0SGFuZGxlfWA7XG4gICAgICAgIGNvbnN0IHByZXZTb3VyY2UgPSBjb25uZWN0aW9uTG9va3VwLmdldChzb3VyY2VLZXkpIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgcHJldlRhcmdldCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KHRhcmdldEtleSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyBlZGdlSWQ6IGVkZ2UuaWQsIHNvdXJjZSwgdGFyZ2V0LCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9O1xuICAgICAgICBlZGdlTG9va3VwLnNldChlZGdlLmlkLCBlZGdlKTtcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoc291cmNlS2V5LCBwcmV2U291cmNlLnNldChgJHt0YXJnZXR9LSR7dGFyZ2V0SGFuZGxlfWAsIGNvbm5lY3Rpb24pKTtcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cC5zZXQodGFyZ2V0S2V5LCBwcmV2VGFyZ2V0LnNldChgJHtzb3VyY2V9LSR7c291cmNlSGFuZGxlfWAsIGNvbm5lY3Rpb24pKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dOb2RlRGF0YShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IF9hID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgY29uc3QgX2IgPSBBcnJheS5pc0FycmF5KGIpID8gYiA6IFtiXTtcbiAgICBpZiAoX2EubGVuZ3RoICE9PSBfYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChfYVtpXS5pZCAhPT0gX2JbaV0uaWQgfHwgX2FbaV0udHlwZSAhPT0gX2JbaV0udHlwZSB8fCAhT2JqZWN0LmlzKF9hW2ldLmRhdGEsIF9iW2ldLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUGFyZW50U2VsZWN0ZWQocGFyZW50Tm9kZSwgbm9kZUxvb2t1cCk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rvcih0YXJnZXQsIHNlbGVjdG9yLCBkb21Ob2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudD8ubWF0Y2hlcyhzZWxlY3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvbU5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICBjb25zdCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKChub2RlLnNlbGVjdGVkIHx8IG5vZGUuaWQgPT09IG5vZGVJZCkgJiZcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnRJZCB8fCAhaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSkgJiZcbiAgICAgICAgICAgIChub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGludGVybmFsTm9kZS5wb3NpdGlvbiB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlUG9zLnggLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBpbnRlcm5hbE5vZGUuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogaW50ZXJuYWxOb2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGludGVybmFsTm9kZS5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFBhcmVudDogaW50ZXJuYWxOb2RlLmV4cGFuZFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGludGVybmFsTm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHJhZ0l0ZW1zO1xufVxuLy8gcmV0dXJucyB0d28gcGFyYW1zOlxuLy8gMS4gdGhlIGRyYWdnZWQgbm9kZSAob3IgdGhlIGZpcnN0IG9mIHRoZSBsaXN0LCBpZiB3ZSBhcmUgZHJhZ2dpbmcgYSBub2RlIHNlbGVjdGlvbilcbi8vIDIuIGFycmF5IG9mIHNlbGVjdGVkIG5vZGVzIChmb3IgbXVsdGkgc2VsZWN0aW9ucylcbmZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlclBhcmFtcyh7IG5vZGVJZCwgZHJhZ0l0ZW1zLCBub2RlTG9va3VwLCBkcmFnZ2luZyA9IHRydWUsIH0pIHtcbiAgICBjb25zdCBub2Rlc0Zyb21EcmFnSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICByZXR1cm4gW25vZGVzRnJvbURyYWdJdGVtc1swXSwgbm9kZXNGcm9tRHJhZ0l0ZW1zXTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICByZXR1cm4gW1xuICAgICAgICAhbm9kZVxuICAgICAgICAgICAgPyBub2Rlc0Zyb21EcmFnSXRlbXNbMF1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtcy5nZXQobm9kZUlkKT8ucG9zaXRpb24gfHwgbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcyxcbiAgICBdO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gWFlEcmFnKHsgb25Ob2RlTW91c2VEb3duLCBnZXRTdG9yZUl0ZW1zLCBvbkRyYWdTdGFydCwgb25EcmFnLCBvbkRyYWdTdG9wLCB9KSB7XG4gICAgbGV0IGxhc3RQb3MgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgbGV0IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IGQzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgYWJvcnREcmFnID0gZmFsc2U7IC8vIHByZXZlbnRzIHVuaW50ZW50aW9uYWwgZHJhZ2dpbmcgb24gbXVsdGl0b3VjaFxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlLCBpc1NlbGVjdGFibGUsIG5vZGVJZCwgbm9kZUNsaWNrRGlzdGFuY2UgPSAwLCB9KSB7XG4gICAgICAgIGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOb2Rlcyh7IHgsIHkgfSwgZHJhZ0V2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVFeHRlbnQsIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBvbk5vZGVEcmFnLCBvblNlbGVjdGlvbkRyYWcsIG9uRXJyb3IsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBsYXN0UG9zID0geyB4LCB5IH07XG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZXNCb3ggPSB7IHg6IDAsIHk6IDAsIHgyOiAwLCB5MjogMCB9O1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMSAmJiBub2RlRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMoZHJhZ0l0ZW1zKTtcbiAgICAgICAgICAgICAgICBub2Rlc0JveCA9IHJlY3RUb0JveChyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgbm90IGluIHRoZSBub2RlTG9va3VwIGFueW1vcmUsIGl0IHdhcyBwcm9iYWJseSBkZWxldGVkIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBpdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueCwgeTogeSAtIGRyYWdJdGVtLmRpc3RhbmNlLnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHNlbGVjdGlvbiB3aXRoIG11bHRpcGxlIG5vZGVzIGFuZCBhIG5vZGUgZXh0ZW50IGlzIHNldCwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG5vZGUgZXh0ZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBiYXNlZCBvbiBpdHMgcG9zaXRpb24gc28gdGhhdCB0aGUgbm9kZSBzdGF5cyBhdCBpdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgW25vZGVFeHRlbnRbMF1bMF0sIG5vZGVFeHRlbnRbMF1bMV1dLFxuICAgICAgICAgICAgICAgICAgICBbbm9kZUV4dGVudFsxXVswXSwgbm9kZUV4dGVudFsxXVsxXV0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAxICYmIG5vZGVFeHRlbnQgJiYgIWRyYWdJdGVtLmV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGRyYWdJdGVtLmludGVybmFscztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDEgPSBwb3NpdGlvbkFic29sdXRlLnggLSBub2Rlc0JveC54ICsgbm9kZUV4dGVudFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbkFic29sdXRlLnggKyBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbkFic29sdXRlLnkgLSBub2Rlc0JveC55ICsgbm9kZUV4dGVudFswXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTIgPSBwb3NpdGlvbkFic29sdXRlLnkgKyBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgLSBub2Rlc0JveC55MiArIG5vZGVFeHRlbnRbMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MSwgeTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3gyLCB5Ml0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUV4dGVudDogYWRqdXN0ZWROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSBoYXNDaGFuZ2UgfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueCAhPT0gcG9zaXRpb24ueCB8fCBkcmFnSXRlbS5wb3NpdGlvbi55ICE9PSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50ICYmIChvbkRyYWcgfHwgb25Ob2RlRHJhZyB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWcpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZz8uKGRyYWdFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYW5CeSwgYXV0b1BhblNwZWVkIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnggPSAobGFzdFBvcy54ID8/IDApIC0geE1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueSA9IChsYXN0UG9zLnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHBhbkJ5KHsgeDogeE1vdmVtZW50LCB5OiB5TW92ZW1lbnQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMobGFzdFBvcywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZXNEcmFnZ2FibGUsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIHNlbGVjdE5vZGVzT25EcmFnLCBvbk5vZGVEcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNTZWxlY3RhYmxlKSAmJiAhbXVsdGlTZWxlY3Rpb25BY3RpdmUgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHNlbGVjdGVkIG5vZGVzIHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZyAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBvbk5vZGVNb3VzZURvd24/Lihub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBkcmFnSXRlbXMgPSBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwICYmIChvbkRyYWdTdGFydCB8fCBvbk5vZGVEcmFnU3RhcnQgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQzRHJhZ0luc3RhbmNlID0gZHJhZygpXG4gICAgICAgICAgICAuY2xpY2tEaXN0YW5jZShub2RlQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGFib3J0RHJhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5vZGVEcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbDtcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlRHJhZ1RocmVzaG9sZCwgbm9kZUxvb2t1cCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkIH0pO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2htb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkZWxldGVzIGEgbm9kZSB3aGlsZSBkcmFnZ2luZywgd2UgbmVlZCB0byBhYm9ydCB0aGUgZHJhZyB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgIChub2RlSWQgJiYgIW5vZGVMb29rdXAuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICAgICAgYWJvcnREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5TdGFydGVkICYmIGF1dG9QYW5Pbk5vZGVEcmFnICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9pbnRlclBvcy54U25hcHBlZCAtIChsYXN0UG9zLnggPz8gMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBvaW50ZXJQb3MueVNuYXBwZWQgLSAobGFzdFBvcy55ID8/IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG5vZGVEcmFnVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBldmVudHMgd2l0aG91dCBtb3ZlbWVudFxuICAgICAgICAgICAgaWYgKChsYXN0UG9zLnggIT09IHBvaW50ZXJQb3MueFNuYXBwZWQgfHwgbGFzdFBvcy55ICE9PSBwb2ludGVyUG9zLnlTbmFwcGVkKSAmJiBkcmFnSXRlbXMgJiYgZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudCBhcyBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MsIGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkIHx8IGFib3J0RHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWdTdG9wIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAob25EcmFnU3RvcCB8fCBvbk5vZGVEcmFnU3RvcCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0b3A/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhZXZlbnQuYnV0dG9uICYmXG4gICAgICAgICAgICAgICAgKCFub0RyYWdDbGFzc05hbWUgfHwgIWhhc1NlbGVjdG9yKHRhcmdldCwgYC4ke25vRHJhZ0NsYXNzTmFtZX1gLCBkb21Ob2RlKSkgJiZcbiAgICAgICAgICAgICAgICAoIWhhbmRsZVNlbGVjdG9yIHx8IGhhc1NlbGVjdG9yKHRhcmdldCwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUpKTtcbiAgICAgICAgICAgIHJldHVybiBpc0RyYWdnYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLmNhbGwoZDNEcmFnSW5zdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1NlbGVjdGlvbj8ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCAtIGRpc3RhbmNlLFxuICAgICAgICB5OiBwb3NpdGlvbi55IC0gZGlzdGFuY2UsXG4gICAgICAgIHdpZHRoOiBkaXN0YW5jZSAqIDIsXG4gICAgICAgIGhlaWdodDogZGlzdGFuY2UgKiAyLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKGdldE92ZXJsYXBwaW5nQXJlYShyZWN0LCBub2RlVG9SZWN0KG5vZGUpKSA+IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuLy8gdGhpcyBkaXN0YW5jZSBpcyB1c2VkIGZvciB0aGUgYXJlYSBhcm91bmQgdGhlIHVzZXIgcG9pbnRlclxuLy8gd2hpbGUgZG9pbmcgYSBjb25uZWN0aW9uIGZvciBmaW5kaW5nIHRoZSBjbG9zZXN0IG5vZGVzXG5jb25zdCBBRERJVElPTkFMX0RJU1RBTkNFID0gMjUwO1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShwb3NpdGlvbiwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSkge1xuICAgIGxldCBjbG9zZXN0SGFuZGxlcyA9IFtdO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGNsb3NlTm9kZXMgPSBnZXROb2Rlc1dpdGhpbkRpc3RhbmNlKHBvc2l0aW9uLCBub2RlTG9va3VwLCBjb25uZWN0aW9uUmFkaXVzICsgQURESVRJT05BTF9ESVNUQU5DRSk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGNsb3NlTm9kZXMpIHtcbiAgICAgICAgY29uc3QgYWxsSGFuZGxlcyA9IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGUgb2YgYWxsSGFuZGxlcykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGhhbmRsZSBpcyB0aGUgc2FtZSBhcyB0aGUgZnJvbUhhbmRsZSB3ZSBza2lwIGl0XG4gICAgICAgICAgICBpZiAoZnJvbUhhbmRsZS5ub2RlSWQgPT09IGhhbmRsZS5ub2RlSWQgJiYgZnJvbUhhbmRsZS50eXBlID09PSBoYW5kbGUudHlwZSAmJiBmcm9tSGFuZGxlLmlkID09PSBoYW5kbGUuaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVybWluZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEhhbmRsZVBvc2l0aW9uKG5vZGUsIGhhbmRsZSwgaGFuZGxlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHggLSBwb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHkgLSBwb3NpdGlvbi55LCAyKSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBjb25uZWN0aW9uUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGVzID0gW3sgLi4uaGFuZGxlLCB4LCB5IH1dO1xuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgYXJlIG9uIHRoZSBzYW1lIGRpc3RhbmNlIHdlIGNvbGxlY3QgYWxsIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcy5wdXNoKHsgLi4uaGFuZGxlLCB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdEhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3aGVuIG11bHRpcGxlIGhhbmRsZXMgb3ZlcmxheSBlYWNoIG90aGVyIHdlIHByZWZlciB0aGUgb3Bwb3NpdGUgaGFuZGxlXG4gICAgaWYgKGNsb3Nlc3RIYW5kbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3Bwb3NpdGVIYW5kbGVUeXBlID0gZnJvbUhhbmRsZS50eXBlID09PSAnc291cmNlJyA/ICd0YXJnZXQnIDogJ3NvdXJjZSc7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SGFuZGxlcy5maW5kKChoYW5kbGUpID0+IGhhbmRsZS50eXBlID09PSBvcHBvc2l0ZUhhbmRsZVR5cGUpID8/IGNsb3Nlc3RIYW5kbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXNbMF07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHdpdGhBYnNvbHV0ZVBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXMgPSBjb25uZWN0aW9uTW9kZSA9PT0gJ3N0cmljdCdcbiAgICAgICAgPyBub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM/LltoYW5kbGVUeXBlXVxuICAgICAgICA6IFsuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCAuLi4obm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pXTtcbiAgICBjb25zdCBoYW5kbGUgPSAoaGFuZGxlSWQgPyBoYW5kbGVzPy5maW5kKChoKSA9PiBoLmlkID09PSBoYW5kbGVJZCkgOiBoYW5kbGVzPy5bMF0pID8/IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZSAmJiB3aXRoQWJzb2x1dGVQb3NpdGlvblxuICAgICAgICA/IHsgLi4uaGFuZGxlLCAuLi5nZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSkgfVxuICAgICAgICA6IGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKSB7XG4gICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gZWRnZVVwZGF0ZXJUeXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVEb21Ob2RlPy5jbGFzc0xpc3QuY29udGFpbnMoJ3RhcmdldCcpKSB7XG4gICAgICAgIHJldHVybiAndGFyZ2V0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCdzb3VyY2UnKSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uVmFsaWQoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzLCBpc0hhbmRsZVZhbGlkKSB7XG4gICAgbGV0IGlzVmFsaWQgPSBudWxsO1xuICAgIGlmIChpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMgJiYgIWlzSGFuZGxlVmFsaWQpIHtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbn1cblxuY29uc3QgYWx3YXlzVmFsaWQgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgeyBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvblJhZGl1cywgaGFuZGxlSWQsIG5vZGVJZCwgZWRnZVVwZGF0ZXJUeXBlLCBpc1RhcmdldCwgZG9tTm9kZSwgbm9kZUxvb2t1cCwgbGliLCBhdXRvUGFuT25Db25uZWN0LCBmbG93SWQsIHBhbkJ5LCBjYW5jZWxDb25uZWN0aW9uLCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0LCBvbkNvbm5lY3RFbmQsIGlzVmFsaWRDb25uZWN0aW9uID0gYWx3YXlzVmFsaWQsIG9uUmVjb25uZWN0RW5kLCB1cGRhdGVDb25uZWN0aW9uLCBnZXRUcmFuc2Zvcm0sIGdldEZyb21IYW5kbGUsIGF1dG9QYW5TcGVlZCwgfSkge1xuICAgIC8vIHdoZW4geHlmbG93IGlzIHVzZWQgaW5zaWRlIGEgc2hhZG93IHJvb3Qgd2UgY2FuJ3QgdXNlIGRvY3VtZW50XG4gICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBsZXQgYXV0b1BhbklkID0gMDtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGNsaWNrZWRIYW5kbGUgPSBkb2M/LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBjbGlja2VkSGFuZGxlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyb21IYW5kbGVJbnRlcm5hbCA9IGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSk7XG4gICAgaWYgKCFmcm9tSGFuZGxlSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCBoYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCB8fCAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3gsIHldID0gY2FsY0F1dG9QYW4ocG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgcGFuQnkoeyB4LCB5IH0pO1xuICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgfVxuICAgIC8vIFN0YXlzIHRoZSBzYW1lIGZvciBhbGwgY29uc2VjdXRpdmUgcG9pbnRlcm1vdmUgZXZlbnRzXG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IHtcbiAgICAgICAgLi4uZnJvbUhhbmRsZUludGVybmFsLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBmcm9tSGFuZGxlSW50ZXJuYWwucG9zaXRpb24sXG4gICAgfTtcbiAgICBjb25zdCBmcm9tTm9kZUludGVybmFsID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBmcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24oZnJvbU5vZGVJbnRlcm5hbCwgZnJvbUhhbmRsZSwgUG9zaXRpb24uTGVmdCwgdHJ1ZSk7XG4gICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgaW5Qcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgaXNWYWxpZDogbnVsbCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgZnJvbUhhbmRsZSxcbiAgICAgICAgZnJvbVBvc2l0aW9uOiBmcm9tSGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICBmcm9tTm9kZTogZnJvbU5vZGVJbnRlcm5hbCxcbiAgICAgICAgdG86IHBvc2l0aW9uLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICAgICAgdG9Qb3NpdGlvbjogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgdG9Ob2RlOiBudWxsLFxuICAgIH07XG4gICAgdXBkYXRlQ29ubmVjdGlvbihuZXdDb25uZWN0aW9uKTtcbiAgICBsZXQgcHJldmlvdXNDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcbiAgICBvbkNvbm5lY3RTdGFydD8uKGV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGUgfSk7XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWdldEZyb21IYW5kbGUoKSB8fCAhZnJvbUhhbmRsZSkge1xuICAgICAgICAgICAgb25Qb2ludGVyVXAoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNsb3Nlc3RIYW5kbGUgPSBnZXRDbG9zZXN0SGFuZGxlKHBvaW50VG9SZW5kZXJlclBvaW50KHBvc2l0aW9uLCB0cmFuc2Zvcm0sIGZhbHNlLCBbMSwgMV0pLCBjb25uZWN0aW9uUmFkaXVzLCBub2RlTG9va3VwLCBmcm9tSGFuZGxlKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWRIYW5kbGUoZXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZTogY2xvc2VzdEhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogbm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVEb21Ob2RlID0gcmVzdWx0LmhhbmRsZURvbU5vZGU7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IGlzQ29ubmVjdGlvblZhbGlkKCEhY2xvc2VzdEhhbmRsZSwgcmVzdWx0LmlzVmFsaWQpO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgLy8gZnJvbSBzdGF5cyB0aGUgc2FtZVxuICAgICAgICAgICAgLi4ucHJldmlvdXNDb25uZWN0aW9uLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIHRvOiBjbG9zZXN0SGFuZGxlICYmIGlzVmFsaWRcbiAgICAgICAgICAgICAgICA/IHJlbmRlcmVyUG9pbnRUb1BvaW50KHsgeDogY2xvc2VzdEhhbmRsZS54LCB5OiBjbG9zZXN0SGFuZGxlLnkgfSwgdHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIDogcG9zaXRpb24sXG4gICAgICAgICAgICB0b0hhbmRsZTogcmVzdWx0LnRvSGFuZGxlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogaXNWYWxpZCAmJiByZXN1bHQudG9IYW5kbGUgPyByZXN1bHQudG9IYW5kbGUucG9zaXRpb24gOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICAgICAgdG9Ob2RlOiByZXN1bHQudG9IYW5kbGUgPyBub2RlTG9va3VwLmdldChyZXN1bHQudG9IYW5kbGUubm9kZUlkKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbiB1cGRhdGUgd2hlbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyBpcyBzbmFwcGVkIHRvIHRoZSBzYW1lIGhhbmRsZSBhcyBiZWZvcmVcbiAgICAgICAgaWYgKGlzVmFsaWQgJiZcbiAgICAgICAgICAgIGNsb3Nlc3RIYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgbmV3Q29ubmVjdGlvbi50b0hhbmRsZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUudHlwZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLm5vZGVJZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5pZCA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS5pZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnggPT09IG5ld0Nvbm5lY3Rpb24udG8ueCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvLnkgPT09IG5ld0Nvbm5lY3Rpb24udG8ueSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICgoY2xvc2VzdEhhbmRsZSB8fCBoYW5kbGVEb21Ob2RlKSAmJiBjb25uZWN0aW9uICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdD8uKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRvIGdldCBhIGZyZXNoIHJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yZSBoZXJlXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIG9uQ29ubmVjdEVuZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgLi4uY29ubmVjdGlvblN0YXRlIH0gPSBwcmV2aW91c0Nvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGZpbmFsQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgLi4uY29ubmVjdGlvblN0YXRlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlID8gcHJldmlvdXNDb25uZWN0aW9uLnRvUG9zaXRpb24gOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBvbkNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbigpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBoYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xufVxuLy8gY2hlY2tzIGlmICBhbmQgcmV0dXJucyBjb25uZWN0aW9uIGluIGZvbSBvZiBhbiBvYmplY3QgeyBzb3VyY2U6IDEyMywgdGFyZ2V0OiAzMTIgfVxuZnVuY3Rpb24gaXNWYWxpZEhhbmRsZShldmVudCwgeyBoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBmcm9tTm9kZUlkLCBmcm9tSGFuZGxlSWQsIGZyb21UeXBlLCBkb2MsIGxpYiwgZmxvd0lkLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBub2RlTG9va3VwLCB9KSB7XG4gICAgY29uc3QgaXNUYXJnZXQgPSBmcm9tVHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3QgaGFuZGxlRG9tTm9kZSA9IGhhbmRsZVxuICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGAuJHtsaWJ9LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtmbG93SWR9LSR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvLyB3ZSBhbHdheXMgd2FudCB0byBwcmlvcml0aXplIHRoZSBoYW5kbGUgYmVsb3cgdGhlIG1vdXNlIGN1cnNvciBvdmVyIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGhhbmRsZSxcbiAgICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGNlbnRlciBvZiBhbm90aGVyIGhhbmRsZSBpcyBjbG9zZXIgdG8gdGhlIG1vdXNlIHBvaW50ZXIgdGhhbiB0aGUgaGFuZGxlIGJlbG93IHRoZSBjdXJzb3JcbiAgICBjb25zdCBoYW5kbGVUb0NoZWNrID0gaGFuZGxlQmVsb3c/LmNsYXNzTGlzdC5jb250YWlucyhgJHtsaWJ9LWZsb3dfX2hhbmRsZWApID8gaGFuZGxlQmVsb3cgOiBoYW5kbGVEb21Ob2RlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb246IG51bGwsXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIH07XG4gICAgaWYgKGhhbmRsZVRvQ2hlY2spIHtcbiAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVUb0NoZWNrKTtcbiAgICAgICAgY29uc3QgaGFuZGxlTm9kZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGUnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGVFbmQgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGVlbmQnKTtcbiAgICAgICAgaWYgKCFoYW5kbGVOb2RlSWQgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogaXNUYXJnZXQgPyBoYW5kbGVOb2RlSWQgOiBmcm9tTm9kZUlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBpc1RhcmdldCA/IGhhbmRsZUlkIDogZnJvbUhhbmRsZUlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCA/IGZyb21Ob2RlSWQgOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGlzVGFyZ2V0ID8gZnJvbUhhbmRsZUlkIDogaGFuZGxlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlICYmIGNvbm5lY3RhYmxlRW5kO1xuICAgICAgICAvLyBpbiBzdHJpY3QgbW9kZSB3ZSBkb24ndCBhbGxvdyB0YXJnZXQgdG8gdGFyZ2V0IG9yIHNvdXJjZSB0byBzb3VyY2UgY29ubmVjdGlvbnNcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgIChjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICAgICAgPyAoaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScpIHx8ICghaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVOb2RlSWQgIT09IGZyb21Ob2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGVJZCk7XG4gICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZCAmJiBpc1ZhbGlkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgcmVzdWx0LnRvSGFuZGxlID0gZ2V0SGFuZGxlKGhhbmRsZU5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBYWUhhbmRsZSA9IHtcbiAgICBvblBvaW50ZXJEb3duLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWRIYW5kbGUsXG59O1xuXG5mdW5jdGlvbiBYWU1pbmltYXAoeyBkb21Ob2RlLCBwYW5ab29tLCBnZXRUcmFuc2Zvcm0sIGdldFZpZXdTY2FsZSB9KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCwgem9vbVN0ZXAgPSAxMCwgcGFubmFibGUgPSB0cnVlLCB6b29tYWJsZSA9IHRydWUsIGludmVyc2VQYW4gPSBmYWxzZSwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB6b29tSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAhcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKlxuICAgICAgICAgICAgICAgIHpvb21TdGVwO1xuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0cmFuc2Zvcm1bMl0gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhKTtcbiAgICAgICAgICAgIHBhblpvb20uc2NhbGVUbyhuZXh0Wm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYW5TdGFydCA9IFswLCAwXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuU3RhcnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuU3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3RvdWNobW92ZScpIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFuQ3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYW5EZWx0YSA9IFtwYW5DdXJyZW50WzBdIC0gcGFuU3RhcnRbMF0sIHBhbkN1cnJlbnRbMV0gLSBwYW5TdGFydFsxXV07XG4gICAgICAgICAgICBwYW5TdGFydCA9IHBhbkN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSBnZXRWaWV3U2NhbGUoKSAqIE1hdGgubWF4KHRyYW5zZm9ybVsyXSwgTWF0aC5sb2codHJhbnNmb3JtWzJdKSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gLSBwYW5EZWx0YVswXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gLSBwYW5EZWx0YVsxXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHpvb21BbmRQYW5IYW5kbGVyID0gem9vbSgpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgcGFuU3RhcnRIYW5kbGVyKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tJywgcGFubmFibGUgPyBwYW5IYW5kbGVyIDogbnVsbClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbS53aGVlbCcsIHpvb21hYmxlID8gem9vbUhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoem9vbUFuZFBhbkhhbmRsZXIsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgcG9pbnRlcixcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCB2aWV3Q2hhbmdlZCA9IChwcmV2Vmlld3BvcnQsIGV2ZW50Vmlld3BvcnQpID0+IHByZXZWaWV3cG9ydC54ICE9PSBldmVudFZpZXdwb3J0LnggfHwgcHJldlZpZXdwb3J0LnkgIT09IGV2ZW50Vmlld3BvcnQueSB8fCBwcmV2Vmlld3BvcnQuem9vbSAhPT0gZXZlbnRWaWV3cG9ydC5rO1xuY29uc3QgdHJhbnNmb3JtVG9WaWV3cG9ydCA9ICh0cmFuc2Zvcm0pID0+ICh7XG4gICAgeDogdHJhbnNmb3JtLngsXG4gICAgeTogdHJhbnNmb3JtLnksXG4gICAgem9vbTogdHJhbnNmb3JtLmssXG59KTtcbmNvbnN0IHZpZXdwb3J0VG9UcmFuc2Zvcm0gPSAoeyB4LCB5LCB6b29tIH0pID0+IHpvb21JZGVudGl0eS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoem9vbSk7XG5jb25zdCBpc1dyYXBwZWRXaXRoQ2xhc3MgPSAoZXZlbnQsIGNsYXNzTmFtZSkgPT4gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoYC4ke2NsYXNzTmFtZX1gKTtcbmNvbnN0IGlzUmlnaHRDbGlja1BhbiA9IChwYW5PbkRyYWcsIHVzZWRCdXR0b24pID0+IHVzZWRCdXR0b24gPT09IDIgJiYgQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygyKTtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikub24oJ2VuZCcsIG9uRW5kKSA6IHNlbGVjdGlvbjtcbn07XG5jb25zdCB3aGVlbERlbHRhID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yID0gZXZlbnQuY3RybEtleSAmJiBpc01hY09zKCkgPyAxMCA6IDE7XG4gICAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiBmYWN0b3I7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBub1doZWVsQ2xhc3NOYW1lLCBkM1NlbGVjdGlvbiwgZDNab29tLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHpvb21PblBpbmNoLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tLCBvblBhblpvb21FbmQsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgLy8gZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgaWYgKCFpc01hY09zKCkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgcGFuT25TY3JvbGxNb2RlICE9PSBQYW5PblNjcm9sbE1vZGUuVmVydGljYWwpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWSAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkM1pvb20udHJhbnNsYXRlQnkoZDNTZWxlY3Rpb24sIC0oZGVsdGFYIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgLShkZWx0YVkgLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB7IGludGVybmFsOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQpO1xuICAgICAgICAvLyBmb3IgcGFuIG9uIHNjcm9sbCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQgY2FsbHMgb24gb3VyIG93blxuICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgdGhlIHN0YXJ0LCB6b29tIGFuZCBlbmQgZXZlbnRzIGZyb20gZDMtem9vbVxuICAgICAgICAvLyBiZWNhdXNlIHN0YXJ0IGFuZCBtb3ZlIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCBhbmQgbm90IG9uY2UgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICBpZiAoIXpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgb25QYW5ab29tU3RhcnQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoeyBub1doZWVsQ2xhc3NOYW1lLCBwcmV2ZW50U2Nyb2xsaW5nLCBkM1pvb21IYW5kbGVyIH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBkKSB7XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gZW5hYmxlIHBpbmNoIHpvb21pbmcgZXZlbiBpZiBwcmV2ZW50U2Nyb2xsaW5nIGlzIHNldCB0byBmYWxzZVxuICAgICAgICBjb25zdCBwcmV2ZW50Wm9vbSA9ICFwcmV2ZW50U2Nyb2xsaW5nICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcgJiYgIWV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGlmIChwcmV2ZW50Wm9vbSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkM1pvb21IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQsIGQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tU3RhcnQgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGl0IGhlcmUsIGJlY2F1c2UgaXQncyBhbHdheXMgMCBpbiB0aGUgXCJ6b29tXCIgZXZlbnRcbiAgICAgICAgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA9IGV2ZW50LnNvdXJjZUV2ZW50Py5idXR0b24gfHwgMDtcbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSB0cnVlO1xuICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb21TdGFydCkge1xuICAgICAgICAgICAgb25QYW5ab29tU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21IYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBvblBhbmVDb250ZXh0TWVudSwgb25UcmFuc2Zvcm1DaGFuZ2UsIG9uUGFuWm9vbSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9ICEhKG9uUGFuZUNvbnRleHRNZW51ICYmIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkpO1xuICAgICAgICBpZiAoIWV2ZW50LnNvdXJjZUV2ZW50Py5zeW5jKSB7XG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZShbZXZlbnQudHJhbnNmb3JtLngsIGV2ZW50LnRyYW5zZm9ybS55LCBldmVudC50cmFuc2Zvcm0ua10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb20gJiYgIWV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQuc291cmNlRXZlbnQsIHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21FbmQsIG9uUGFuZUNvbnRleHRNZW51LCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9uUGFuZUNvbnRleHRNZW51ICYmXG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApICYmXG4gICAgICAgICAgICAhem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiAmJlxuICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51KGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gZmFsc2U7XG4gICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICBpZiAob25QYW5ab29tRW5kICYmIHZpZXdDaGFuZ2VkKHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0LCBldmVudC50cmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy50aW1lcklkKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzZXRUaW1lb3V0IGZvciBwYW5PblNjcm9sbCB0byBzdXByZXNzIG11bHRpcGxlIGVuZCBldmVudHMgZmlyZWQgZHVyaW5nIHNjcm9sbFxuICAgICAgICAgICAgcGFuT25TY3JvbGwgPyAxNTAgOiAwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcih7IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHVzZXJTZWxlY3Rpb25BY3RpdmUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBsaWIsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHpvb21TY3JvbGwgPSB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgfHwgem9vbU9uU2Nyb2xsO1xuICAgICAgICBjb25zdCBwaW5jaFpvb20gPSB6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5O1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxICYmXG4gICAgICAgICAgICBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJlxuICAgICAgICAgICAgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19ub2RlYCkgfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX2VkZ2VgKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFsbCBpbnRlcmFjdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBwcmV2ZW50IGFsbCB6b29tIGV2ZW50c1xuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAhem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXpvb21PbkRvdWJsZUNsaWNrICYmICF6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGR1cmluZyBhIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGFsbCBvdGhlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm93aGVlbCBjbGFzcywgd2UgcHJldmVudCB6b29taW5nXG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm9wYW4gY2xhc3MsIHdlIHByZXZlbnQgcGFubmluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1BhbkNsYXNzTmFtZSkgJiZcbiAgICAgICAgICAgIChldmVudC50eXBlICE9PSAnd2hlZWwnIHx8IChwYW5PblNjcm9sbCAmJiBldmVudC50eXBlID09PSAnd2hlZWwnICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgZXZlbnQudG91Y2hlcz8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gaWYgeW91IG1hbmFnZSB0byBzdGFydCB3aXRoIDIgdG91Y2hlcywgd2UgcHJldmVudCBuYXRpdmUgem9vbVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gdGhlcmUgaXMgbm8gc2Nyb2xsIGhhbmRsaW5nIGVuYWJsZWQsIHdlIHByZXZlbnQgYWxsIHdoZWVsIGV2ZW50c1xuICAgICAgICBpZiAoIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICFwaW5jaFpvb20gJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG5vdCBtb3ZhYmxlLCB3ZSBwcmV2ZW50IGRyYWdnaW5nIGl0IHdpdGggbW91c2VzdGFydCBvciB0b3VjaHN0YXJ0XG4gICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgIXBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSBhbGxvdyByaWdodCBjbGlja3MgaWYgcGFuIG9uIGRyYWcgaXMgc2V0IHRvIHJpZ2h0IGNsaWNrXG4gICAgICAgIGNvbnN0IGJ1dHRvbkFsbG93ZWQgPSAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pKSB8fCAhZXZlbnQuYnV0dG9uIHx8IGV2ZW50LmJ1dHRvbiA8PSAxO1xuICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpICYmIGJ1dHRvbkFsbG93ZWQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gWFlQYW5ab29tKHsgZG9tTm9kZSwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuZUNsaWNrRGlzdGFuY2UsIHRyYW5zbGF0ZUV4dGVudCwgdmlld3BvcnQsIG9uUGFuWm9vbSwgb25QYW5ab29tU3RhcnQsIG9uUGFuWm9vbUVuZCwgb25EcmFnZ2luZ0NoYW5nZSwgfSkge1xuICAgIGNvbnN0IHpvb21QYW5WYWx1ZXMgPSB7XG4gICAgICAgIGlzWm9vbWluZ09yUGFubmluZzogZmFsc2UsXG4gICAgICAgIHVzZWRSaWdodE1vdXNlQnV0dG9uOiBmYWxzZSxcbiAgICAgICAgcHJldlZpZXdwb3J0OiB7IHg6IDAsIHk6IDAsIHpvb206IDAgfSxcbiAgICAgICAgbW91c2VCdXR0b246IDAsXG4gICAgICAgIHRpbWVySWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuU2Nyb2xsVGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICBpc1BhblNjcm9sbGluZzogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBiYm94ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBkM1pvb21JbnN0YW5jZSA9IHpvb20oKVxuICAgICAgICAuY2xpY2tEaXN0YW5jZSghaXNOdW1lcmljKHBhbmVDbGlja0Rpc3RhbmNlKSB8fCBwYW5lQ2xpY2tEaXN0YW5jZSA8IDAgPyAwIDogcGFuZUNsaWNrRGlzdGFuY2UpXG4gICAgICAgIC5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pXG4gICAgICAgIC50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKS5jYWxsKGQzWm9vbUluc3RhbmNlKTtcbiAgICBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdmlld3BvcnQueCxcbiAgICAgICAgeTogdmlld3BvcnQueSxcbiAgICAgICAgem9vbTogY2xhbXAodmlld3BvcnQuem9vbSwgbWluWm9vbSwgbWF4Wm9vbSksXG4gICAgfSwgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nKTtcbiAgICBjb25zdCBkM0RibENsaWNrWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScpO1xuICAgIGQzWm9vbUluc3RhbmNlLndoZWVsRGVsdGEod2hlZWxEZWx0YSk7XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblBhbmVDb250ZXh0TWVudSwgdXNlclNlbGVjdGlvbkFjdGl2ZSwgcGFuT25TY3JvbGwsIHBhbk9uRHJhZywgcGFuT25TY3JvbGxNb2RlLCBwYW5PblNjcm9sbFNwZWVkLCBwcmV2ZW50U2Nyb2xsaW5nLCB6b29tT25QaW5jaCwgem9vbU9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCBsaWIsIG9uVHJhbnNmb3JtQ2hhbmdlLCB9KSB7XG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICF6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZykge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUGFuT25TY3JvbGwgPSBwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlO1xuICAgICAgICBjb25zdCB3aGVlbEhhbmRsZXIgPSBpc1Bhbk9uU2Nyb2xsXG4gICAgICAgICAgICA/IGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGQzU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJywgd2hlZWxIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBzdGFydEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdzdGFydCcsIHN0YXJ0SGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbVxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUhhbmRsZXIgPSBjcmVhdGVQYW5ab29tSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnU6ICEhb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIHBhblpvb21IYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIGVuZFxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUVuZEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdlbmQnLCBwYW5ab29tRW5kSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY3JlYXRlRmlsdGVyKHtcbiAgICAgICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgIH0pO1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IGFkZCB6b29tT25Eb3VibGVDbGljayB0byB0aGUgZmlsdGVyIGFib3ZlIGJlY2F1c2VcbiAgICAgICAgLy8gZG91YmxlIHRhcHBpbmcgb24gdG91Y2ggc2NyZWVucyBjaXJjdW12ZW50cyB0aGUgZmlsdGVyIGFuZFxuICAgICAgICAvLyBkYmxjbGljay56b29tIGlzIGZpcmVkIG9uIHRoZSBzZWxlY3Rpb24gZGlyZWN0bHlcbiAgICAgICAgaWYgKHpvb21PbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIGQzRGJsQ2xpY2tab29tSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0Q29uc3RyYWluZWQodmlld3BvcnQsIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgY29udHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbUluc3RhbmNlPy5jb25zdHJhaW4oKShuZXh0VHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIGlmIChjb250cmFpbmVkVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0oY29udHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGNvbnRyYWluZWRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnQodmlld3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0obmV4dFRyYW5zZm9ybSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShuZXh0VHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN5bmNWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybS5rICE9PSB2aWV3cG9ydC56b29tIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS54ICE9PSB2aWV3cG9ydC54IHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS55ICE9PSB2aWV3cG9ydC55KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtLCBudWxsLCB7IHN5bmM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uID8gem9vbVRyYW5zZm9ybShkM1NlbGVjdGlvbi5ub2RlKCkpIDogeyB4OiAwLCB5OiAwLCBrOiAxIH07XG4gICAgICAgIHJldHVybiB7IHg6IHRyYW5zZm9ybS54LCB5OiB0cmFuc2Zvcm0ueSwgem9vbTogdHJhbnNmb3JtLmsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyh6b29tLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlVG8oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHpvb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlQnkoZmFjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlQnkoZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIGZhY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0U2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENsaWNrRGlzdGFuY2UoZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWREaXN0YW5jZSA9ICFpc051bWVyaWMoZGlzdGFuY2UpIHx8IGRpc3RhbmNlIDwgMCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LmNsaWNrRGlzdGFuY2UodmFsaWREaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgc2V0Vmlld3BvcnQsXG4gICAgICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQsXG4gICAgICAgIGdldFZpZXdwb3J0LFxuICAgICAgICBzY2FsZVRvLFxuICAgICAgICBzY2FsZUJ5LFxuICAgICAgICBzZXRTY2FsZUV4dGVudCxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBzeW5jVmlld3BvcnQsXG4gICAgICAgIHNldENsaWNrRGlzdGFuY2UsXG4gICAgfTtcbn1cblxudmFyIFJlc2l6ZUNvbnRyb2xWYXJpYW50O1xuKGZ1bmN0aW9uIChSZXNpemVDb250cm9sVmFyaWFudCkge1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiTGluZVwiXSA9IFwibGluZVwiO1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiSGFuZGxlXCJdID0gXCJoYW5kbGVcIjtcbn0pKFJlc2l6ZUNvbnRyb2xWYXJpYW50IHx8IChSZXNpemVDb250cm9sVmFyaWFudCA9IHt9KSk7XG5jb25zdCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMgPSBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXTtcbmNvbnN0IFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuXG4vKipcbiAqIEdldCBhbGwgY29ubmVjdGluZyBlZGdlcyBmb3IgYSBnaXZlbiBzZXQgb2Ygbm9kZXNcbiAqIEBwYXJhbSB3aWR0aCAtIG5ldyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZXaWR0aCAtIHByZXZpb3VzIHdpZHRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gbmV3IGhlaWdodCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZIZWlnaHQgLSBwcmV2aW91cyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBhZmZlY3RzWCAtIHdoZXRoZXIgdG8gaW52ZXJ0IHRoZSByZXNpemUgZGlyZWN0aW9uIGZvciB0aGUgeCBheGlzXG4gKiBAcGFyYW0gYWZmZWN0c1kgLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHkgYXhpc1xuICogQHJldHVybnMgYXJyYXkgb2YgdHdvIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlc2l6ZSBmb3IgZWFjaCBheGlzLCAwID0gbm8gY2hhbmdlLCAxID0gaW5jcmVhc2UsIC0xID0gZGVjcmVhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0UmVzaXplRGlyZWN0aW9uKHsgd2lkdGgsIHByZXZXaWR0aCwgaGVpZ2h0LCBwcmV2SGVpZ2h0LCBhZmZlY3RzWCwgYWZmZWN0c1ksIH0pIHtcbiAgICBjb25zdCBkZWx0YVdpZHRoID0gd2lkdGggLSBwcmV2V2lkdGg7XG4gICAgY29uc3QgZGVsdGFIZWlnaHQgPSBoZWlnaHQgLSBwcmV2SGVpZ2h0O1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFtkZWx0YVdpZHRoID4gMCA/IDEgOiBkZWx0YVdpZHRoIDwgMCA/IC0xIDogMCwgZGVsdGFIZWlnaHQgPiAwID8gMSA6IGRlbHRhSGVpZ2h0IDwgMCA/IC0xIDogMF07XG4gICAgaWYgKGRlbHRhV2lkdGggJiYgYWZmZWN0c1gpIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gZGlyZWN0aW9uWzBdICogLTE7XG4gICAgfVxuICAgIGlmIChkZWx0YUhlaWdodCAmJiBhZmZlY3RzWSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSBkaXJlY3Rpb25bMV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBjb250cm9sIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZCB0byBkaW1lbnNpb25zIHRoYXQgYXJlIGJlaW5nIHJlc2l6ZWRcbiAqIEBwYXJhbSBjb250cm9sUG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCB0aGF0IGlzIGJlaW5nIGRyYWdnZWRcbiAqIEByZXR1cm5zIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCwgYWZmZWN0c1gsIGFmZmVjdHNZLFxuICovXG5mdW5jdGlvbiBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygncmlnaHQnKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdib3R0b20nKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIGNvbnN0IGFmZmVjdHNYID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgYWZmZWN0c1kgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSG9yaXpvbnRhbCxcbiAgICAgICAgaXNWZXJ0aWNhbCxcbiAgICAgICAgYWZmZWN0c1gsXG4gICAgICAgIGFmZmVjdHNZLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMb3dlckV4dGVudENsYW1wKGxvd2VyRXh0ZW50LCBsb3dlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGxvd2VyQm91bmQgLSBsb3dlckV4dGVudCk7XG59XG5mdW5jdGlvbiBnZXRVcHBlckV4dGVudENsYW1wKHVwcGVyRXh0ZW50LCB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHVwcGVyRXh0ZW50IC0gdXBwZXJCb3VuZCk7XG59XG5mdW5jdGlvbiBnZXRTaXplQ2xhbXAoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBtaW5TaXplIC0gc2l6ZSwgc2l6ZSAtIG1heFNpemUpO1xufVxuZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/ICFiIDogYjtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBuZXcgd2lkdGggJiBoZWlnaHQgYW5kIHggJiB5IG9mIG5vZGUgYWZ0ZXIgcmVzaXplIGJhc2VkIG9uIHBvaW50ZXIgcG9zaXRpb25cbiAqIEBkZXNjcmlwdGlvbiAtIEJ1Y2tsZSB1cCwgdGhpcyBpcyBhIGNodW5reSBvbmUuLi4gSWYgeW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXcgZGltZW5zaW9ucyBvZiBhIG5vZGUgYWZ0ZXIgYSByZXNpemUsXG4gKiB5b3UgaGF2ZSB0byBhY2NvdW50IGZvciBhbGwgcG9zc2libGUgcmVzdHJpY3Rpb25zOiBtaW4vbWF4IHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSwgdGhlIG1heGltdW0gZXh0ZW50IHRoZSBub2RlIGlzIGFsbG93ZWRcbiAqIHRvIG1vdmUgaW4gKGluIHRoaXMgY2FzZTogcmVzaXplIGludG8pIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBub2RlLCB0aGUgbWluaW1hbCBleHRlbnQgZGV0ZXJtaW5lZCBieSBjaGlsZCBub2Rlc1xuICogd2l0aCBleHBhbmRQYXJlbnQgb3IgZXh0ZW50OiAncGFyZW50JyBzZXQgYW5kIG9oIHllYWgsIHRoZXNlIHRoaW5ncyBhbHNvIGhhdmUgdG8gd29yayB3aXRoIGtlZXBBc3BlY3RSYXRpbyFcbiAqIFRoZSB3YXkgdGhpcyBpcyBkb25lIGlzIGJ5IGRldGVybWluaW5nIGhvdyBtdWNoIGVhY2ggb2YgdGhlc2UgcmVzdHJpY3RpbmcgYWN0dWFsbHkgcmVzdHJpY3RzIHRoZSByZXNpemUgYW5kIHRoZW4gYXBwbHlpbmcgdGhlXG4gKiBzdHJvbmdlc3QgcmVzdHJpY3Rpb24uIEJlY2F1c2UgdGhlIHJlc2l6ZSBhZmZlY3RzIHgsIHkgYW5kIHdpZHRoLCBoZWlnaHQgYW5kIHdpZHRoLCBoZWlnaHQgb2YgYSBvcHBvc2luZyBzaWRlIHdpdGgga2VlcEFzcGVjdFJhdGlvLFxuICogdGhlIHJlc2l6ZSBhbW91bnQgaXMgYWx3YXlzIGtlcHQgaW4gZGlzdFggJiBkaXN0WSBhbW91bnQgKHRoZSBkaXN0YW5jZSBpbiBtb3VzZSBtb3ZlbWVudClcbiAqIEluc3RlYWQgb2YgY2xhbXBpbmcgZWFjaCB2YWx1ZSwgd2UgZmlyc3QgY2FsY3VsYXRlIHRoZSBiaWdnZXN0ICdjbGFtcCcgKGZvciB0aGUgbGFjayBvZiBhIGJldHRlciBuYW1lKSBhbmQgdGhlbiBhcHBseSBpdCB0byBhbGwgdmFsdWVzLlxuICogVG8gY29tcGxpY2F0ZSB0aGluZ3Mgbm9kZU9yaWdpbiBoYXMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50IGFzIHdlbGwuIFRoaXMgaXMgZG9uZSBieSBvZmZzZXR0aW5nIHRoZSBub2RlcyBhcyBpZiB0aGVpciBvcmlnaW4gaXMgWzAsIDBdLFxuICogdGhlbiBjYWxjdWxhdGluZyB0aGUgcmVzdHJpY3Rpb25zIGFzIHVzdWFsXG4gKiBAcGFyYW0gc3RhcnRWYWx1ZXMgLSBzdGFydGluZyB2YWx1ZXMgb2YgcmVzaXplXG4gKiBAcGFyYW0gY29udHJvbERpcmVjdGlvbiAtIGRpbWVuc2lvbnMgYWZmZWN0ZWQgYnkgdGhlIHJlc2l6ZVxuICogQHBhcmFtIHBvaW50ZXJQb3NpdGlvbiAtIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gY29ycmVjdGVkIGZvciBzbmFwcGluZ1xuICogQHBhcmFtIGJvdW5kYXJpZXMgLSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBrZWVwQXNwZWN0UmF0aW8gLSBwcmV2ZW50IGNoYW5nZXMgb2YgYXNwcmVjdCByYXRpb1xuICogQHJldHVybnMgeCwgeSwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbm9kZSBhZnRlciByZXNpemVcbiAqL1xuZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBjb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgZXh0ZW50LCBjaGlsZEV4dGVudCkge1xuICAgIGxldCB7IGFmZmVjdHNYLCBhZmZlY3RzWSB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCB7IGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpYWdvbmFsID0gaXNIb3Jpem9udGFsICYmIGlzVmVydGljYWw7XG4gICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IHBvaW50ZXJQb3NpdGlvbjtcbiAgICBjb25zdCB7IG1pbldpZHRoLCBtYXhXaWR0aCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQgfSA9IGJvdW5kYXJpZXM7XG4gICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IHN0YXJ0V2lkdGgsIGhlaWdodDogc3RhcnRIZWlnaHQsIGFzcGVjdFJhdGlvIH0gPSBzdGFydFZhbHVlcztcbiAgICBsZXQgZGlzdFggPSBNYXRoLmZsb29yKGlzSG9yaXpvbnRhbCA/IHhTbmFwcGVkIC0gc3RhcnRWYWx1ZXMucG9pbnRlclggOiAwKTtcbiAgICBsZXQgZGlzdFkgPSBNYXRoLmZsb29yKGlzVmVydGljYWwgPyB5U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJZIDogMCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBzdGFydFdpZHRoICsgKGFmZmVjdHNYID8gLWRpc3RYIDogZGlzdFgpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0ICsgKGFmZmVjdHNZID8gLWRpc3RZIDogZGlzdFkpO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSAtbm9kZU9yaWdpblswXSAqIHN0YXJ0V2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IC1ub2RlT3JpZ2luWzFdICogc3RhcnRIZWlnaHQ7XG4gICAgLy8gQ2hlY2sgaWYgbWF4V2lkdGgsIG1pbldXaWR0aCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQgYXJlIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBsZXQgY2xhbXBYID0gZ2V0U2l6ZUNsYW1wKG5ld1dpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgpO1xuICAgIGxldCBjbGFtcFkgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0LCBtaW5IZWlnaHQsIG1heEhlaWdodCk7XG4gICAgLy8gQ2hlY2sgaWYgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBkaXN0WSArIG9yaWdpbk9mZnNldFksIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZID4gMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgbGV0IHhFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGxldCB5RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBpZiAoYWZmZWN0c1ggJiYgZGlzdFggPiAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIGRpc3RYLCBjaGlsZEV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCwgY2hpbGRFeHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFksIGNoaWxkRXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1kgJiYgZGlzdFkgPCAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld0hlaWdodCwgY2hpbGRFeHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgYXNwZWN0IHJhdGlvIHJlc2l6aW5nIG9mIHRoZSBvdGhlciBzaWRlIGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtYXggZGltZW5zaW9ucyBtaWdodCBiZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RIZWlnaHRDbGFtcCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBtaW5IZWlnaHQsIG1heEhlaWdodCkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0SGVpZ2h0Q2xhbXApO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgbmV3V2lkdGggLyBhc3BlY3RSYXRpbywgZXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGV4dGVudFswXVsxXSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGlsZCBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyAoYWZmZWN0c1ggPyBkaXN0WCA6IC1kaXN0WCkgLyBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIHRoZSBzYW1lIHRoaW5nIGZvciB2ZXJ0aWNhbCByZXNpemluZ1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0V2lkdGhDbGFtcCA9IGdldFNpemVDbGFtcChuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgbWluV2lkdGgsIG1heFdpZHRoKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RXaWR0aENsYW1wKTtcbiAgICAgICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1kgJiYgIWFmZmVjdHNYICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMV1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIChhZmZlY3RzWSA/IGRpc3RZIDogLWRpc3RZKSAqIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFswXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzdFkgPSBkaXN0WSArIChkaXN0WSA8IDAgPyBjbGFtcFkgOiAtY2xhbXBZKTtcbiAgICBkaXN0WCA9IGRpc3RYICsgKGRpc3RYIDwgMCA/IGNsYW1wWCA6IC1jbGFtcFgpO1xuICAgIGlmIChrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdXaWR0aCA+IG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSAoeG9yKGFmZmVjdHNYLCBhZmZlY3RzWSkgPyAtZGlzdFggOiBkaXN0WCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RZIDogZGlzdFkpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSBkaXN0WCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNZID0gYWZmZWN0c1g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9IGRpc3RZICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgYWZmZWN0c1ggPSBhZmZlY3RzWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gYWZmZWN0c1ggPyBzdGFydFggKyBkaXN0WCA6IHN0YXJ0WDtcbiAgICBjb25zdCB5ID0gYWZmZWN0c1kgPyBzdGFydFkgKyBkaXN0WSA6IHN0YXJ0WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKSxcbiAgICAgICAgaGVpZ2h0OiBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKSxcbiAgICAgICAgeDogbm9kZU9yaWdpblswXSAqIGRpc3RYICogKCFhZmZlY3RzWCA/IDEgOiAtMSkgKyB4LFxuICAgICAgICB5OiBub2RlT3JpZ2luWzFdICogZGlzdFkgKiAoIWFmZmVjdHNZID8gMSA6IC0xKSArIHksXG4gICAgfTtcbn1cblxuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHg6IDAsIHk6IDAgfTtcbmNvbnN0IGluaXRTdGFydFZhbHVlcyA9IHtcbiAgICAuLi5pbml0UHJldlZhbHVlcyxcbiAgICBwb2ludGVyWDogMCxcbiAgICBwb2ludGVyWTogMCxcbiAgICBhc3BlY3RSYXRpbzogMSxcbn07XG5mdW5jdGlvbiBub2RlVG9QYXJlbnRFeHRlbnQobm9kZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW25vZGUubWVhc3VyZWQud2lkdGgsIG5vZGUubWVhc3VyZWQuaGVpZ2h0XSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIHBhcmVudCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHggPSBwYXJlbnQucG9zaXRpb24ueCArIGNoaWxkLnBvc2l0aW9uLng7XG4gICAgY29uc3QgeSA9IHBhcmVudC5wb3NpdGlvbi55ICsgY2hpbGQucG9zaXRpb24ueTtcbiAgICBjb25zdCB3aWR0aCA9IGNoaWxkLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2hpbGQubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WCA9IG5vZGVPcmlnaW5bMF0gKiB3aWR0aDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRZID0gbm9kZU9yaWdpblsxXSAqIGhlaWdodDtcbiAgICByZXR1cm4gW1xuICAgICAgICBbeCAtIG9yaWdpbk9mZnNldFgsIHkgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICAgICAgW3ggKyB3aWR0aCAtIG9yaWdpbk9mZnNldFgsIHkgKyBoZWlnaHQgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gWFlSZXNpemVyKHsgZG9tTm9kZSwgbm9kZUlkLCBnZXRTdG9yZUl0ZW1zLCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBjb250cm9sUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xEaXJlY3Rpb24gPSBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDsgLy8gTmVlZGVkIHRvIGZpeCBleHBhbmRQYXJlbnRcbiAgICAgICAgbGV0IHBhcmVudEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCB9KTtcbiAgICAgICAgICAgIHByZXZWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54ID8/IDAsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55ID8/IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJldlZhbHVlcyxcbiAgICAgICAgICAgICAgICBwb2ludGVyWDogeFNuYXBwZWQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclk6IHlTbmFwcGVkLFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwcmV2VmFsdWVzLndpZHRoIC8gcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkICYmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgbm9kZS5leHBhbmRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudEV4dGVudCA9IHBhcmVudE5vZGUgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnID8gbm9kZVRvUGFyZW50RXh0ZW50KHBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgY2hpbGQgbm9kZXMgdG8gY29ycmVjdCB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbnMgd2hlbiB0b3AvbGVmdCBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgbGFyZ2VzdCBtaW5pbWFsIGV4dGVudCB0aGUgcGFyZW50IG5vZGUgaXMgYWxsb3dlZCB0byByZXNpemUgdG9cbiAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hpbGRJZCwgY2hpbGRdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50SWQgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5jaGlsZC5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBjaGlsZC5leHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZXh0ZW50ID09PSAncGFyZW50JyB8fCBjaGlsZC5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBub2RlLCBjaGlsZC5vcmlnaW4gPz8gbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgubWluKGV4dGVudFswXVswXSwgY2hpbGRFeHRlbnRbMF1bMF0pLCBNYXRoLm1pbihleHRlbnRbMF1bMV0sIGNoaWxkRXh0ZW50WzBdWzFdKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1heChleHRlbnRbMV1bMF0sIGNoaWxkRXh0ZW50WzFdWzBdKSwgTWF0aC5tYXgoZXh0ZW50WzFdWzFdLCBjaGlsZEV4dGVudFsxXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IGV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbiB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeDogcHJldlgsIHk6IHByZXZZLCB3aWR0aDogcHJldldpZHRoLCBoZWlnaHQ6IHByZXZIZWlnaHQgfSA9IHByZXZWYWx1ZXM7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVPcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBzdG9yZU5vZGVPcmlnaW47XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIHBhcmVudEV4dGVudCwgY2hpbGRFeHRlbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNXaWR0aENoYW5nZSA9IHdpZHRoICE9PSBwcmV2V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBpc0hlaWdodENoYW5nZSA9IGhlaWdodCAhPT0gcHJldkhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlzWFBvc0NoYW5nZSA9IHggIT09IHByZXZYICYmIGlzV2lkdGhDaGFuZ2U7XG4gICAgICAgICAgICBjb25zdCBpc1lQb3NDaGFuZ2UgPSB5ICE9PSBwcmV2WSAmJiBpc0hlaWdodENoYW5nZTtcbiAgICAgICAgICAgIGlmICghaXNYUG9zQ2hhbmdlICYmICFpc1lQb3NDaGFuZ2UgJiYgIWlzV2lkdGhDaGFuZ2UgJiYgIWlzSGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzWFBvc0NoYW5nZSB8fCBpc1lQb3NDaGFuZ2UgfHwgbm9kZU9yaWdpblswXSA9PT0gMSB8fCBub2RlT3JpZ2luWzFdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnggPSBpc1hQb3NDaGFuZ2UgPyB4IDogcHJldlZhbHVlcy54O1xuICAgICAgICAgICAgICAgIGNoYW5nZS55ID0gaXNZUG9zQ2hhbmdlID8geSA6IHByZXZWYWx1ZXMueTtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnggPSBjaGFuZ2UueDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnkgPSBjaGFuZ2UueTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPSBpc1dpZHRoQ2hhbmdlID8gd2lkdGggOiBwcmV2VmFsdWVzLndpZHRoO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5oZWlnaHQgPSBpc0hlaWdodENoYW5nZSA/IGhlaWdodCA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/LigpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgWFlEcmFnLCBYWUhhbmRsZSwgWFlNaW5pbWFwLCBYWVBhblpvb20sIFhZUmVzaXplciwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLCBhZGRFZGdlLCBhZG9wdFVzZXJOb2RlcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgYm94VG9SZWN0LCBjYWxjQXV0b1BhbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBjbGFtcCwgY2xhbXBQb3NpdGlvbiwgY2xhbXBQb3NpdGlvblRvUGFyZW50LCBjcmVhdGVNYXJrZXJJZHMsIGRldldhcm4sIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBlcnJvck1lc3NhZ2VzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGZpdFZpZXcsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldEJlemllclBhdGgsIGdldEJvdW5kc09mQm94ZXMsIGdldEJvdW5kc09mUmVjdHMsIGdldENvbm5lY3RlZEVkZ2VzLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBnZXREaW1lbnNpb25zLCBnZXRFZGdlQ2VudGVyLCBnZXRFZGdlUG9zaXRpb24sIGdldEVsZW1lbnRzVG9SZW1vdmUsIGdldEVsZXZhdGVkRWRnZVpJbmRleCwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0Rml0Vmlld05vZGVzLCBnZXRIYW5kbGVCb3VuZHMsIGdldEhhbmRsZVBvc2l0aW9uLCBnZXRIb3N0Rm9yRWxlbWVudCwgZ2V0SW5jb21lcnMsIGdldEludGVybmFsTm9kZXNCb3VuZHMsIGdldE1hcmtlcklkLCBnZXROb2RlRGltZW5zaW9ucywgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiwgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0sIGdldE5vZGVzQm91bmRzLCBnZXROb2Rlc0luc2lkZSwgZ2V0T3V0Z29lcnMsIGdldE92ZXJsYXBwaW5nQXJlYSwgZ2V0UG9pbnRlclBvc2l0aW9uLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgaGFuZGxlRXhwYW5kUGFyZW50LCBpbmZpbml0ZUV4dGVudCwgaW5pdGlhbENvbm5lY3Rpb24sIGlzQ29vcmRpbmF0ZUV4dGVudCwgaXNFZGdlQmFzZSwgaXNFZGdlVmlzaWJsZSwgaXNJbnB1dERPTU5vZGUsIGlzSW50ZXJuYWxOb2RlQmFzZSwgaXNNYWNPcywgaXNNb3VzZUV2ZW50LCBpc05vZGVCYXNlLCBpc051bWVyaWMsIGlzUmVjdE9iamVjdCwgbm9kZUhhc0RpbWVuc2lvbnMsIG5vZGVUb0JveCwgbm9kZVRvUmVjdCwgb3Bwb3NpdGVQb3NpdGlvbiwgcGFuQnksIHBvaW50VG9SZW5kZXJlclBvaW50LCByZWNvbm5lY3RFZGdlLCByZWN0VG9Cb3gsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBzaGFsbG93Tm9kZURhdGEsIHNuYXBQb3NpdGlvbiwgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIHVwZGF0ZU5vZGVJbnRlcm5hbHMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/base.css":
/*!**************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/base.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ed7810b28e9d\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2Jhc2UuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJ1c2xhXFxPbmVEcml2ZVxc0KDQsNCx0L7Rh9C40Lkg0YHRgtC+0LtcXGdpdHZlcnNlLWNpY2RcXGdpdHZlcnNlLWNsaWVudFxcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxyZWFjdFxcZGlzdFxcYmFzZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJlZDc4MTBiMjhlOWRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/base.css\n");

/***/ })

};
;